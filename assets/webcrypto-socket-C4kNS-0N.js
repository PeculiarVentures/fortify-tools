var wa=function(Ee,gi,mi){/*!
 * MIT License
 *
 * Copyright (c) 2017-2022 Peculiar Ventures, LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */const os="[object ArrayBuffer]";class v{static isArrayBuffer(e){return Object.prototype.toString.call(e)===os}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||e.byteOffset===0&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=v.toUint8Array(e),i=v.toUint8Array(t);if(r.length!==i.byteLength)return!1;for(let s=0;s<r.length;s++)if(r[s]!==i[s])return!1;return!0}static concat(...e){let t;Array.isArray(e[0])&&!(e[1]instanceof Function)||Array.isArray(e[0])&&e[1]instanceof Function?t=e[0]:e[e.length-1]instanceof Function?t=e.slice(0,e.length-1):t=e;let r=0;for(const o of t)r+=o.byteLength;const i=new Uint8Array(r);let s=0;for(const o of t){const a=this.toUint8Array(o);i.set(a,s),s+=a.length}return e[e.length-1]instanceof Function?this.toView(i,e[e.length-1]):i.buffer}}const Xr="string",as=/^[0-9a-f]+$/i,cs=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,ls=/^[a-zA-Z0-9-_]+$/;class vi{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return r.buffer}static toString(e){const t=v.toUint8Array(e);let r="";for(let s=0;s<t.length;s++)r+=String.fromCharCode(t[s]);return decodeURIComponent(escape(r))}}class Ce{static toString(e,t=!1){const r=v.toArrayBuffer(e),i=new DataView(r);let s="";for(let o=0;o<r.byteLength;o+=2){const a=i.getUint16(o,t);s+=String.fromCharCode(a)}return s}static fromString(e,t=!1){const r=new ArrayBuffer(e.length*2),i=new DataView(r);for(let s=0;s<e.length;s++)i.setUint16(s*2,e.charCodeAt(s),t);return r}}class y{static isHex(e){return typeof e===Xr&&as.test(e)}static isBase64(e){return typeof e===Xr&&cs.test(e)}static isBase64Url(e){return typeof e===Xr&&ls.test(e)}static ToString(e,t="utf8"){const r=v.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return Ce.toString(r,!0);case"utf16":case"utf16be":return Ce.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return Ce.fromString(e,!0);case"utf16":case"utf16be":return Ce.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=v.toUint8Array(e);if(typeof btoa<"u"){const r=this.ToString(t,"binary");return btoa(r)}else return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!y.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!y.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=y.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return vi.fromString(e);case"utf16":case"utf16be":return Ce.fromString(e);case"utf16le":case"usc2":return Ce.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=y.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return vi.toString(e);case"utf16":case"utf16be":return Ce.toString(e);case"utf16le":case"usc2":return Ce.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.charCodeAt(i);return r.buffer}static ToBinary(e){const t=v.toUint8Array(e);let r="";for(let i=0;i<t.length;i++)r+=String.fromCharCode(t[i]);return r}static ToHex(e){const t=v.toUint8Array(e);let r="";const i=t.length;for(let s=0;s<i;s++){const o=t[s];o<16&&(r+="0"),r+=o.toString(16)}return r}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!y.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let i=0;i<t.length;i=i+2){const s=t.slice(i,i+2);r[i/2]=parseInt(s,16)}return r.buffer}static ToUtf16String(e,t=!1){return Ce.toString(e,t)}static FromUtf16String(e,t=!1){return Ce.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(e==null?void 0:e.replace(/[\n\r\t ]/g,""))||""}}y.DEFAULT_UTF8_ENCODING="utf8";function gt(n,...e){const t=arguments[0];for(let r=1;r<arguments.length;r++){const i=arguments[r];for(const s in i)t[s]=i[s]}return t}function mt(...n){const e=n.map(i=>i.byteLength).reduce((i,s)=>i+s),t=new Uint8Array(e);let r=0;return n.map(i=>new Uint8Array(i)).forEach(i=>{for(const s of i)t[r++]=s}),t.buffer}function wi(n,e){if(!(n&&e)||n.byteLength!==e.byteLength)return!1;const t=new Uint8Array(n),r=new Uint8Array(e);for(let i=0;i<n.byteLength;i++)if(t[i]!==r[i])return!1;return!0}function l(n,e,t,r){var i=arguments.length,s=i<3?e:r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,e,t,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(e,t,s):o(e,t))||s);return i>3&&s&&Object.defineProperty(e,t,s),s}typeof SuppressedError=="function"&&SuppressedError;class ye{static async set(e){return new Uint8Array(e)}static async get(e){return new Uint8Array(e).buffer}}function p(n){return e=>{const t=e;t.localName=n.name||t.name||t.toString().match(/^function\s*([^\s(]+)/)[1],t.items=t.items||{},t.target=e,t.items=gt({},t.items);const r=new gi.Type(t.localName);for(const i in t.items){const s=t.items[i];let o;s.repeated?o="repeated":s.required&&(o="required"),r.add(new gi.Field(s.name,s.id,s.type,o))}t.protobuf=r}}function us(n,e,t){const r=`_${e}`,i={set:function(s){this[r]!==s&&(this.raw=null,this[r]=s)},get:function(){if(this[r]===void 0){let s=t.defaultValue;t.parser&&!t.repeated&&(s=new t.parser),this[r]=s}return this[r]},enumerable:!0};Object.defineProperty(n,r,{writable:!0,enumerable:!1}),Object.defineProperty(n,e,i)}function u(n){return(e,t)=>{const r=e.constructor,i=t;r.items=r.items||{},r.target!==r&&(r.items=gt({},r.items),r.target=r),r.items[i]={id:n.id,type:n.type||"bytes",defaultValue:n.defaultValue,converter:n.converter||null,parser:n.parser||null,name:n.name||i,required:n.required||!1,repeated:n.repeated||!1},us(e,i,r.items[i])}}class ir{static async importProto(e){const t=new this;return await t.importProto(e),t}isEmpty(){return this.raw===void 0}hasChanged(){if(this.raw===null)return!0;const e=this.constructor,t=this;for(const r in e.items){const i=e.items[r];if(i.repeated){if(i.parser)return t[r].some(s=>s.hasChanged())}else if(i.parser&&t[r]&&t[r].hasChanged())return!0}return!1}async importProto(e){const t=this.constructor,r=this;let i,s;e instanceof ir?s=await e.exportProto():s=e;try{if(!t.protobuf)throw new Error("Protobuf schema doesn't contain 'protobuf' property");i=t.protobuf.decode(new Uint8Array(s))}catch(o){const a=o instanceof Error?o:new Error("Unknown error");throw new Error(`Cannot decode message for ${t.localName}.
$ProtobufError: ${a.message}`)}for(const o in t.items){const a=t.items[o];let c=i[a.name];ArrayBuffer.isView(c)&&(c=new Uint8Array(c)),Array.isArray(c)||(a.repeated?r[o]=c=[]:c=[c]),a.repeated&&!r[o]&&(r[o]=[]);for(const h of c)a.repeated?r[o].push(await this.importItem(a,h)):r[o]=await this.importItem(a,h)}this.raw=s}async exportProto(){if(!this.hasChanged())return this.raw;const e=this.constructor,t=this,r={};for(const i in e.items){const s=e.items[i];let o=t[i];Array.isArray(o)||(o=o===void 0?[]:[o]);for(const a of o){const c=await this.exportItem(s,a);s.repeated?(r[s.name]||(r[s.name]=[]),r[s.name].push(c)):r[s.name]=c}}return this.raw=new Uint8Array(e.protobuf.encode(r).finish()).buffer,this.raw}async exportItem(e,t){const r=this.constructor;let i;if(e.parser){const o=await t.exportProto();if(e.required&&!o)throw new Error(`Parameter '${e.name}' is required in '${r.localName}' protobuf message.`);o&&(i=new Uint8Array(o))}else{if(e.required&&t===void 0)throw new Error(`Parameter '${e.name}' is required in '${r.localName}' protobuf message.`);e.converter?t!==void 0&&(i=await e.converter.set(t)):(t instanceof ArrayBuffer&&(t=new Uint8Array(t)),i=t)}return i}async importItem(e,t){const r=this.constructor;let i;if(e.parser){const s=e.parser;if(t&&t.byteLength)i=await s.importProto(new Uint8Array(t).buffer);else if(e.required)throw new Error(`Parameter '${e.name}' is required in '${r.localName}' protobuf message.`)}else if(e.converter){if(t&&t.byteLength)i=await e.converter.get(t);else if(e.required)throw new Error(`Parameter '${e.name}' is required in '${r.localName}' protobuf message.`)}else i=t;return i}}var hs;function qe(){}qe.prototype=Object.create(null);function P(){P.init.call(this)}P.EventEmitter=P,P.usingDomains=!1,P.prototype.domain=void 0,P.prototype._events=void 0,P.prototype._maxListeners=void 0,P.defaultMaxListeners=10,P.init=function(){this.domain=null,P.usingDomains&&hs.active,(!this._events||this._events===Object.getPrototypeOf(this)._events)&&(this._events=new qe,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},P.prototype.setMaxListeners=function(e){if(typeof e!="number"||e<0||isNaN(e))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=e,this};function Ei(n){return n._maxListeners===void 0?P.defaultMaxListeners:n._maxListeners}P.prototype.getMaxListeners=function(){return Ei(this)};function fs(n,e,t){if(e)n.call(t);else for(var r=n.length,i=Ct(n,r),s=0;s<r;++s)i[s].call(t)}function ds(n,e,t,r){if(e)n.call(t,r);else for(var i=n.length,s=Ct(n,i),o=0;o<i;++o)s[o].call(t,r)}function ys(n,e,t,r,i){if(e)n.call(t,r,i);else for(var s=n.length,o=Ct(n,s),a=0;a<s;++a)o[a].call(t,r,i)}function ps(n,e,t,r,i,s){if(e)n.call(t,r,i,s);else for(var o=n.length,a=Ct(n,o),c=0;c<o;++c)a[c].call(t,r,i,s)}function gs(n,e,t,r){if(e)n.apply(t,r);else for(var i=n.length,s=Ct(n,i),o=0;o<i;++o)s[o].apply(t,r)}P.prototype.emit=function(e){var t,r,i,s,o,a,c,h=e==="error";if(a=this._events,a)h=h&&a.error==null;else if(!h)return!1;if(c=this.domain,h){if(t=arguments[1],c)t||(t=new Error('Uncaught, unspecified "error" event')),t.domainEmitter=this,t.domain=c,t.domainThrown=!1,c.emit("error",t);else{if(t instanceof Error)throw t;var d=new Error('Uncaught, unspecified "error" event. ('+t+")");throw d.context=t,d}return!1}if(r=a[e],!r)return!1;var f=typeof r=="function";switch(i=arguments.length,i){case 1:fs(r,f,this);break;case 2:ds(r,f,this,arguments[1]);break;case 3:ys(r,f,this,arguments[1],arguments[2]);break;case 4:ps(r,f,this,arguments[1],arguments[2],arguments[3]);break;default:for(s=new Array(i-1),o=1;o<i;o++)s[o-1]=arguments[o];gs(r,f,this,s)}return!0};function Ai(n,e,t,r){var i,s,o;if(typeof t!="function")throw new TypeError('"listener" argument must be a function');if(s=n._events,s?(s.newListener&&(n.emit("newListener",e,t.listener?t.listener:t),s=n._events),o=s[e]):(s=n._events=new qe,n._eventsCount=0),!o)o=s[e]=t,++n._eventsCount;else if(typeof o=="function"?o=s[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),!o.warned&&(i=Ei(n),i&&i>0&&o.length>i)){o.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+e+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=n,a.type=e,a.count=o.length,ms(a)}return n}function ms(n){typeof console.warn=="function"?console.warn(n):console.log(n)}P.prototype.addListener=function(e,t){return Ai(this,e,t,!1)},P.prototype.on=P.prototype.addListener,P.prototype.prependListener=function(e,t){return Ai(this,e,t,!0)};function bi(n,e,t){var r=!1;function i(){n.removeListener(e,i),r||(r=!0,t.apply(n,arguments))}return i.listener=t,i}P.prototype.once=function(e,t){if(typeof t!="function")throw new TypeError('"listener" argument must be a function');return this.on(e,bi(this,e,t)),this},P.prototype.prependOnceListener=function(e,t){if(typeof t!="function")throw new TypeError('"listener" argument must be a function');return this.prependListener(e,bi(this,e,t)),this},P.prototype.removeListener=function(e,t){var r,i,s,o,a;if(typeof t!="function")throw new TypeError('"listener" argument must be a function');if(i=this._events,!i)return this;if(r=i[e],!r)return this;if(r===t||r.listener&&r.listener===t)--this._eventsCount===0?this._events=new qe:(delete i[e],i.removeListener&&this.emit("removeListener",e,r.listener||t));else if(typeof r!="function"){for(s=-1,o=r.length;o-- >0;)if(r[o]===t||r[o].listener&&r[o].listener===t){a=r[o].listener,s=o;break}if(s<0)return this;if(r.length===1){if(r[0]=void 0,--this._eventsCount===0)return this._events=new qe,this;delete i[e]}else vs(r,s);i.removeListener&&this.emit("removeListener",e,a||t)}return this},P.prototype.removeAllListeners=function(e){var t,r;if(r=this._events,!r)return this;if(!r.removeListener)return arguments.length===0?(this._events=new qe,this._eventsCount=0):r[e]&&(--this._eventsCount===0?this._events=new qe:delete r[e]),this;if(arguments.length===0){for(var i=Object.keys(r),s=0,o;s<i.length;++s)o=i[s],o!=="removeListener"&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=new qe,this._eventsCount=0,this}if(t=r[e],typeof t=="function")this.removeListener(e,t);else if(t)do this.removeListener(e,t[t.length-1]);while(t[0]);return this},P.prototype.listeners=function(e){var t,r,i=this._events;return i?(t=i[e],t?typeof t=="function"?r=[t.listener||t]:r=ws(t):r=[]):r=[],r},P.listenerCount=function(n,e){return typeof n.listenerCount=="function"?n.listenerCount(e):Ii.call(n,e)},P.prototype.listenerCount=Ii;function Ii(n){var e=this._events;if(e){var t=e[n];if(typeof t=="function")return 1;if(t)return t.length}return 0}P.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};function vs(n,e){for(var t=e,r=t+1,i=n.length;r<i;t+=1,r+=1)n[t]=n[r];n.pop()}function Ct(n,e){for(var t=new Array(e);e--;)t[e]=n[e];return t}function ws(n){for(var e=new Array(n.length),t=0;t<e.length;++t)e[t]=n[t].listener||n[t];return e}const Es="ECDSA",As="ECDH",Ni="AES-CBC",ki="SHA-256",Bi="HMAC",Si=20,xi=y.FromBinary("InfoText"),bs=y.FromBinary("InfoRatchet"),Ci=y.FromBinary("InfoMessageKeys");let nr=null;typeof self<"u"&&(nr={crypto:self.crypto,name:"WebCrypto"});function Is(n,e){nr={crypto:e,name:n}}function k(){if(!nr)throw new Error("WebCrypto engine is empty. Use setEngine to resolve it.");return nr}let x=(()=>{class n{static async generateKeyPair(t,r){const i=t,s=t==="ECDSA"?["sign","verify"]:["deriveKey","deriveBits"],o=await k().crypto.subtle.generateKey({name:i,namedCurve:this.NAMED_CURVE},r,s),a=await pe.create(o.publicKey);return{privateKey:o.privateKey,publicKey:a}}static deriveBytes(t,r){return k().crypto.subtle.deriveBits({name:"ECDH",public:r.key},t,256)}static verify(t,r,i){return k().crypto.subtle.verify({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t.key,i,r)}static async sign(t,r){return k().crypto.subtle.sign({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t,r)}static async ecKeyPairToJson(t){return{privateKey:t.privateKey,publicKey:t.publicKey.key,thumbprint:await t.publicKey.thumbprint()}}static async ecKeyPairFromJson(t){return{privateKey:t.privateKey,publicKey:await pe.create(t.publicKey)}}}return n.NAMED_CURVE="P-256",n.DIGEST_ALGORITHM="SHA-512",n})();const Ns={name:"AES-CBC",length:256};class H{static randomBytes(e){const t=new Uint8Array(e);return k().crypto.getRandomValues(t),t.buffer}static digest(e,t){return k().crypto.subtle.digest(e,t)}static encrypt(e,t,r){return k().crypto.subtle.encrypt({name:Ni,iv:new Uint8Array(r)},e,t)}static decrypt(e,t,r){return k().crypto.subtle.decrypt({name:Ni,iv:new Uint8Array(r)},e,t)}static importHMAC(e){return k().crypto.subtle.importKey("raw",e,{name:Bi,hash:{name:ki}},!1,["sign","verify"])}static importAES(e){return k().crypto.subtle.importKey("raw",e,Ns,!1,["encrypt","decrypt"])}static async sign(e,t){return await k().crypto.subtle.sign({name:Bi,hash:ki},e,t)}static async HKDF(e,t=1,r,i=new ArrayBuffer(0)){r||(r=await this.importHMAC(new Uint8Array(32).buffer));const s=await this.sign(r,e);new ArrayBuffer(32+i.byteLength+1);const o=await this.importHMAC(s),a=[new ArrayBuffer(0)];for(let c=0;c<t;c++)a[c+1]=await this.sign(o,mt(a[c],i,new Uint8Array([c+1]).buffer));return a.slice(1)}}class pe{static async create(e){const t=new this,r=e.algorithm.name.toUpperCase();if(!(r==="ECDH"||r==="ECDSA"))throw new Error("Error: Unsupported asymmetric key algorithm.");if(e.type!=="public")throw new Error("Error: Expected key type to be public but it was not.");t.key=e;const i=await k().crypto.subtle.exportKey("jwk",e);if(!(i.x&&i.y))throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const s=y.FromBase64Url(i.x),o=y.FromBase64Url(i.y),a=y.ToBinary(s)+y.ToBinary(o);return t.serialized=y.FromBinary(a),t.id=await t.thumbprint(),t}static async importKey(e,t){const r=y.ToBase64Url(e.slice(0,32)),i=y.ToBase64Url(e.slice(32)),s={crv:x.NAMED_CURVE,kty:"EC",x:r,y:i},o=t==="ECDSA"?["verify"]:[],a=await k().crypto.subtle.importKey("jwk",s,{name:t,namedCurve:x.NAMED_CURVE},!0,o);return await pe.create(a)}serialize(){return this.serialized}async thumbprint(){const e=await this.serialize(),t=await H.digest("SHA-256",e);return y.ToHex(t)}async isEqual(e){return e&&e instanceof pe?wi(this.serialized,e.serialized):!1}}class sr{constructor(e,t,r){this.id=e,this.signingKey=t,this.exchangeKey=r,this.preKeys=[],this.signedPreKeys=[]}static async fromJSON(e){const t=await x.ecKeyPairFromJson(e.signingKey),r=await x.ecKeyPairFromJson(e.exchangeKey),i=new this(e.id,t,r);return i.createdAt=new Date(e.createdAt),await i.fromJSON(e),i}static async create(e,t=0,r=0,i=!1){const s=await x.generateKeyPair(Es,i),o=await x.generateKeyPair(As,i),a=new sr(e,s,o);a.createdAt=new Date;for(let c=0;c<r;c++)a.preKeys.push(await x.generateKeyPair("ECDH",i));for(let c=0;c<t;c++)a.signedPreKeys.push(await x.generateKeyPair("ECDH",i));return a}async toJSON(){const e=[],t=[];for(const r of this.preKeys)e.push(await x.ecKeyPairToJson(r));for(const r of this.signedPreKeys)t.push(await x.ecKeyPairToJson(r));return{createdAt:this.createdAt.toISOString(),exchangeKey:await x.ecKeyPairToJson(this.exchangeKey),id:this.id,preKeys:e,signedPreKeys:t,signingKey:await x.ecKeyPairToJson(this.signingKey)}}async fromJSON(e){this.id=e.id,this.signingKey=await x.ecKeyPairFromJson(e.signingKey),this.exchangeKey=await x.ecKeyPairFromJson(e.exchangeKey),this.preKeys=[];for(const t of e.preKeys)this.preKeys.push(await x.ecKeyPairFromJson(t));this.signedPreKeys=[];for(const t of e.signedPreKeys)this.signedPreKeys.push(await x.ecKeyPairFromJson(t))}}class Dt{static fill(e){const t=new Dt;return t.fill(e),t}static async fromJSON(e){const t=new this;return await t.fromJSON(e),t}fill(e){this.signingKey=e.signingKey,this.exchangeKey=e.exchangeKey,this.signature=e.signature,this.createdAt=e.createdAt}verify(){return x.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async toJSON(){return{createdAt:this.createdAt.toISOString(),exchangeKey:await this.exchangeKey.key,id:this.id,signature:this.signature,signingKey:await this.signingKey.key,thumbprint:await this.signingKey.thumbprint()}}async fromJSON(e){if(this.id=e.id,this.signature=e.signature,this.signingKey=await pe.create(e.signingKey),this.exchangeKey=await pe.create(e.exchangeKey),this.createdAt=new Date(e.createdAt),!await this.verify())throw new Error("Error: Wrong signature for RemoteIdentity")}}let vt=(()=>{let n=class extends ir{};return l([u({id:0,type:"uint32",defaultValue:1})],n.prototype,"version",void 0),n=l([p({name:"Base"})],n),n})();class Di{static async set(e){return new Uint8Array(e.serialize())}static async get(e){return pe.importKey(e.buffer,"ECDSA")}}class or{static async set(e){return new Uint8Array(e.serialize())}static async get(e){return pe.importKey(e.buffer,"ECDH")}}let ks=class{static async set(e){return new Uint8Array(y.FromString(e.toISOString()))}static async get(e){return new Date(y.ToString(e))}},Ki=(()=>{var n;let e=n=class extends vt{static async fill(r){const i=new n;return await i.fill(r),i}async sign(r){this.signature=await x.sign(r,this.exchangeKey.serialize())}async verify(){return await x.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async fill(r){this.signingKey=r.signingKey.publicKey,this.exchangeKey=r.exchangeKey.publicKey,this.createdAt=r.createdAt,await this.sign(r.signingKey.privateKey)}};return l([u({id:1,converter:Di})],e.prototype,"signingKey",void 0),l([u({id:2,converter:or})],e.prototype,"exchangeKey",void 0),l([u({id:3})],e.prototype,"signature",void 0),l([u({id:4,converter:ks})],e.prototype,"createdAt",void 0),e=n=l([p({name:"Identity"})],e),e})(),Bs=(()=>{let n=class extends vt{};return l([u({id:1,converter:or,required:!0})],n.prototype,"senderRatchetKey",void 0),l([u({id:2,type:"uint32",required:!0})],n.prototype,"counter",void 0),l([u({id:3,type:"uint32",required:!0})],n.prototype,"previousCounter",void 0),l([u({id:4,converter:ye,required:!0})],n.prototype,"cipherText",void 0),n=l([p({name:"Message"})],n),n})(),Lr=(()=>{let n=class extends vt{async sign(t){this.signature=await this.signHMAC(t)}async verify(t){const r=await this.signHMAC(t);return wi(r,this.signature)}async getSignedRaw(){const t=this.receiverKey.serialize(),r=this.senderKey.serialize(),i=await this.message.exportProto();return mt(t,r,i)}async signHMAC(t){const r=await this.getSignedRaw();return await H.sign(t,r)}};return l([u({id:1,converter:Di,required:!0})],n.prototype,"senderKey",void 0),l([u({id:2,parser:Bs,required:!0})],n.prototype,"message",void 0),l([u({id:3,required:!0})],n.prototype,"signature",void 0),n=l([p({name:"MessageSigned"})],n),n})(),Ss=(()=>{let n=class extends vt{};return l([u({id:1,type:"uint32",required:!0})],n.prototype,"registrationId",void 0),l([u({id:2,type:"uint32"})],n.prototype,"preKeyId",void 0),l([u({id:3,type:"uint32",required:!0})],n.prototype,"preKeySignedId",void 0),l([u({id:4,converter:or,required:!0})],n.prototype,"baseKey",void 0),l([u({id:5,parser:Ki,required:!0})],n.prototype,"identity",void 0),l([u({id:6,parser:Lr,required:!0})],n.prototype,"signedMessage",void 0),n=l([p({name:"PreKeyMessage"})],n),n})(),Pi=(()=>{let n=class extends vt{};return l([u({id:1,type:"uint32",required:!0})],n.prototype,"id",void 0),l([u({id:2,converter:or,required:!0})],n.prototype,"key",void 0),n=l([p({name:"PreKey"})],n),n})(),xs=(()=>{let n=class extends Pi{async sign(t){this.signature=await x.sign(t,this.key.serialize())}verify(t){return x.verify(t,this.key.serialize(),this.signature)}};return l([u({id:3,converter:ye,required:!0})],n.prototype,"signature",void 0),n=l([p({name:"PreKeySigned"})],n),n})(),Oi=(()=>{let n=class extends vt{};return l([u({id:1,type:"uint32",required:!0})],n.prototype,"registrationId",void 0),l([u({id:2,parser:Ki,required:!0})],n.prototype,"identity",void 0),l([u({id:3,parser:Pi})],n.prototype,"preKey",void 0),l([u({id:4,parser:xs,required:!0})],n.prototype,"preKeySigned",void 0),n=l([p({name:"PreKeyBundle"})],n),n})();class Cs{constructor(e=20){this.items=[],this.maxSize=e}get length(){return this.items.length}get latest(){return this.items[this.length-1]}push(e){this.length===this.maxSize&&(this.items=this.items.slice(1)),this.items.push(e)}async toJSON(){const e=[];for(const t of this.items)e.push(await t.toJSON());return e}async fromJSON(e){this.items=e}}const Ds=new Uint8Array([1]).buffer,Ks=new Uint8Array([2]).buffer;class Ti{constructor(e){this.counter=0,this.rootKey=e}static async fromJSON(e){const t=new this(e.rootKey);return t.fromJSON(e),t}async toJSON(){return{counter:this.counter,rootKey:this.rootKey}}async fromJSON(e){this.counter=e.counter,this.rootKey=e.rootKey}async calculateKey(e){const t=await H.sign(e,Ds),r=await H.sign(e,Ks);return{cipher:t,rootKey:await H.importHMAC(r)}}async click(){const e=this.rootKey,t=await this.calculateKey(e);return this.rootKey=t.rootKey,this.counter++,t.cipher}}class Ui extends Ti{async encrypt(e){const t=await this.click(),r=await H.HKDF(t,3,void 0,Ci),i=await H.importAES(r[0]),s=await H.importHMAC(r[1]),o=r[2].slice(0,16);return{cipherText:await H.encrypt(i,e,o),hmacKey:s}}}class Vi extends Ti{constructor(){super(...arguments),this.keys=[]}async toJSON(){const e=await super.toJSON();return e.keys=this.keys,e}async fromJSON(e){await super.fromJSON(e),this.keys=e.keys}async decrypt(e,t){const r=await this.getKey(t),i=await H.HKDF(r,3,void 0,Ci),s=await H.importAES(i[0]),o=await H.importHMAC(i[1]),a=i[2].slice(0,16);return{cipherText:await H.decrypt(s,e,a),hmacKey:o}}async getKey(e){for(;this.counter<=e;){const r=await this.click();this.keys.push(r)}return this.keys[e]}}async function Ps(n,e,t,r,i){const s=await x.deriveBytes(n.exchangeKey.privateKey,r),o=await x.deriveBytes(e.privateKey,t),a=await x.deriveBytes(e.privateKey,r);let c=new ArrayBuffer(0);i&&(c=await x.deriveBytes(e.privateKey,i));const h=new Uint8Array(32);for(let S=0;S<h.length;S++)h[S]=255;const d=h.buffer,f=mt(d,s,o,a,c),b=await H.HKDF(f,1,void 0,xi);return await H.importHMAC(b[0])}async function Os(n,e,t,r,i){const s=await x.deriveBytes(e.privateKey,t),o=await x.deriveBytes(n.exchangeKey.privateKey,r),a=await x.deriveBytes(e.privateKey,r);let c=new ArrayBuffer(0);i&&(c=await x.deriveBytes(i,r));const h=new Uint8Array(32);for(let S=0;S<h.length;S++)h[S]=255;const d=h.buffer,f=mt(d,s,o,a,c),b=await H.HKDF(f,1,void 0,xi);return await H.importHMAC(b[0])}class Kt extends P{constructor(e={}){super(),this.options=e,this.counter=0,this.currentStep=new Hr,this.steps=new Ts(Si),this.promises={}}static async create(e,t,r={}){let i;const s=new Kt(r);if(t instanceof Oi){if(!await t.identity.verify())throw new Error("Error: Remote client's identity key is invalid.");if(!await t.preKeySigned.verify(t.identity.signingKey))throw new Error("Error: Remote client's signed prekey is invalid.");s.currentRatchetKey=await s.generateRatchetKey(),s.currentStep.remoteRatchetKey=t.preKeySigned.key,s.remoteIdentity=Dt.fill(t.identity),s.remoteIdentity.id=t.registrationId,s.remotePreKeyId=t.preKey.id,s.remotePreKeySignedId=t.preKeySigned.id,i=await Ps(e,s.currentRatchetKey,t.identity.exchangeKey,t.preKeySigned.key,t.preKey.key)}else{if(!await t.identity.verify())throw new Error("Error: Remote client's identity key is invalid.");const o=e.signedPreKeys[t.preKeySignedId];if(!o)throw new Error(`Error: PreKey with id ${t.preKeySignedId} not found`);let a;t.preKeyId!==void 0&&(a=e.preKeys[t.preKeyId]),s.remoteIdentity=Dt.fill(t.identity),s.currentRatchetKey=o,i=await Os(e,s.currentRatchetKey,t.identity.exchangeKey,t.signedMessage.message.senderRatchetKey,a&&a.privateKey)}return s.identity=e,s.id=e.id,s.rootKey=i,s}static async fromJSON(e,t,r){const i=new Kt;return i.identity=e,i.remoteIdentity=t,await i.fromJSON(r),i}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async decrypt(e){return this.queuePromise("encrypt",async()=>{const t=e.message.senderRatchetKey,r=e.message;if(e.message.previousCounter<this.counter-Si)throw new Error("Error: Too old message");let i=this.steps.getStep(t);if(!i){const o=new Hr;o.remoteRatchetKey=t,this.steps.push(o),this.currentStep=o,i=o}i.receivingChain||(i.receivingChain=await this.createChain(this.currentRatchetKey.privateKey,t,Vi));const s=await i.receivingChain.decrypt(r.cipherText,r.counter);if(this.update(),e.senderKey=this.remoteIdentity.signingKey,e.receiverKey=this.identity.signingKey.publicKey,!await e.verify(s.hmacKey))throw new Error("Error: The Message did not successfully verify!");return s.cipherText})}async encrypt(e){return this.queuePromise("encrypt",async()=>{if(this.currentStep.receivingChain&&!this.currentStep.sendingChain&&(this.counter++,this.currentRatchetKey=await this.generateRatchetKey()),!this.currentStep.sendingChain){if(!this.currentStep.remoteRatchetKey)throw new Error("currentStep has empty remoteRatchetKey");this.currentStep.sendingChain=await this.createChain(this.currentRatchetKey.privateKey,this.currentStep.remoteRatchetKey,Ui)}const t=await this.currentStep.sendingChain.encrypt(e);this.update();let r;this.steps.length===0&&!this.currentStep.receivingChain&&this.currentStep.sendingChain.counter===1&&(r=new Ss,r.registrationId=this.identity.id,r.preKeyId=this.remotePreKeyId,r.preKeySignedId=this.remotePreKeySignedId,r.baseKey=this.currentRatchetKey.publicKey,await r.identity.fill(this.identity));const i=new Lr;return i.receiverKey=this.remoteIdentity.signingKey,i.senderKey=this.identity.signingKey.publicKey,i.message.cipherText=t.cipherText,i.message.counter=this.currentStep.sendingChain.counter-1,i.message.previousCounter=this.counter,i.message.senderRatchetKey=this.currentRatchetKey.publicKey,await i.sign(t.hmacKey),r?(r.signedMessage=i,r):i})}async hasRatchetKey(e){let t;e instanceof pe?t=e:t=await pe.create(e);for(const r of this.steps.items)if(await r.remoteRatchetKey.isEqual(t))return!0;return!1}async toJSON(){return{counter:this.counter,ratchetKey:await x.ecKeyPairToJson(this.currentRatchetKey),remoteIdentity:await this.remoteIdentity.signingKey.thumbprint(),rootKey:this.rootKey,steps:await this.steps.toJSON()}}async fromJSON(e){this.currentRatchetKey=await x.ecKeyPairFromJson(e.ratchetKey),this.counter=e.counter,this.rootKey=e.rootKey;for(const t of e.steps)this.currentStep=await Hr.fromJSON(t),this.steps.push(this.currentStep)}update(){this.emit("update")}generateRatchetKey(){return x.generateKeyPair("ECDH",!!this.options.exportableKeys)}async createChain(e,t,r){const i=await x.deriveBytes(e,t),s=await H.HKDF(i,2,this.rootKey,bs),o=await H.importHMAC(s[0]),a=await H.importHMAC(s[1]),c=new r(a);return this.rootKey=o,c}queuePromise(e,t){const r=this.promises[e]||Promise.resolve(),i=this.promises[e]=r.then(t,t);return i.then(()=>{this.promises[e]===i&&delete this.promises[e]}),i}}class Hr{static async fromJSON(e){const t=new this;return await t.fromJSON(e),t}async toJSON(){const e={};return this.remoteRatchetKey&&(e.remoteRatchetKey=this.remoteRatchetKey.key),this.sendingChain&&(e.sendingChain=await this.sendingChain.toJSON()),this.receivingChain&&(e.receivingChain=await this.receivingChain.toJSON()),e}async fromJSON(e){e.remoteRatchetKey&&(this.remoteRatchetKey=await pe.create(e.remoteRatchetKey)),e.sendingChain&&(this.sendingChain=await Ui.fromJSON(e.sendingChain)),e.receivingChain&&(this.receivingChain=await Vi.fromJSON(e.receivingChain))}}class Ts extends Cs{getStep(e){let t;return this.items.some(r=>(r.remoteRatchetKey.id===e.id&&(t=r),!!t)),t}}class Ri{static async set(e){return new Uint8Array(y.FromUtf8String(e.toISOString()))}static async get(e){return new Date(y.ToUtf8String(e))}}class ar{static async set(e){return new Uint8Array(y.FromHex(e))}static async get(e){return y.ToHex(e)}}class cr{static async set(e){return new Uint8Array(y.FromUtf8String(e.toString(10)))}static async get(e){return parseInt(y.ToUtf8String(e),10)}}var Mr;let U=class extends ir{constructor(){super(...arguments),this.version=0}};U.INDEX=1,l([u({id:U.INDEX++,type:"uint32",required:!0,defaultValue:1})],U.prototype,"version",void 0),U=l([p({name:"BaseMessage"})],U);let C=class extends U{constructor(){super(),this.actionId="",this.action=this.constructor.ACTION}};C.INDEX=U.INDEX,C.ACTION="action",l([u({id:C.INDEX++,type:"string",required:!0})],C.prototype,"action",void 0),l([u({id:C.INDEX++,type:"string",required:!1})],C.prototype,"actionId",void 0),C=l([p({name:"Action"})],C);let De=class extends U{constructor(){super(...arguments),this.name=""}isEmpty(){return!this.name}toAlgorithm(){return{name:this.name}}fromAlgorithm(e){this.name=e.name}};De.INDEX=U.INDEX,l([u({id:De.INDEX++,type:"string",required:!0})],De.prototype,"name",void 0),De=l([p({name:"BaseAlgorithm"})],De);let w=Mr=class extends De{toAlgorithm(){const e={},t=this.constructor;for(const r in t.items){if(r==="version")continue;const i=this[r];if(r==="labelStr"){e.label=i;continue}i!==void 0&&(i instanceof De?i.isEmpty()||(e[r]=i.toAlgorithm()):e[r]=i)}return e}fromAlgorithm(e){e instanceof Mr&&(e=e.toAlgorithm());const t=this.constructor;for(const r in e)if(t.items&&r in t.items){const i=t.items[r];if(i.parser)switch(i.parser){case De:{this[r].fromAlgorithm(e[r]);break}default:throw new Error(`Unsupported parser '${i.parser.name}'`)}else r==="label"&&typeof e.label=="string"?this.labelStr=e.label:this[r]=e[r]}}};w.INDEX=De.INDEX,l([u({id:w.INDEX++,type:"bytes",parser:De})],w.prototype,"hash",void 0),l([u({id:w.INDEX++,type:"bytes"})],w.prototype,"publicExponent",void 0),l([u({id:w.INDEX++,type:"uint32"})],w.prototype,"modulusLength",void 0),l([u({id:w.INDEX++,type:"uint32"})],w.prototype,"saltLength",void 0),l([u({id:w.INDEX++,type:"bytes"})],w.prototype,"label",void 0),l([u({id:w.INDEX++,type:"string"})],w.prototype,"namedCurve",void 0),l([u({id:w.INDEX++,converter:ye})],w.prototype,"public",void 0),l([u({id:w.INDEX++,type:"uint32"})],w.prototype,"length",void 0),l([u({id:w.INDEX++})],w.prototype,"iv",void 0),l([u({id:w.INDEX++,type:"bool"})],w.prototype,"token",void 0),l([u({id:w.INDEX++,type:"bool"})],w.prototype,"sensitive",void 0),l([u({id:w.INDEX++,type:"string"})],w.prototype,"labelStr",void 0),w=Mr=l([p({name:"Algorithm"})],w);let se=class extends U{constructor(){super(...arguments),this.providerID="",this.id="",this.type=""}};se.INDEX=U.INDEX,l([u({id:se.INDEX++,type:"string",required:!0})],se.prototype,"providerID",void 0),l([u({id:se.INDEX++,type:"bytes",required:!0,converter:ar})],se.prototype,"id",void 0),l([u({id:se.INDEX++,type:"string",required:!0})],se.prototype,"type",void 0),se=l([p({name:"CryptoItem"})],se);class Us{static async set(e){const t=new w;t.fromAlgorithm(e);const r=await t.exportProto();return new Uint8Array(r)}static async get(e){const t=new w;return await t.importProto(e),t.toAlgorithm()}}let I=class extends se{constructor(){super(...arguments),this.type="secret",this.algorithm={name:""},this.extractable=!1,this.usages=[]}};I.INDEX=se.INDEX,l([u({id:I.INDEX++,type:"bytes",required:!0,converter:Us})],I.prototype,"algorithm",void 0),l([u({id:I.INDEX++,type:"bool"})],I.prototype,"extractable",void 0),l([u({id:I.INDEX++,type:"string",repeated:!0})],I.prototype,"usages",void 0),I=l([p({name:"CryptoKey"})],I);let $e=class extends U{constructor(){super(...arguments),this.privateKey=new I,this.publicKey=new I}};$e.INDEX=U.INDEX,l([u({id:$e.INDEX++,name:"privateKey",type:"bytes",required:!0,parser:I})],$e.prototype,"privateKey",void 0),l([u({id:$e.INDEX++,name:"publicKey",type:"bytes",parser:I})],$e.prototype,"publicKey",void 0),$e=l([p({name:"CryptoKeyPair"})],$e);let G=class extends U{constructor(e,t=0,r="error"){super(),this.code=0,this.type="error",this.message="",this.name="Error",this.stack="",e&&(this.message=e,this.code=t,this.type=r)}};G.INDEX=U.INDEX,l([u({id:G.INDEX++,type:"uint32",defaultValue:0})],G.prototype,"code",void 0),l([u({id:G.INDEX++,type:"string",defaultValue:"error"})],G.prototype,"type",void 0),l([u({id:G.INDEX++,type:"string",defaultValue:""})],G.prototype,"message",void 0),l([u({id:G.INDEX++,type:"string",defaultValue:"Error"})],G.prototype,"name",void 0),l([u({id:G.INDEX++,type:"string",defaultValue:""})],G.prototype,"stack",void 0),G=l([p({name:"Error"})],G);let Ke=class extends C{constructor(e){super(),this.status=!1,e&&(this.actionId=e.actionId,this.action=e.action)}};Ke.INDEX=C.INDEX,l([u({id:Ke.INDEX++,type:"bool",defaultValue:!1})],Ke.prototype,"status",void 0),l([u({id:Ke.INDEX++,type:"bytes",parser:G})],Ke.prototype,"error",void 0),l([u({id:Ke.INDEX++,type:"bytes",converter:ye})],Ke.prototype,"data",void 0),Ke=l([p({name:"Result"})],Ke);let lr=class extends C{};lr.INDEX=C.INDEX,lr.ACTION="auth",lr=l([p({name:"AuthRequest"})],lr);let Pt=class extends C{};Pt.INDEX=C.INDEX,Pt.ACTION="server/login",Pt=l([p({})],Pt);let Ot=class extends C{};Ot.INDEX=C.INDEX,Ot.ACTION="server/isLoggedIn",Ot=l([p({})],Ot);let wt=class extends C{};wt.INDEX=C.INDEX,wt.ACTION="cardReader",wt=l([p({})],wt);let Tt=class extends C{};Tt.INDEX=C.INDEX,Tt.ACTION="cardReader/readers",Tt=l([p({})],Tt);let oe=class extends wt{constructor(e,t){super(),this.reader="",this.atr="",e&&t&&(this.reader=e,this.atr=t)}};oe.INDEX=wt.INDEX,l([u({id:oe.INDEX++,required:!0,type:"string",defaultValue:""})],oe.prototype,"reader",void 0),l([u({id:oe.INDEX++,required:!0,converter:ar})],oe.prototype,"atr",void 0),oe=l([p({})],oe);let Et=class extends oe{};Et.INDEX=oe.INDEX,Et.ACTION=oe.ACTION+"/insert",Et=l([p({})],Et);let At=class extends oe{};At.INDEX=oe.INDEX,At.ACTION=oe.ACTION+"/remove",At=l([p({})],At);let g=class extends C{constructor(){super(...arguments),this.providerID=""}};g.INDEX=C.INDEX,g.ACTION="crypto",l([u({id:g.INDEX++,required:!0,type:"string"})],g.prototype,"providerID",void 0),g=l([p({})],g);let Ut=class extends g{};Ut.INDEX=g.INDEX,Ut.ACTION="crypto/login",Ut=l([p({})],Ut);let Vt=class extends g{};Vt.INDEX=g.INDEX,Vt.ACTION="crypto/logout",Vt=l([p({})],Vt);let Rt=class extends g{};Rt.INDEX=g.INDEX,Rt.ACTION="crypto/isLoggedIn",Rt=l([p({})],Rt);let Xt=class extends g{};Xt.INDEX=g.INDEX,Xt.ACTION="crypto/reset",Xt=l([p({})],Xt);let O=class extends se{constructor(){super(...arguments),this.id="",this.publicKey=new I,this.type="x509",this.label="",this.token=!1,this.sensitive=!1}};O.INDEX=se.INDEX,l([u({id:O.INDEX++,required:!0,converter:ar})],O.prototype,"id",void 0),l([u({id:O.INDEX++,required:!0,parser:I})],O.prototype,"publicKey",void 0),l([u({id:O.INDEX++,required:!0,type:"string"})],O.prototype,"type",void 0),l([u({id:O.INDEX++,type:"string",defaultValue:""})],O.prototype,"label",void 0),l([u({id:O.INDEX++,type:"bool",defaultValue:!1})],O.prototype,"token",void 0),l([u({id:O.INDEX++,type:"bool",defaultValue:!1})],O.prototype,"sensitive",void 0),O=l([p({})],O);let z=class extends O{constructor(){super(...arguments),this.type="x509",this.serialNumber="",this.issuerName="",this.subjectName="",this.notBefore=new Date,this.notAfter=new Date}};z.INDEX=O.INDEX,l([u({id:z.INDEX++,required:!0,converter:ar})],z.prototype,"serialNumber",void 0),l([u({id:z.INDEX++,required:!0,type:"string"})],z.prototype,"issuerName",void 0),l([u({id:z.INDEX++,required:!0,type:"string"})],z.prototype,"subjectName",void 0),l([u({id:z.INDEX++,required:!0,converter:Ri})],z.prototype,"notBefore",void 0),l([u({id:z.INDEX++,required:!0,converter:Ri})],z.prototype,"notAfter",void 0),z=l([p({})],z);let Ze=class extends O{constructor(){super(...arguments),this.type="request",this.subjectName=""}};Ze.INDEX=O.INDEX,l([u({id:Ze.INDEX++,required:!0,type:"string"})],Ze.prototype,"subjectName",void 0),Ze=l([p({})],Ze);let Fe=class extends U{constructor(){super(...arguments),this.type="",this.value=new ArrayBuffer(0)}};Fe.INDEX=U.INDEX,l([u({id:Fe.INDEX++,required:!0,type:"string"})],Fe.prototype,"type",void 0),l([u({id:Fe.INDEX++,required:!0,converter:ye})],Fe.prototype,"value",void 0),Fe=l([p({})],Fe);let bt=class extends U{constructor(){super(...arguments),this.items=[]}};bt.INDEX=U.INDEX,l([u({id:bt.INDEX++,required:!0,repeated:!0,parser:Fe})],bt.prototype,"items",void 0),bt=l([p({})],bt);let Je=class extends g{constructor(){super(...arguments),this.item=new O}};Je.INDEX=g.INDEX,Je.ACTION="crypto/certificateStorage/setItem",l([u({id:Je.INDEX++,required:!0,parser:O})],Je.prototype,"item",void 0),Je=l([p({})],Je);let Ae=class extends g{constructor(){super(...arguments),this.key="",this.algorithm=new w,this.keyUsages=[]}};Ae.INDEX=g.INDEX,Ae.ACTION="crypto/certificateStorage/getItem",l([u({id:Ae.INDEX++,required:!0,type:"string"})],Ae.prototype,"key",void 0),l([u({id:Ae.INDEX++,parser:w})],Ae.prototype,"algorithm",void 0),l([u({id:Ae.INDEX++,repeated:!0,type:"string"})],Ae.prototype,"keyUsages",void 0),Ae=l([p({})],Ae);let Lt=class extends g{};Lt.INDEX=g.INDEX,Lt.ACTION="crypto/certificateStorage/keys",Lt=l([p({})],Lt);let Qe=class extends g{constructor(){super(...arguments),this.key=""}};Qe.INDEX=g.INDEX,Qe.ACTION="crypto/certificateStorage/getValue",l([u({id:Qe.INDEX++,required:!0,type:"string"})],Qe.prototype,"key",void 0),Qe=l([p({})],Qe);let et=class extends g{constructor(){super(...arguments),this.key=""}};et.INDEX=g.INDEX,et.ACTION="crypto/certificateStorage/removeItem",l([u({id:et.INDEX++,required:!0,type:"string"})],et.prototype,"key",void 0),et=l([p({})],et);let Ht=class extends g{};Ht.INDEX=g.INDEX,Ht.ACTION="crypto/certificateStorage/clear",Ht=l([p({})],Ht);let ae=class extends g{constructor(){super(...arguments),this.format="raw",this.data=new ArrayBuffer(0),this.algorithm=new w,this.keyUsages=[]}};ae.INDEX=g.INDEX,ae.ACTION="crypto/certificateStorage/import",l([u({id:ae.INDEX++,required:!0,type:"string"})],ae.prototype,"format",void 0),l([u({id:ae.INDEX++,required:!0,converter:ye})],ae.prototype,"data",void 0),l([u({id:ae.INDEX++,required:!0,parser:w})],ae.prototype,"algorithm",void 0),l([u({id:ae.INDEX++,repeated:!0,type:"string"})],ae.prototype,"keyUsages",void 0),ae=l([p({})],ae);let Ve=class extends g{constructor(){super(...arguments),this.format="raw",this.item=new O}};Ve.INDEX=g.INDEX,Ve.ACTION="crypto/certificateStorage/export",l([u({id:Ve.INDEX++,required:!0,type:"string"})],Ve.prototype,"format",void 0),l([u({id:Ve.INDEX++,required:!0,parser:O})],Ve.prototype,"item",void 0),Ve=l([p({})],Ve);let tt=class extends g{constructor(){super(...arguments),this.item=new O}};tt.INDEX=g.INDEX,tt.ACTION="crypto/certificateStorage/indexOf",l([u({id:tt.INDEX++,required:!0,parser:O})],tt.prototype,"item",void 0),tt=l([p({})],tt);let It=class extends g{constructor(){super(...arguments),this.item=new O}};It.INDEX=g.INDEX,It.ACTION="crypto/certificateStorage/getChain",l([u({id:Je.INDEX++,required:!0,parser:O})],It.prototype,"item",void 0),It=l([p({})],It);let rt=class extends g{constructor(){super(...arguments),this.url=""}};rt.INDEX=g.INDEX,rt.ACTION="crypto/certificateStorage/getCRL",l([u({id:rt.INDEX++,required:!0,type:"string"})],rt.prototype,"url",void 0),rt=l([p({})],rt);let it=class extends U{constructor(){super(...arguments),this.method="get"}};it.INDEX=U.INDEX,l([u({id:it.INDEX++,required:!1,type:"string",defaultValue:"get"})],it.prototype,"method",void 0),it=l([p({})],it);let be=class extends g{constructor(){super(...arguments),this.url="",this.request=new ArrayBuffer(0),this.options=new it}};be.INDEX=g.INDEX,be.ACTION="crypto/certificateStorage/getOCSP",l([u({id:be.INDEX++,required:!0,type:"string"})],be.prototype,"url",void 0),l([u({id:be.INDEX++,required:!0,converter:ye})],be.prototype,"request",void 0),l([u({id:be.INDEX++,required:!1,parser:it})],be.prototype,"options",void 0),be=l([p({})],be);let nt=class extends g{constructor(){super(...arguments),this.item=new I}};nt.INDEX=g.INDEX,nt.ACTION="crypto/keyStorage/setItem",l([u({id:nt.INDEX++,required:!0,parser:I})],nt.prototype,"item",void 0),nt=l([p({})],nt);let ce=class extends g{constructor(){super(...arguments),this.key="",this.algorithm=new w,this.extractable=!1,this.keyUsages=[]}};ce.INDEX=g.INDEX,ce.ACTION="crypto/keyStorage/getItem",l([u({id:ce.INDEX++,required:!0,type:"string"})],ce.prototype,"key",void 0),l([u({id:ce.INDEX++,parser:w})],ce.prototype,"algorithm",void 0),l([u({id:ce.INDEX++,type:"bool"})],ce.prototype,"extractable",void 0),l([u({id:ce.INDEX++,repeated:!0,type:"string"})],ce.prototype,"keyUsages",void 0),ce=l([p({})],ce);let Mt=class extends g{};Mt.INDEX=g.INDEX,Mt.ACTION="crypto/keyStorage/keys",Mt=l([p({})],Mt);let st=class extends g{constructor(){super(...arguments),this.key=""}};st.INDEX=g.INDEX,st.ACTION="crypto/keyStorage/removeItem",l([u({id:st.INDEX++,required:!0,type:"string"})],st.prototype,"key",void 0),st=l([p({})],st);let _t=class extends g{};_t.INDEX=g.INDEX,_t.ACTION="crypto/keyStorage/clear",_t=l([p({})],_t);let ot=class extends g{constructor(){super(...arguments),this.item=new I}};ot.INDEX=g.INDEX,ot.ACTION="crypto/keyStorage/indexOf",l([u({id:ot.INDEX++,required:!0,parser:I})],ot.prototype,"item",void 0),ot=l([p({})],ot);let le=class extends U{constructor(e){super(),this.major=0,this.minor=0,e&&gt(this,e)}};le.INDEX=U.INDEX,l([u({id:le.INDEX++,required:!0,type:"uint32"})],le.prototype,"major",void 0),l([u({id:le.INDEX++,required:!0,type:"uint32"})],le.prototype,"minor",void 0),le=l([p({})],le);let N=class extends U{constructor(e){super(),this.label="",this.manufacturerID="",this.model="",this.serialNumber="",this.flags=0,this.hardwareVersion=new le,this.firmwareVersion=new le,this.maxSessionCount=0,this.sessionCount=0,this.maxRwSessionCount=0,this.rwSessionCount=0,this.maxPinLen=0,this.minPinLen=0,this.totalPublicMemory=0,this.freePublicMemory=0,this.totalPrivateMemory=0,this.freePrivateMemory=0,e&&(gt(this,e),this.firmwareVersion=new le(e.firmwareVersion),this.hardwareVersion=new le(e.hardwareVersion))}};N.INDEX=U.INDEX,l([u({id:N.INDEX++,required:!0,type:"string"})],N.prototype,"label",void 0),l([u({id:N.INDEX++,required:!0,type:"string"})],N.prototype,"manufacturerID",void 0),l([u({id:N.INDEX++,required:!0,type:"string"})],N.prototype,"model",void 0),l([u({id:N.INDEX++,required:!0,type:"string"})],N.prototype,"serialNumber",void 0),l([u({id:N.INDEX++,required:!0,type:"uint32"})],N.prototype,"flags",void 0),l([u({id:N.INDEX++,required:!0,parser:le})],N.prototype,"hardwareVersion",void 0),l([u({id:N.INDEX++,required:!0,parser:le})],N.prototype,"firmwareVersion",void 0),l([u({id:N.INDEX++,required:!0,type:"uint32"})],N.prototype,"maxSessionCount",void 0),l([u({id:N.INDEX++,required:!0,type:"uint32"})],N.prototype,"sessionCount",void 0),l([u({id:N.INDEX++,required:!0,type:"uint32"})],N.prototype,"maxRwSessionCount",void 0),l([u({id:N.INDEX++,required:!0,type:"uint32"})],N.prototype,"rwSessionCount",void 0),l([u({id:N.INDEX++,required:!0,type:"uint32"})],N.prototype,"maxPinLen",void 0),l([u({id:N.INDEX++,required:!0,type:"uint32"})],N.prototype,"minPinLen",void 0),l([u({id:N.INDEX++,required:!0,converter:cr})],N.prototype,"totalPublicMemory",void 0),l([u({id:N.INDEX++,required:!0,converter:cr})],N.prototype,"freePublicMemory",void 0),l([u({id:N.INDEX++,required:!0,converter:cr})],N.prototype,"totalPrivateMemory",void 0),l([u({id:N.INDEX++,required:!0,converter:cr})],N.prototype,"freePrivateMemory",void 0),N=l([p({})],N);let X=class extends U{constructor(e){super(),this.id="",this.name="",this.readOnly=!1,this.algorithms=[],this.isRemovable=!1,this.atr="",this.isHardware=!1,this.card="",e&&(gt(this,e),e.token&&(this.token=new N(e.token)))}};X.INDEX=U.INDEX,l([u({id:X.INDEX++,required:!0,type:"string"})],X.prototype,"id",void 0),l([u({id:X.INDEX++,required:!0,type:"string"})],X.prototype,"name",void 0),l([u({id:X.INDEX++,type:"bool",defaultValue:!1})],X.prototype,"readOnly",void 0),l([u({id:X.INDEX++,repeated:!0,type:"string"})],X.prototype,"algorithms",void 0),l([u({id:X.INDEX++,type:"bool",defaultValue:!1})],X.prototype,"isRemovable",void 0),l([u({id:X.INDEX++,type:"string"})],X.prototype,"atr",void 0),l([u({id:X.INDEX++,type:"bool",defaultValue:!1})],X.prototype,"isHardware",void 0),l([u({id:X.INDEX++,type:"string"})],X.prototype,"card",void 0),l([u({id:X.INDEX++,parser:N})],X.prototype,"token",void 0),X=l([p({})],X);let je=class extends U{constructor(){super(...arguments),this.name="",this.providers=[]}};je.INDEX=U.INDEX,l([u({id:je.INDEX++,type:"string",required:!0})],je.prototype,"name",void 0),l([u({id:je.INDEX++,repeated:!0,parser:X})],je.prototype,"providers",void 0),je=l([p({})],je);let qt=class extends C{};qt.INDEX=C.INDEX,qt.ACTION="provider/action/info",qt=l([p({})],qt);let at=class extends C{constructor(){super(...arguments),this.cryptoID=""}};at.INDEX=C.INDEX,at.ACTION="provider/action/getCrypto",l([u({id:at.INDEX++,required:!0,type:"string"})],at.prototype,"cryptoID",void 0),at=l([p({})],at);let Nt=class extends C{};Nt.INDEX=C.INDEX,Nt.ACTION="provider/event/authorized",Nt=l([p({})],Nt);let ge=class extends C{constructor(e){super(),this.added=[],this.removed=[],e&&gt(this,e)}};ge.INDEX=C.INDEX,ge.ACTION="provider/event/token",l([u({id:ge.INDEX++,repeated:!0,parser:X})],ge.prototype,"added",void 0),l([u({id:ge.INDEX++,repeated:!0,parser:X})],ge.prototype,"removed",void 0),l([u({id:ge.INDEX++,type:"bytes",parser:G})],ge.prototype,"error",void 0),ge=l([p({name:"ProviderTokenEvent"})],ge);let Ge=class extends g{constructor(){super(...arguments),this.algorithm=new w,this.data=new ArrayBuffer(0)}};Ge.INDEX=g.INDEX,Ge.ACTION="crypto/subtle/digest",l([u({id:Ge.INDEX++,required:!0,parser:w})],Ge.prototype,"algorithm",void 0),l([u({id:Ge.INDEX++,required:!0,converter:ye})],Ge.prototype,"data",void 0),Ge=l([p({})],Ge);let Ie=class extends g{constructor(){super(...arguments),this.algorithm=new w,this.extractable=!1,this.usage=[]}};Ie.INDEX=g.INDEX,Ie.ACTION="crypto/subtle/generateKey",l([u({id:Ie.INDEX++,type:"bytes",required:!0,parser:w})],Ie.prototype,"algorithm",void 0),l([u({id:Ie.INDEX++,type:"bool",required:!0})],Ie.prototype,"extractable",void 0),l([u({id:Ie.INDEX++,type:"string",repeated:!0})],Ie.prototype,"usage",void 0),Ie=l([p({})],Ie);let $=class extends g{constructor(){super(...arguments),this.algorithm=new w,this.key=new I,this.data=new ArrayBuffer(0)}};$.INDEX=g.INDEX,$.ACTION="crypto/subtle/sign",l([u({id:$.INDEX++,required:!0,parser:w})],$.prototype,"algorithm",void 0),l([u({id:$.INDEX++,required:!0,parser:I})],$.prototype,"key",void 0),l([u({id:$.INDEX++,required:!0,converter:ye})],$.prototype,"data",void 0),$=l([p({})],$);let ct=class extends ${constructor(){super(...arguments),this.signature=new ArrayBuffer(0)}};ct.INDEX=$.INDEX,ct.ACTION="crypto/subtle/verify",l([u({id:ct.INDEX++,required:!0,converter:ye})],ct.prototype,"signature",void 0),ct=l([p({})],ct);let $t=class extends ${};$t.INDEX=$.INDEX,$t.ACTION="crypto/subtle/encrypt",$t=l([p({})],$t);let Ft=class extends ${};Ft.INDEX=$.INDEX,Ft.ACTION="crypto/subtle/decrypt",Ft=l([p({})],Ft);let Ne=class extends g{constructor(){super(...arguments),this.algorithm=new w,this.key=new I,this.length=0}};Ne.INDEX=g.INDEX,Ne.ACTION="crypto/subtle/deriveBits",l([u({id:Ne.INDEX++,required:!0,parser:w})],Ne.prototype,"algorithm",void 0),l([u({id:Ne.INDEX++,required:!0,parser:I})],Ne.prototype,"key",void 0),l([u({id:Ne.INDEX++,required:!0,type:"uint32"})],Ne.prototype,"length",void 0),Ne=l([p({})],Ne);let W=class extends g{constructor(){super(...arguments),this.algorithm=new w,this.key=new I,this.derivedKeyType=new w,this.extractable=!1,this.usage=[]}};W.INDEX=g.INDEX,W.ACTION="crypto/subtle/deriveKey",l([u({id:W.INDEX++,required:!0,parser:w})],W.prototype,"algorithm",void 0),l([u({id:W.INDEX++,required:!0,parser:I})],W.prototype,"key",void 0),l([u({id:W.INDEX++,required:!0,parser:w})],W.prototype,"derivedKeyType",void 0),l([u({id:W.INDEX++,type:"bool"})],W.prototype,"extractable",void 0),l([u({id:W.INDEX++,type:"string",repeated:!0})],W.prototype,"usage",void 0),W=l([p({})],W);let q=class extends g{constructor(){super(...arguments),this.format="raw",this.wrappedKey=new ArrayBuffer(0),this.unwrappingKey=new I,this.unwrapAlgorithm=new w,this.unwrappedKeyAlgorithm=new w,this.extractable=!1,this.keyUsage=[]}};q.INDEX=g.INDEX,q.ACTION="crypto/subtle/unwrapKey",l([u({id:q.INDEX++,required:!0,type:"string"})],q.prototype,"format",void 0),l([u({id:q.INDEX++,required:!0,converter:ye})],q.prototype,"wrappedKey",void 0),l([u({id:q.INDEX++,required:!0,parser:I})],q.prototype,"unwrappingKey",void 0),l([u({id:q.INDEX++,required:!0,parser:w})],q.prototype,"unwrapAlgorithm",void 0),l([u({id:q.INDEX++,required:!0,parser:w})],q.prototype,"unwrappedKeyAlgorithm",void 0),l([u({id:q.INDEX++,type:"bool"})],q.prototype,"extractable",void 0),l([u({id:q.INDEX++,type:"string",repeated:!0})],q.prototype,"keyUsage",void 0),q=l([p({})],q);let ue=class extends g{constructor(){super(...arguments),this.format="raw",this.key=new I,this.wrappingKey=new I,this.wrapAlgorithm=new w}};ue.INDEX=g.INDEX,ue.ACTION="crypto/subtle/wrapKey",l([u({id:ue.INDEX++,required:!0,type:"string"})],ue.prototype,"format",void 0),l([u({id:ue.INDEX++,required:!0,parser:I})],ue.prototype,"key",void 0),l([u({id:ue.INDEX++,required:!0,parser:I})],ue.prototype,"wrappingKey",void 0),l([u({id:ue.INDEX++,required:!0,parser:w})],ue.prototype,"wrapAlgorithm",void 0),ue=l([p({})],ue);let Re=class extends g{constructor(){super(...arguments),this.format="raw",this.key=new I}};Re.INDEX=g.INDEX,Re.ACTION="crypto/subtle/exportKey",l([u({id:Re.INDEX++,type:"string",required:!0})],Re.prototype,"format",void 0),l([u({id:Re.INDEX++,required:!0,parser:I})],Re.prototype,"key",void 0),Re=l([p({})],Re);let Y=class extends g{constructor(){super(...arguments),this.format="raw",this.keyData=new ArrayBuffer(0),this.algorithm=new w,this.extractable=!1,this.keyUsages=[]}};Y.INDEX=g.INDEX,Y.ACTION="crypto/subtle/importKey",l([u({id:Y.INDEX++,type:"string",required:!0})],Y.prototype,"format",void 0),l([u({id:Y.INDEX++,required:!0,converter:ye})],Y.prototype,"keyData",void 0),l([u({id:Y.INDEX++,required:!0,parser:w})],Y.prototype,"algorithm",void 0),l([u({id:Y.INDEX++,required:!0,type:"bool"})],Y.prototype,"extractable",void 0),l([u({id:Y.INDEX++,type:"string",repeated:!0})],Y.prototype,"keyUsages",void 0),Y=l([p({})],Y);class Vs extends P{constructor(e){super(),this.client=e,this.onEvent=this.onEvent.bind(this),this.client.on("listening",()=>{this.client.on("event",this.onEvent)}).on("close",()=>{this.client.removeListener("event",this.onEvent)})}async readers(){const e=await this.client.send(new Tt);return JSON.parse(y.ToString(e))}on(e,t){return super.on(e,t)}emit(e,...t){return super.emit(e,...t)}onEvent(e){(async()=>{switch(e.action){case Et.ACTION:this.onInsert(await Et.importProto(e));break;case At.ACTION:this.onRemove(await At.importProto(e));break}})().catch(t=>this.emit("error",t))}onInsert(e){this.emit("insert",e)}onRemove(e){this.emit("remove",e)}}async function Rs(n,e){const t=await n.thumbprint(),r=await e.thumbprint(),i=y.FromHex(t+r),s=await k().crypto.subtle.digest("SHA-256",i);return parseInt(y.ToHex(s),16).toString().substr(2,6)}const Xs="/.well-known/webcrypto-socket";class Ls{constructor(e,t){this.target=e,this.event=t}}class Xi extends Error{constructor(e){super(e.message),this.name="CryptoServerError",this.code=e.code,this.type=e.type}}class _r extends Ls{}class Hs extends _r{constructor(e,t,r,i){super(e,"close"),this.remoteAddress=t,this.reasonCode=r,this.description=i}}class ur extends _r{constructor(e,t){super(e,"error"),this.error=t}}class Ms extends _r{constructor(e,t){super(e,"listening"),this.address=t}}function qr(){return typeof self<"u"&&/firefox\/([\w\.-]+)$/i.test(self.navigator.userAgent)}function Jt(){return typeof self<"u"&&/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i.test(self.navigator.userAgent)}function jt(){return typeof self<"u"&&/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i.test(self.navigator.userAgent)}const $r={name:"ECDH",namedCurve:"P-256"},Fr={name:"ECDSA",namedCurve:"P-256"},J={name:"AES-CBC",iv:new ArrayBuffer(16)};async function _s(n){const e=n.algorithm.name.toUpperCase();if(!(e==="ECDH"||e==="ECDSA"))throw new Error("Error: Unsupported asymmetric key algorithm.");if(n.type!=="public")throw new Error("Error: Expected key type to be public but it was not.");const t=await k().crypto.subtle.exportKey("jwk",n);if(!(t.x&&t.y))throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const r=y.FromBase64Url(t.x),i=y.FromBase64Url(t.y),s=y.ToBinary(r)+y.ToBinary(i),o=n,a=y.FromBinary(s);return{id:y.ToHex(await k().crypto.subtle.digest("SHA-256",a)),key:o,serialized:a}}async function Li(n,e){const t=await _s(e);n.id=t.id,n.key=t.key,n.serialized=t.serialized}var hr;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(hr||(hr={}));class qs extends P{get state(){return this.socket?this.socket.readyState:hr.closed}constructor(e){super(),this.stack={},this.messageCounter=0,this.storage=e}connect(e,t){return this.getServerInfo(e).then(r=>{const[i,s,o]=r.version.split(".").map(c=>parseInt(c,10));if(i<1||i===1&&s<2)throw new Error(`Current version of WebCryptoSocket doesn't work with WebCryptoServer v${r.version}. Please update your client to the latest version.`);this.serviceInfo=r;const a=`wss://${e}`;this.socket=t?new mi(a,void 0,t):new mi(a),this.socket.binaryType="arraybuffer",this.socket.onerror=c=>{this.emit("error",new ur(this,c.error))},this.socket.onopen=()=>{(async()=>{let c=await this.storage.loadIdentity();c||(c=await sr.create(1,0,0,jt()||Jt()||qr()),await this.storage.saveIdentity(c));const h="0",d=await Oi.importProto(y.FromBase64(r.preKey));this.cipher=await Kt.create(c,d),await this.storage.saveRemoteIdentity(h,this.cipher.remoteIdentity),this.emit("listening",new Ms(this,e))})().catch(c=>this.emit("error",new ur(this,c)))},this.socket.onclose=c=>{for(const h in this.stack)this.stack[h].reject(new Error("Cannot finish operation. Session was closed"));this.emit("close",new Hs(this,e,c.code,c.reason))},this.socket.onmessage=c=>{c.data instanceof ArrayBuffer&&Lr.importProto(c.data).then(h=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.decrypt(h)}).then(h=>{this.onMessage(h)}).catch(h=>{this.emit("error",new ur(this,h))})}}).catch(r=>{this.emit("error",new ur(this,r))}),this}close(){this.socket&&this.socket.close()}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async challenge(){if(!this.cipher)throw new Error("Client cipher is not initialized");return Rs(this.cipher.remoteIdentity.signingKey,this.cipher.identity.signingKey.publicKey)}async isLoggedIn(){const e=new Ot,t=await this.send(e);return t?!!new Uint8Array(t)[0]:!1}async login(){const e=new Pt;await this.send(e)}send(e){return new Promise((t,r)=>{this.checkSocketState(),e||(e=new C),e.action=e.action,e.actionId=(this.messageCounter++).toString(),e.exportProto().then(i=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.encrypt(i).then(s=>s.exportProto())}).then(i=>{if(!this.socket)throw new Error("Client socket is not initialized");this.stack[e.actionId]={resolve:t,reject:r},this.socket.send(i)}).catch(r)})}async getServerInfo(e){const t=`https://${e}${Xs}`,r=await fetch(t);if(r.status!==200)throw new Error("Cannot get wellknown link");return await r.json()}checkSocketState(){if(this.state!==hr.open)throw new Error("Socket connection is not open")}async onMessage(e){const t=await C.importProto(e),r=this.stack[t.actionId];if(r){delete this.stack[t.actionId];const i=await Ke.importProto(await t.exportProto());if(i.error&&i.error.message){const s=i.error,o=new Xi(s);r.reject(o)}else r.resolve(i.data)}else this.emit("event",t)}}/*!
 Copyright (c) Peculiar Ventures, LLC
*/function kt(n,e){let t=0;if(n.length===1)return n[0];for(let r=n.length-1;r>=0;r--)t+=n[n.length-1-r]*Math.pow(2,e*r);return t}function lt(n,e,t=-1){const r=t;let i=n,s=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(n<o){let c;if(r<0)c=new ArrayBuffer(a),s=a;else{if(r<a)return new ArrayBuffer(0);c=new ArrayBuffer(r),s=r}const h=new Uint8Array(c);for(let d=a-1;d>=0;d--){const f=Math.pow(2,d*e);h[s-d-1]=Math.floor(i/f),i-=h[s-d-1]*f}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function Jr(...n){let e=0,t=0;for(const s of n)e+=s.length;const r=new ArrayBuffer(e),i=new Uint8Array(r);for(const s of n)i.set(s,t),t+=s.length;return i}function Hi(){const n=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const a=n[0]===255&&n[1]&128,c=n[0]===0&&(n[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=n[0]&128;const r=kt(t,8),i=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(i);for(let a=0;a<this.valueHex.byteLength;a++)s[a]=n[a];return s[0]&=127,kt(s,8)-r}function $s(n){const e=n<0?n*-1:n;let t=128;for(let r=1;r<8;r++){if(e<=t){if(n<0){const o=t-e,a=lt(o,8,r),c=new Uint8Array(a);return c[0]|=128,a}let i=lt(e,8,r),s=new Uint8Array(i);if(s[0]&128){const o=i.slice(0),a=new Uint8Array(o);i=new ArrayBuffer(i.byteLength+1),s=new Uint8Array(i);for(let c=0;c<o.byteLength;c++)s[c+1]=a[c];s[0]=0}return i}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function Fs(n,e){if(n.byteLength!==e.byteLength)return!1;const t=new Uint8Array(n),r=new Uint8Array(e);for(let i=0;i<t.length;i++)if(t[i]!==r[i])return!1;return!0}function he(n,e){const t=n.toString(10);if(e<t.length)return"";const r=e-t.length,i=new Array(r);for(let o=0;o<r;o++)i[o]="0";return i.join("").concat(t)}/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 *
 * Author 2014-2019, Yury Strozhevsky
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */function fr(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function jr(n){let e=0,t=0;for(let i=0;i<n.length;i++){const s=n[i];e+=s.byteLength}const r=new Uint8Array(e);for(let i=0;i<n.length;i++){const s=n[i];r.set(new Uint8Array(s),t),t+=s.byteLength}return r.buffer}function Xe(n,e,t,r){return e instanceof Uint8Array?e.byteLength?t<0?(n.error="Wrong parameter: inputOffset less than zero",!1):r<0?(n.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-r<0?(n.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(n.error="Wrong parameter: inputBuffer has zero length",!1):(n.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class dr{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return jr(this.items)}}const Gt=[new Uint8Array([1])],Mi="0123456789",Gr="name",_i="valueHexView",Js="isHexOnly",js="idBlock",Gs="tagClass",zs="tagNumber",Ws="isConstructed",Ys="fromBER",Zs="toBER",Qs="local",te="",ke=new ArrayBuffer(0),yr=new Uint8Array(0),zt="EndOfContent",qi="OCTET STRING",$i="BIT STRING";function Pe(n){var e;return e=class extends n{constructor(...r){var i;super(...r);const s=r[0]||{};this.isHexOnly=(i=s.isHexOnly)!==null&&i!==void 0?i:!1,this.valueHexView=s.valueHex?v.toUint8Array(s.valueHex):yr}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(r){this.valueHexView=new Uint8Array(r)}fromBER(r,i,s){const o=r instanceof ArrayBuffer?new Uint8Array(r):r;if(!Xe(this,o,i,s))return-1;const a=i+s;return this.valueHexView=o.subarray(i,a),this.valueHexView.length?(this.blockLength=s,a):(this.warnings.push("Zero buffer length"),i)}toBER(r=!1){return this.isHexOnly?r?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",ke)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:y.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}class ut{constructor({blockLength:e=0,error:t=te,warnings:r=[],valueBeforeDecode:i=yr}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=v.toUint8Array(i)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:y.ToHex(this.valueBeforeDecodeView)}}}ut.NAME="baseBlock";class Z extends ut{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}Z.NAME="valueBlock";class Fi extends Pe(ut){constructor({idBlock:e={}}={}){var t,r,i,s;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?v.toUint8Array(e.valueHex):yr,this.tagClass=(r=e.tagClass)!==null&&r!==void 0?r:-1,this.tagNumber=(i=e.tagNumber)!==null&&i!==void 0?i:-1,this.isConstructed=(s=e.isConstructed)!==null&&s!==void 0?s:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",ke}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const i=new Uint8Array(1);if(!e){let s=this.tagNumber;s&=31,t|=s,i[0]=t}return i.buffer}if(!this.isHexOnly){const i=lt(this.tagNumber,7),s=new Uint8Array(i),o=i.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=s[c]|128;a[o]=s[o-1]}return a.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=t|31,!e){const i=this.valueHexView;for(let s=0;s<i.length-1;s++)r[s+1]=i[s]|128;r[this.valueHexView.byteLength]=i[i.length-1]}return r.buffer}fromBER(e,t,r){const i=v.toUint8Array(e);if(!Xe(this,i,t,r))return-1;const s=i.subarray(t,t+r);if(s.length===0)return this.error="Zero buffer length",-1;switch(s[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(s[0]&32)===32,this.isHexOnly=!1;const a=s[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,h=this.valueHexView=new Uint8Array(255),d=255;for(;s[c]&128;){if(h[c-1]=s[c]&127,c++,c>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(c===d){d+=255;const b=new Uint8Array(d);for(let S=0;S<h.length;S++)b[S]=h[S];h=this.valueHexView=new Uint8Array(d)}}this.blockLength=c+1,h[c-1]=s[c]&127;const f=new Uint8Array(c);for(let b=0;b<c;b++)f[b]=h[b];h=this.valueHexView=new Uint8Array(c),h.set(f),this.blockLength<=9?this.tagNumber=kt(h,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}Fi.NAME="identificationBlock";class Ji extends ut{constructor({lenBlock:e={}}={}){var t,r,i;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(r=e.longFormUsed)!==null&&r!==void 0?r:!1,this.length=(i=e.length)!==null&&i!==void 0?i:0}fromBER(e,t,r){const i=v.toUint8Array(e);if(!Xe(this,i,t,r))return-1;const s=i.subarray(t,t+r);if(s.length===0)return this.error="Zero buffer length",-1;if(s[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=s[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(s[0]&128),this.longFormUsed===!1)return this.length=s[0],this.blockLength=1,t+this.blockLength;const o=s[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const a=t+1,c=i.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=kt(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const i=lt(this.length,8);if(i.byteLength>127)return this.error="Too big length",ke;if(t=new ArrayBuffer(i.byteLength+1),e)return t;const s=new Uint8Array(i);r=new Uint8Array(t),r[0]=i.byteLength|128;for(let o=0;o<i.byteLength;o++)r[o+1]=s[o];return t}return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}Ji.NAME="lengthBlock";const m={};class F extends ut{constructor({name:e=te,optional:t=!1,primitiveSchema:r,...i}={},s){super(i),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new Fi(i),this.lenBlock=new Ji(i),this.valueBlock=s?new s(i):new Z(i)}fromBER(e,t,r){const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}toBER(e,t){const r=t||new dr;t||ji(this);const i=this.idBlock.toBER(e);if(r.write(i),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const s=this.valueBlock.toBER(e);this.lenBlock.length=s.byteLength;const o=this.lenBlock.toBER(e);r.write(o),r.write(s)}return t?ke:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():y.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${y.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;const t=this.toBER(),r=e.toBER();return Fs(t,r)}}F.NAME="BaseBlock";function ji(n){if(n instanceof m.Constructed)for(const e of n.valueBlock.value)ji(e)&&(n.lenBlock.isIndefiniteForm=!0);return!!n.lenBlock.isIndefiniteForm}class zr extends F{constructor({value:e=te,...t}={},r){super(t,r),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,r){const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}zr.NAME="BaseStringBlock";class Gi extends Pe(Z){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}Gi.NAME="PrimitiveValueBlock";var zi;class Wt extends F{constructor(e={}){super(e,Gi),this.idBlock.isConstructed=!1}}zi=Wt,m.Primitive=zi,Wt.NAME="PRIMITIVE";function eo(n,e){if(n instanceof e)return n;const t=new e;return t.idBlock=n.idBlock,t.lenBlock=n.lenBlock,t.warnings=n.warnings,t.valueBeforeDecodeView=n.valueBeforeDecodeView,t}function Bt(n,e=0,t=n.length){const r=e;let i=new F({},Z);const s=new ut;if(!Xe(s,n,e,t))return i.error=s.error,{offset:-1,result:i};if(!n.subarray(e,e+t).length)return i.error="Zero buffer length",{offset:-1,result:i};let a=i.idBlock.fromBER(n,e,t);if(i.idBlock.warnings.length&&i.warnings.concat(i.idBlock.warnings),a===-1)return i.error=i.idBlock.error,{offset:-1,result:i};if(e=a,t-=i.idBlock.blockLength,a=i.lenBlock.fromBER(n,e,t),i.lenBlock.warnings.length&&i.warnings.concat(i.lenBlock.warnings),a===-1)return i.error=i.lenBlock.error,{offset:-1,result:i};if(e=a,t-=i.lenBlock.blockLength,!i.idBlock.isConstructed&&i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let c=F;switch(i.idBlock.tagClass){case 1:if(i.idBlock.tagNumber>=37&&i.idBlock.isHexOnly===!1)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};c=m.EndOfContent;break;case 1:c=m.Boolean;break;case 2:c=m.Integer;break;case 3:c=m.BitString;break;case 4:c=m.OctetString;break;case 5:c=m.Null;break;case 6:c=m.ObjectIdentifier;break;case 10:c=m.Enumerated;break;case 12:c=m.Utf8String;break;case 13:c=m.RelativeObjectIdentifier;break;case 14:c=m.TIME;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:c=m.Sequence;break;case 17:c=m.Set;break;case 18:c=m.NumericString;break;case 19:c=m.PrintableString;break;case 20:c=m.TeletexString;break;case 21:c=m.VideotexString;break;case 22:c=m.IA5String;break;case 23:c=m.UTCTime;break;case 24:c=m.GeneralizedTime;break;case 25:c=m.GraphicString;break;case 26:c=m.VisibleString;break;case 27:c=m.GeneralString;break;case 28:c=m.UniversalString;break;case 29:c=m.CharacterString;break;case 30:c=m.BmpString;break;case 31:c=m.DATE;break;case 32:c=m.TimeOfDay;break;case 33:c=m.DateTime;break;case 34:c=m.Duration;break;default:{const h=i.idBlock.isConstructed?new m.Constructed:new m.Primitive;h.idBlock=i.idBlock,h.lenBlock=i.lenBlock,h.warnings=i.warnings,i=h}}break;case 2:case 3:case 4:default:c=i.idBlock.isConstructed?m.Constructed:m.Primitive}return i=eo(i,c),a=i.fromBER(n,e,i.lenBlock.isIndefiniteForm?t:i.lenBlock.length),i.valueBeforeDecodeView=n.subarray(r,r+i.blockLength),{offset:a,result:i}}function St(n){if(!n.byteLength){const e=new F({},Z);return e.error="Input buffer has zero length",{offset:-1,result:e}}return Bt(v.toUint8Array(n).slice(),0,n.byteLength)}function to(n,e){return n?1:e}class ze extends Z{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const i=v.toUint8Array(e);if(!Xe(this,i,t,r))return-1;if(this.valueBeforeDecodeView=i.subarray(t,t+r),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let s=t;for(;to(this.isIndefiniteForm,r)>0;){const o=Bt(i,s,r);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(s=o.offset,this.blockLength+=o.result.blockLength,r-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===zt)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===zt?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(e,t){const r=t||new dr;for(let i=0;i<this.value.length;i++)this.value[i].toBER(e,r);return t?ke:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}ze.NAME="ConstructedValueBlock";var Wi;class re extends F{constructor(e={}){super(e,ze),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){const e=[];for(const r of this.valueBlock.value)e.push(r.toString("ascii").split(`
`).map(i=>`  ${i}`).join(`
`));const t=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :
${e.join(`
`)}`:`${t} :`}}Wi=re,m.Constructed=Wi,re.NAME="CONSTRUCTED";class Yi extends Z{fromBER(e,t,r){return t}toBER(e){return ke}}Yi.override="EndOfContentValueBlock";var Zi;class Wr extends F{constructor(e={}){super(e,Yi),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}Zi=Wr,m.EndOfContent=Zi,Wr.NAME=zt;var Qi;class ht extends F{constructor(e={}){super(e,Z),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const i=new Uint8Array(r);i[0]=5,i[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}Qi=ht,m.Null=Qi,ht.NAME="NULL";class en extends Pe(Z){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=v.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,r){const i=v.toUint8Array(e);return Xe(this,i,t,r)?(this.valueHexView=i.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,Hi.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}en.NAME="BooleanValueBlock";var tn;class pr extends F{constructor(e={}){super(e,en),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}tn=pr,m.Boolean=tn,pr.NAME="BOOLEAN";class rn extends Pe(ze){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let i=0;if(this.isConstructed){if(this.isHexOnly=!1,i=ze.prototype.fromBER.call(this,e,t,r),i===-1)return i;for(let s=0;s<this.value.length;s++){const o=this.value[s].constructor.NAME;if(o===zt){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==qi)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,i=super.fromBER(e,t,r),this.blockLength=r;return i}toBER(e,t){return this.isConstructed?ze.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}rn.NAME="OctetStringValueBlock";var nn;let gr=class ns extends F{constructor({idBlock:e={},lenBlock:t={},...r}={}){var i,s;(i=r.isConstructed)!==null&&i!==void 0||(r.isConstructed=!!(!((s=r.value)===null||s===void 0)&&s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},rn),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,r===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const s=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(s.byteLength){const o=Bt(s,0,s.byteLength);o.offset!==-1&&o.offset===r&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(e,t,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?re.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${y.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof ns&&e.push(t.valueBlock.valueHexView);return v.concat(e)}};nn=gr,m.OctetString=nn,gr.NAME=qi;class sn extends Pe(ze){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let i=-1;if(this.isConstructed){if(i=ze.prototype.fromBER.call(this,e,t,r),i===-1)return i;for(const a of this.value){const c=a.constructor.NAME;if(c===zt){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==$i)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const h=a.valueBlock;if(this.unusedBits>0&&h.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=h.unusedBits}return i}const s=v.toUint8Array(e);if(!Xe(this,s,t,r))return-1;const o=s.subarray(t,t+r);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const a=o.subarray(1);try{if(a.byteLength){const c=Bt(a,0,a.byteLength);c.offset!==-1&&c.offset===r-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+r}toBER(e,t){if(this.isConstructed)return ze.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return ke;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}sn.NAME="BitStringValueBlock";var on;let mr=class extends F{constructor({idBlock:e={},lenBlock:t={},...r}={}){var i,s;(i=r.isConstructed)!==null&&i!==void 0||(r.isConstructed=!!(!((s=r.value)===null||s===void 0)&&s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},sn),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return re.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const i of t)e.push(i.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}};on=mr,m.BitString=on,mr.NAME=$i;var an;function ro(n,e){const t=new Uint8Array([0]),r=new Uint8Array(n),i=new Uint8Array(e);let s=r.slice(0);const o=s.length-1,a=i.slice(0),c=a.length-1;let h=0;const d=c<o?o:c;let f=0;for(let b=d;b>=0;b--,f++){switch(!0){case f<a.length:h=s[o-f]+a[c-f]+t[0];break;default:h=s[o-f]+t[0]}switch(t[0]=h/10,!0){case f>=s.length:s=Jr(new Uint8Array([h%10]),s);break;default:s[o-f]=h%10}}return t[0]>0&&(s=Jr(t,s)),s}function cn(n){if(n>=Gt.length)for(let e=Gt.length;e<=n;e++){const t=new Uint8Array([0]);let r=Gt[e-1].slice(0);for(let i=r.length-1;i>=0;i--){const s=new Uint8Array([(r[i]<<1)+t[0]]);t[0]=s[0]/10,r[i]=s[0]%10}t[0]>0&&(r=Jr(t,r)),Gt.push(r)}return Gt[n]}function io(n,e){let t=0;const r=new Uint8Array(n),i=new Uint8Array(e),s=r.slice(0),o=s.length-1,a=i.slice(0),c=a.length-1;let h,d=0;for(let f=c;f>=0;f--,d++)switch(h=s[o-d]-a[c-d]-t,!0){case h<0:t=1,s[o-d]=h+10;break;default:t=0,s[o-d]=h}if(t>0)for(let f=o-c+1;f>=0;f--,d++)if(h=s[o-d]-t,h<0)t=1,s[o-d]=h+10;else{t=0,s[o-d]=h;break}return s.slice()}class Yr extends Pe(Z){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=Hi.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array($s(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,i=0){const s=this.fromBER(e,t,r);if(s===-1)return s;const o=this.valueHexView;return o[0]===0&&o[1]&128?this.valueHexView=o.subarray(1):i!==0&&o.length<i&&(i-o.length>1&&(i=o.length+1),this.valueHexView=o.subarray(i-o.length)),s}toDER(e=!1){const t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{const r=new Uint8Array(this.valueHexView.length+1);r[0]=0,r.set(t,1),this.valueHexView=r}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,r){const i=super.fromBER(e,t,r);return i===-1||this.setValueHex(),i}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=this.valueHexView.length*8-1;let t=new Uint8Array(this.valueHexView.length*8/3),r=0,i;const s=this.valueHexView;let o="",a=!1;for(let c=s.byteLength-1;c>=0;c--){i=s[c];for(let h=0;h<8;h++){if((i&1)===1)switch(r){case e:t=io(cn(r),t),o="-";break;default:t=ro(t,cn(r))}r++,i>>=1}}for(let c=0;c<t.length;c++)t[c]&&(a=!0),a&&(o+=Mi.charAt(t[c]));return a===!1&&(o+=Mi.charAt(0)),o}}an=Yr,Yr.NAME="IntegerValueBlock",Object.defineProperty(an.prototype,"valueHex",{set:function(n){this.valueHexView=new Uint8Array(n),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var ln;class me extends F{constructor(e={}){super(e,Yr),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return fr(),BigInt(this.valueBlock.toString())}static fromBigInt(e){fr();const t=BigInt(e),r=new dr,i=t.toString(16).replace(/^-/,""),s=new Uint8Array(y.FromHex(i));if(t<0){const a=new Uint8Array(s.length+(s[0]&128?1:0));a[0]|=128;const h=BigInt(`0x${y.ToHex(a)}`)+t,d=v.toUint8Array(y.FromHex(h.toString(16)));d[0]|=128,r.write(d)}else s[0]&128&&r.write(new Uint8Array([0])),r.write(s);return new me({valueHex:r.final()})}convertToDER(){const e=new me({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new me({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}ln=me,m.Integer=ln,me.NAME="INTEGER";var un;class vr extends me{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}un=vr,m.Enumerated=un,vr.NAME="ENUMERATED";class Zr extends Pe(Z){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const i=v.toUint8Array(e);if(!Xe(this,i,t,r))return-1;const s=i.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=s[a]&127,this.blockLength++,!!(s[a]&128));a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,s[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=kt(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){fr();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let i=0;i<r.length;i++)r[i]=parseInt(t.slice(i*7,i*7+7),2)+(i+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const i=this.valueHexView,s=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)s[o]=i[o]|128;return s[this.blockLength-1]=i[this.blockLength-1],s.buffer}const t=lt(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",ke;const r=new Uint8Array(t.byteLength);if(!e){const i=new Uint8Array(t),s=t.byteLength-1;for(let o=0;o<s;o++)r[o]=i[o]|128;r[s]=i[s]}return r}toString(){let e="";if(this.isHexOnly)e=y.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}Zr.NAME="sidBlock";class hn extends Z{constructor({value:e=te,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let i=t;for(;r>0;){const s=new Zr;if(i=s.fromBER(e,i,r),i===-1)return this.blockLength=0,this.error=s.error,i;this.value.length===0&&(s.isFirstSid=!0),this.blockLength+=s.blockLength,r-=s.blockLength,this.value.push(s)}return i}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(e);if(i.byteLength===0)return this.error=this.value[r].error,ke;t.push(i)}return jr(t)}fromString(e){this.value=[];let t=0,r=0,i="",s=!1;do if(r=e.indexOf(".",t),r===-1?i=e.substring(t):i=e.substring(t,r),t=r+1,s){const o=this.value[0];let a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}const c=parseInt(i,10);if(isNaN(c))return;o.valueDec=c+a,s=!1}else{const o=new Zr;if(i>Number.MAX_SAFE_INTEGER){fr();const a=BigInt(i);o.valueBigInt=a}else if(o.valueDec=parseInt(i,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,s=!0),this.value.push(o)}while(r!==-1)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let i=this.value[r].toString();r!==0&&(e=`${e}.`),t?(i=`{${i}}`,this.value[r].isFirstSid?e=`2.{${i} - 80}`:e+=i):e+=i}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}hn.NAME="ObjectIdentifierValueBlock";var fn;let wr=class extends F{constructor(e={}){super(e,hn),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}};fn=wr,m.ObjectIdentifier=fn,wr.NAME="OBJECT IDENTIFIER";class Qr extends Pe(ut){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(r===0)return t;const i=v.toUint8Array(e);if(!Xe(this,i,t,r))return-1;const s=i.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=s[a]&127,this.blockLength++,!!(s[a]&128));a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,s[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=kt(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const i=this.valueHexView,s=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)s[o]=i[o]|128;return s[this.blockLength-1]=i[this.blockLength-1],s.buffer}const t=lt(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",ke;const r=new Uint8Array(t.byteLength);if(!e){const i=new Uint8Array(t),s=t.byteLength-1;for(let o=0;o<s;o++)r[o]=i[o]|128;r[s]=i[s]}return r.buffer}toString(){let e="";return this.isHexOnly?e=y.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}Qr.NAME="relativeSidBlock";class dn extends Z{constructor({value:e=te,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let i=t;for(;r>0;){const s=new Qr;if(i=s.fromBER(e,i,r),i===-1)return this.blockLength=0,this.error=s.error,i;this.blockLength+=s.blockLength,r-=s.blockLength,this.value.push(s)}return i}toBER(e,t){const r=[];for(let i=0;i<this.value.length;i++){const s=this.value[i].toBER(e);if(s.byteLength===0)return this.error=this.value[i].error,ke;r.push(s)}return jr(r)}fromString(e){this.value=[];let t=0,r=0,i="";do{r=e.indexOf(".",t),r===-1?i=e.substring(t):i=e.substring(t,r),t=r+1;const s=new Qr;if(s.valueDec=parseInt(i,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(r!==-1);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let i=this.value[r].toString();r!==0&&(e=`${e}.`),t&&(i=`{${i}}`),e+=i}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}dn.NAME="RelativeObjectIdentifierValueBlock";var yn;class ei extends F{constructor(e={}){super(e,dn),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}yn=ei,m.RelativeObjectIdentifier=yn,ei.NAME="RelativeObjectIdentifier";var pn;class Le extends re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}pn=Le,m.Sequence=pn,Le.NAME="SEQUENCE";var gn;class He extends re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}gn=He,m.Set=gn,He.NAME="SET";class mn extends Pe(Z){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=te}toJSON(){return{...super.toJSON(),value:this.value}}}mn.NAME="StringValueBlock";class vn extends mn{}vn.NAME="SimpleStringValueBlock";class fe extends zr{constructor({...e}={}){super(e,vn)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,v.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.charCodeAt(i);this.valueBlock.value=e}}fe.NAME="SIMPLE STRING";class wn extends fe{fromBuffer(e){this.valueBlock.valueHexView=v.toUint8Array(e);try{this.valueBlock.value=y.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=y.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(y.FromUtf8String(e)),this.valueBlock.value=e}}wn.NAME="Utf8StringValueBlock";var En;class Me extends wn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}En=Me,m.Utf8String=En,Me.NAME="UTF8String";class An extends fe{fromBuffer(e){this.valueBlock.value=y.ToUtf16String(e),this.valueBlock.valueHexView=v.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(y.FromUtf16String(e))}}An.NAME="BmpStringValueBlock";var bn;class Er extends An{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}bn=Er,m.BmpString=bn,Er.NAME="BMPString";class In extends fe{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let i=0;i<r.length;i+=4)r[i]=r[i+3],r[i+1]=r[i+2],r[i+2]=0,r[i+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let i=0;i<t;i++){const s=lt(e.charCodeAt(i),8),o=new Uint8Array(s);if(o.length>4)continue;const a=4-o.length;for(let c=o.length-1;c>=0;c--)r[i*4+c+a]=o[c]}this.valueBlock.value=e}}In.NAME="UniversalStringValueBlock";var Nn;class Ar extends In{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}Nn=Ar,m.UniversalString=Nn,Ar.NAME="UniversalString";var kn;class br extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}kn=br,m.NumericString=kn,br.NAME="NumericString";var Bn;class Ir extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}Bn=Ir,m.PrintableString=Bn,Ir.NAME="PrintableString";var Sn;class Nr extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}Sn=Nr,m.TeletexString=Sn,Nr.NAME="TeletexString";var xn;class kr extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}xn=kr,m.VideotexString=xn,kr.NAME="VideotexString";var Cn;class Br extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}Cn=Br,m.IA5String=Cn,Br.NAME="IA5String";var Dn;class Sr extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}Dn=Sr,m.GraphicString=Dn,Sr.NAME="GraphicString";var Kn;class Yt extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}Kn=Yt,m.VisibleString=Kn,Yt.NAME="VisibleString";var Pn;class xr extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}Pn=xr,m.GeneralString=Pn,xr.NAME="GeneralString";var On;class Cr extends fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}On=Cr,m.CharacterString=On,Cr.NAME="CharacterString";var Tn;class Zt extends Yt{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let i=0;i<e.length;i++)this.valueBlock.valueHexView[i]=e.charCodeAt(i)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,v.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let i=0;i<e.length;i++)r[i]=e.charCodeAt(i);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const r=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(r===null){this.error="Wrong input string for conversion";return}const i=parseInt(r[1],10);i>=50?this.year=1900+i:this.year=2e3+i,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(e="iso"){if(e==="iso"){const t=new Array(7);return t[0]=he(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=he(this.month,2),t[2]=he(this.day,2),t[3]=he(this.hour,2),t[4]=he(this.minute,2),t[5]=he(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}Tn=Zt,m.UTCTime=Tn,Zt.NAME="UTCTime";var Un;class Dr extends Zt{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t=!1,r="",i="",s=0,o,a=0,c=0;if(e[e.length-1]==="Z")r=e.substring(0,e.length-1),t=!0;else{const f=new Number(e[e.length-1]);if(isNaN(f.valueOf()))throw new Error("Wrong input string for conversion");r=e}if(t){if(r.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(r.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let f=1,b=r.indexOf("+"),S="";if(b===-1&&(b=r.indexOf("-"),f=-1),b!==-1){if(S=r.substring(b+1),r=r.substring(0,b),S.length!==2&&S.length!==4)throw new Error("Wrong input string for conversion");let L=parseInt(S.substring(0,2),10);if(isNaN(L.valueOf()))throw new Error("Wrong input string for conversion");if(a=f*L,S.length===4){if(L=parseInt(S.substring(2,4),10),isNaN(L.valueOf()))throw new Error("Wrong input string for conversion");c=f*L}}}let h=r.indexOf(".");if(h===-1&&(h=r.indexOf(",")),h!==-1){const f=new Number(`0${r.substring(h)}`);if(isNaN(f.valueOf()))throw new Error("Wrong input string for conversion");s=f.valueOf(),i=r.substring(0,h)}else i=r;switch(!0){case i.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,h!==-1)throw new Error("Wrong input string for conversion");break;case i.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let f=60*s;this.minute=Math.floor(f),f=60*(f-this.minute),this.second=Math.floor(f),f=1e3*(f-this.second),this.millisecond=Math.floor(f)}break;case i.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let f=60*s;this.second=Math.floor(f),f=1e3*(f-this.second),this.millisecond=Math.floor(f)}break;case i.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,h!==-1){const f=1e3*s;this.millisecond=Math.floor(f)}break;default:throw new Error("Wrong input string for conversion")}const d=o.exec(i);if(d===null)throw new Error("Wrong input string for conversion");for(let f=1;f<d.length;f++)switch(f){case 1:this.year=parseInt(d[f],10);break;case 2:this.month=parseInt(d[f],10);break;case 3:this.day=parseInt(d[f],10);break;case 4:this.hour=parseInt(d[f],10)+a;break;case 5:this.minute=parseInt(d[f],10)+c;break;case 6:this.second=parseInt(d[f],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){const f=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=f.getUTCFullYear(),this.month=f.getUTCMonth(),this.day=f.getUTCDay(),this.hour=f.getUTCHours(),this.minute=f.getUTCMinutes(),this.second=f.getUTCSeconds(),this.millisecond=f.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){const t=[];return t.push(he(this.year,4)),t.push(he(this.month,2)),t.push(he(this.day,2)),t.push(he(this.hour,2)),t.push(he(this.minute,2)),t.push(he(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(he(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}Un=Dr,m.GeneralizedTime=Un,Dr.NAME="GeneralizedTime";var Vn;class ti extends Me{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}Vn=ti,m.DATE=Vn,ti.NAME="DATE";var Rn;class ri extends Me{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}Rn=ri,m.TimeOfDay=Rn,ri.NAME="TimeOfDay";var Xn;class ii extends Me{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}Xn=ii,m.DateTime=Xn,ii.NAME="DateTime";var Ln;class ni extends Me{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}Ln=ni,m.Duration=Ln,ni.NAME="Duration";var Hn;class si extends Me{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}Hn=si,m.TIME=Hn,si.NAME="TIME";class ft{constructor({name:e=te,optional:t=!1}={}){this.name=e,this.optional=t}}class oi extends ft{constructor({value:e=[],...t}={}){super(t),this.value=e}}class Kr extends ft{constructor({value:e=new ft,local:t=!1,...r}={}){super(r),this.value=e,this.local=t}}class no{constructor({data:e=yr}={}){this.dataView=v.toUint8Array(e)}get data(){return this.dataView.slice().buffer}set data(e){this.dataView=v.toUint8Array(e)}fromBER(e,t,r){const i=t+r;return this.dataView=v.toUint8Array(e).subarray(t,i),i}toBER(e){return this.dataView.slice().buffer}}function dt(n,e,t){if(t instanceof oi){for(let s=0;s<t.value.length;s++)if(dt(n,e,t.value[s]).verified)return{verified:!0,result:n};{const s={verified:!1,result:{error:"Wrong values for Choice type"}};return t.hasOwnProperty(Gr)&&(s.name=t.name),s}}if(t instanceof ft)return t.hasOwnProperty(Gr)&&(n[t.name]=e),{verified:!0,result:n};if(!(n instanceof Object))return{verified:!1,result:{error:"Wrong root object"}};if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(!(t instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(js in t))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Ys in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Zs in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const r=t.idBlock.toBER(!1);if(r.byteLength===0)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(t.idBlock.fromBER(r,0,r.byteLength)===-1)return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(t.idBlock.hasOwnProperty(Gs)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:n};if(t.idBlock.hasOwnProperty(zs)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:n};if(t.idBlock.hasOwnProperty(Ws)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:n};if(!(Js in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:n};if(t.idBlock.isHexOnly){if(!(_i in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=t.idBlock.valueHexView,o=e.idBlock.valueHexView;if(s.length!==o.length)return{verified:!1,result:n};for(let a=0;a<s.length;a++)if(s[a]!==o[1])return{verified:!1,result:n}}if(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,te),t.name&&(n[t.name]=e)),t instanceof m.Constructed){let s=0,o={verified:!1,result:{error:"Unknown error"}},a=t.valueBlock.value.length;if(a>0&&t.valueBlock.value[0]instanceof Kr&&(a=e.valueBlock.value.length),a===0)return{verified:!0,result:n};if(e.valueBlock.value.length===0&&t.valueBlock.value.length!==0){let c=!0;for(let h=0;h<t.valueBlock.value.length;h++)c=c&&(t.valueBlock.value[h].optional||!1);return c?{verified:!0,result:n}:(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,te),t.name&&delete n[t.name]),n.error="Inconsistent object length",{verified:!1,result:n})}for(let c=0;c<a;c++)if(c-s>=e.valueBlock.value.length){if(t.valueBlock.value[c].optional===!1){const h={verified:!1,result:n};return n.error="Inconsistent length between ASN.1 data and schema",t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,te),t.name&&(delete n[t.name],h.name=t.name)),h}}else if(t.valueBlock.value[0]instanceof Kr){if(o=dt(n,e.valueBlock.value[c],t.valueBlock.value[0].value),o.verified===!1)if(t.valueBlock.value[0].optional)s++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,te),t.name&&delete n[t.name]),o;if(Gr in t.valueBlock.value[0]&&t.valueBlock.value[0].name.length>0){let h={};Qs in t.valueBlock.value[0]&&t.valueBlock.value[0].local?h=e:h=n,typeof h[t.valueBlock.value[0].name]>"u"&&(h[t.valueBlock.value[0].name]=[]),h[t.valueBlock.value[0].name].push(e.valueBlock.value[c])}}else if(o=dt(n,e.valueBlock.value[c-s],t.valueBlock.value[c]),o.verified===!1)if(t.valueBlock.value[c].optional)s++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,te),t.name&&delete n[t.name]),o;if(o.verified===!1){const c={verified:!1,result:n};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,te),t.name&&(delete n[t.name],c.name=t.name)),c}return{verified:!0,result:n}}if(t.primitiveSchema&&_i in e.valueBlock){const s=Bt(e.valueBlock.valueHexView);if(s.offset===-1){const o={verified:!1,result:s.result};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,te),t.name&&(delete n[t.name],o.name=t.name)),o}return dt(n,s.result,t.primitiveSchema)}return{verified:!0,result:n}}function so(n,e){if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const t=Bt(v.toUint8Array(n));return t.offset===-1?{verified:!1,result:t.result}:dt(t.result,t.result,e)}var Mn=Object.freeze({__proto__:null,Any:ft,BaseBlock:F,BaseStringBlock:zr,BitString:mr,BmpString:Er,Boolean:pr,CharacterString:Cr,Choice:oi,Constructed:re,DATE:ti,DateTime:ii,Duration:ni,EndOfContent:Wr,Enumerated:vr,GeneralString:xr,GeneralizedTime:Dr,GraphicString:Sr,HexBlock:Pe,IA5String:Br,Integer:me,Null:ht,NumericString:br,ObjectIdentifier:wr,OctetString:gr,Primitive:Wt,PrintableString:Ir,RawData:no,RelativeObjectIdentifier:ei,Repeated:Kr,Sequence:Le,Set:He,TIME:si,TeletexString:Nr,TimeOfDay:ri,UTCTime:Zt,UniversalString:Ar,Utf8String:Me,ValueBlock:Z,VideotexString:kr,ViewWriter:dr,VisibleString:Yt,compareSchema:dt,fromBER:St,verifySchema:so}),j;(function(n){n[n.Sequence=0]="Sequence",n[n.Set=1]="Set",n[n.Choice=2]="Choice"})(j||(j={}));var E;(function(n){n[n.Any=1]="Any",n[n.Boolean=2]="Boolean",n[n.OctetString=3]="OctetString",n[n.BitString=4]="BitString",n[n.Integer=5]="Integer",n[n.Enumerated=6]="Enumerated",n[n.ObjectIdentifier=7]="ObjectIdentifier",n[n.Utf8String=8]="Utf8String",n[n.BmpString=9]="BmpString",n[n.UniversalString=10]="UniversalString",n[n.NumericString=11]="NumericString",n[n.PrintableString=12]="PrintableString",n[n.TeletexString=13]="TeletexString",n[n.VideotexString=14]="VideotexString",n[n.IA5String=15]="IA5String",n[n.GraphicString=16]="GraphicString",n[n.VisibleString=17]="VisibleString",n[n.GeneralString=18]="GeneralString",n[n.CharacterString=19]="CharacterString",n[n.UTCTime=20]="UTCTime",n[n.GeneralizedTime=21]="GeneralizedTime",n[n.DATE=22]="DATE",n[n.TimeOfDay=23]="TimeOfDay",n[n.DateTime=24]="DateTime",n[n.Duration=25]="Duration",n[n.TIME=26]="TIME",n[n.Null=27]="Null"})(E||(E={}));const oo={fromASN:n=>n instanceof ht?null:n.valueBeforeDecodeView,toASN:n=>{if(n===null)return new ht;const e=St(n);if(e.result.error)throw new Error(e.result.error);return e.result}},ai={fromASN:n=>n.valueBlock.valueHexView.byteLength>=4?n.valueBlock.toString():n.valueBlock.valueDec,toASN:n=>new me({value:+n})},ao={fromASN:n=>n.valueBlock.valueDec,toASN:n=>new vr({value:n})},co={fromASN:n=>n.valueBlock.valueHexView,toASN:n=>new mr({valueHex:n})},lo={fromASN:n=>n.valueBlock.toString(),toASN:n=>new wr({value:n})},uo={fromASN:n=>n.valueBlock.value,toASN:n=>new pr({value:n})},ho={fromASN:n=>n.valueBlock.valueHexView,toASN:n=>new gr({valueHex:n})};function ve(n){return{fromASN:e=>e.valueBlock.value,toASN:e=>new n({value:e})}}const fo=ve(Me),yo=ve(Er),po=ve(Ar),go=ve(br),mo=ve(Ir),vo=ve(Nr),wo=ve(kr),Eo=ve(Br),Ao=ve(Sr),bo=ve(Yt),Io=ve(xr),No=ve(Cr),ko={fromASN:n=>n.toDate(),toASN:n=>new Zt({valueDate:n})},Bo={fromASN:n=>n.toDate(),toASN:n=>new Dr({valueDate:n})},So={fromASN:()=>null,toASN:()=>new ht};function ci(n){switch(n){case E.Any:return oo;case E.BitString:return co;case E.BmpString:return yo;case E.Boolean:return uo;case E.CharacterString:return No;case E.Enumerated:return ao;case E.GeneralString:return Io;case E.GeneralizedTime:return Bo;case E.GraphicString:return Ao;case E.IA5String:return Eo;case E.Integer:return ai;case E.Null:return So;case E.NumericString:return go;case E.ObjectIdentifier:return lo;case E.OctetString:return ho;case E.PrintableString:return mo;case E.TeletexString:return vo;case E.UTCTime:return ko;case E.UniversalString:return po;case E.Utf8String:return fo;case E.VideotexString:return wo;case E.VisibleString:return bo;default:return null}}function _e(n){return typeof n=="function"&&n.prototype?n.prototype.toASN&&n.prototype.fromASN?!0:_e(n.prototype):!!(n&&typeof n=="object"&&"toASN"in n&&"fromASN"in n)}function _n(n){var e;if(n){const t=Object.getPrototypeOf(n);return((e=t==null?void 0:t.prototype)===null||e===void 0?void 0:e.constructor)===Array?!0:_n(t)}return!1}function xo(n,e){if(!(n&&e)||n.byteLength!==e.byteLength)return!1;const t=new Uint8Array(n),r=new Uint8Array(e);for(let i=0;i<n.byteLength;i++)if(t[i]!==r[i])return!1;return!0}class Co{constructor(){this.items=new WeakMap}has(e){return this.items.has(e)}get(e,t=!1){const r=this.items.get(e);if(!r)throw new Error(`Cannot get schema for '${e.prototype.constructor.name}' target`);if(t&&!r.schema)throw new Error(`Schema '${e.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);return r}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const t={type:j.Sequence,items:{}},r=this.findParentSchema(e);return r&&(Object.assign(t,r),t.items=Object.assign({},t.items,r.items)),t}create(e,t){const r=this.items.get(e)||this.createDefault(e),i=[];for(const s in r.items){const o=r.items[s],a=t?s:"";let c;if(typeof o.type=="number"){const d=E[o.type],f=Mn[d];if(!f)throw new Error(`Cannot get ASN1 class by name '${d}'`);c=new f({name:a})}else _e(o.type)?c=new o.type().toSchema(a):o.optional?this.get(o.type).type===j.Choice?c=new ft({name:a}):(c=this.create(o.type,!1),c.name=a):c=new ft({name:a});const h=!!o.optional||o.defaultValue!==void 0;if(o.repeated){c.name="";const d=o.repeated==="set"?He:Le;c=new d({name:"",value:[new Kr({name:a,value:c})]})}if(o.context!==null&&o.context!==void 0)if(o.implicit)if(typeof o.type=="number"||_e(o.type)){const d=o.repeated?re:Wt;i.push(new d({name:a,optional:h,idBlock:{tagClass:3,tagNumber:o.context}}))}else{this.cache(o.type);const d=!!o.repeated;let f=d?c:this.get(o.type,!0).schema;f="valueBlock"in f?f.valueBlock.value:f.value,i.push(new re({name:d?"":a,optional:h,idBlock:{tagClass:3,tagNumber:o.context},value:f}))}else i.push(new re({optional:h,idBlock:{tagClass:3,tagNumber:o.context},value:[c]}));else c.optional=h,i.push(c)}switch(r.type){case j.Sequence:return new Le({value:i,name:""});case j.Set:return new He({value:i,name:""});case j.Choice:return new oi({value:i,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=Object.getPrototypeOf(e);return t?this.items.get(t)||this.findParentSchema(t):null}}const we=new Co,Qt=n=>e=>{let t;we.has(e)?t=we.get(e):(t=we.createDefault(e),we.set(e,t)),Object.assign(t,n)},D=n=>(e,t)=>{let r;we.has(e.constructor)?r=we.get(e.constructor):(r=we.createDefault(e.constructor),we.set(e.constructor,r));const i=Object.assign({},n);if(typeof i.type=="number"&&!i.converter){const s=ci(n.type);if(!s)throw new Error(`Cannot get default converter for property '${t}' of ${e.constructor.name}`);i.converter=s}r.items[t]=i};class qn extends Error{constructor(){super(...arguments),this.schemas=[]}}class Do{static parse(e,t){const r=St(e);if(r.result.error)throw new Error(r.result.error);return this.fromASN(r.result,t)}static fromASN(e,t){var r;try{if(_e(t))return new t().fromASN(e);const i=we.get(t);we.cache(t);let s=i.schema;if(e.constructor===re&&i.type!==j.Choice){s=new re({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:i.schema.valueBlock.value});for(const c in i.items)delete e[c]}const o=dt({},e,s);if(!o.verified)throw new qn(`Data does not match to ${t.name} ASN1 schema. ${o.result.error}`);const a=new t;if(_n(t)){if(!("value"in e.valueBlock&&Array.isArray(e.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const c=i.itemType;if(typeof c=="number"){const h=ci(c);if(!h)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);return t.from(e.valueBlock.value,d=>h.fromASN(d))}else return t.from(e.valueBlock.value,h=>this.fromASN(h,c))}for(const c in i.items){const h=o.result[c];if(!h)continue;const d=i.items[c],f=d.type;if(typeof f=="number"||_e(f)){const b=(r=d.converter)!==null&&r!==void 0?r:_e(f)?new f:null;if(!b)throw new Error("Converter is empty");if(d.repeated)if(d.implicit){const S=d.repeated==="sequence"?Le:He,L=new S;L.valueBlock=h.valueBlock;const Ue=St(L.toBER(!1));if(Ue.offset===-1)throw new Error(`Cannot parse the child item. ${Ue.result.error}`);if(!("value"in Ue.result.valueBlock&&Array.isArray(Ue.result.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const A=Ue.result.valueBlock.value;a[c]=Array.from(A,B=>b.fromASN(B))}else a[c]=Array.from(h,S=>b.fromASN(S));else{let S=h;if(d.implicit){let L;if(_e(f))L=new f().toSchema("");else{const Ue=E[f],A=Mn[Ue];if(!A)throw new Error(`Cannot get '${Ue}' class from asn1js module`);L=new A}L.valueBlock=S.valueBlock,S=St(L.toBER(!1)).result}a[c]=b.fromASN(S)}}else if(d.repeated){if(!Array.isArray(h))throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");a[c]=Array.from(h,b=>this.fromASN(b,f))}else a[c]=this.fromASN(h,f)}return a}catch(i){throw i instanceof qn&&i.schemas.push(t.name),i}}}class Pr{static serialize(e){return e instanceof F?e.toBER(!1):this.toASN(e).toBER(!1)}static toASN(e){if(e&&typeof e=="object"&&_e(e))return e.toASN();if(!(e&&typeof e=="object"))throw new TypeError("Parameter 1 should be type of Object.");const t=e.constructor,r=we.get(t);we.cache(t);let i=[];if(r.itemType){if(!Array.isArray(e))throw new TypeError("Parameter 1 should be type of Array.");if(typeof r.itemType=="number"){const o=ci(r.itemType);if(!o)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);i=e.map(a=>o.toASN(a))}else i=e.map(o=>this.toAsnItem({type:r.itemType},"[]",t,o))}else for(const o in r.items){const a=r.items[o],c=e[o];if(c===void 0||a.defaultValue===c||typeof a.defaultValue=="object"&&typeof c=="object"&&xo(this.serialize(a.defaultValue),this.serialize(c)))continue;const h=Pr.toAsnItem(a,o,t,c);if(typeof a.context=="number")if(a.implicit)if(!a.repeated&&(typeof a.type=="number"||_e(a.type))){const d={};d.valueHex=h instanceof ht?h.valueBeforeDecodeView:h.valueBlock.toBER(),i.push(new Wt({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},...d}))}else i.push(new re({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:h.valueBlock.value}));else i.push(new re({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:[h]}));else a.repeated?i=i.concat(h):i.push(h)}let s;switch(r.type){case j.Sequence:s=new Le({value:i});break;case j.Set:s=new He({value:i});break;case j.Choice:if(!i[0])throw new Error(`Schema '${t.name}' has wrong data. Choice cannot be empty.`);s=i[0];break}return s}static toAsnItem(e,t,r,i){let s;if(typeof e.type=="number"){const o=e.converter;if(!o)throw new Error(`Property '${t}' doesn't have converter for type ${E[e.type]} in schema '${r.name}'`);if(e.repeated){if(!Array.isArray(i))throw new TypeError("Parameter 'objProp' should be type of Array.");const a=Array.from(i,h=>o.toASN(h)),c=e.repeated==="sequence"?Le:He;s=new c({value:a})}else s=o.toASN(i)}else if(e.repeated){if(!Array.isArray(i))throw new TypeError("Parameter 'objProp' should be type of Array.");const o=Array.from(i,c=>this.toASN(c)),a=e.repeated==="sequence"?Le:He;s=new a({value:o})}else s=this.toASN(i);return s}}class li{static serialize(e){return Pr.serialize(e)}static parse(e,t){return Do.parse(e,t)}static toString(e){const t=v.isBufferSource(e)?v.toArrayBuffer(e):li.serialize(e),r=St(t);if(r.offset===-1)throw new Error(`Cannot decode ASN.1 data. ${r.result.error}`);return r.result.toString()}}class Ko extends Error{constructor(e,t){super(t?`${e}. See the inner exception for more details.`:e),this.message=e,this.innerError=t}}class We extends Ko{}var Q;(function(n){n[n.Any=0]="Any",n[n.Boolean=1]="Boolean",n[n.Number=2]="Number",n[n.String=3]="String"})(Q||(Q={}));function Po(n,e){switch(e){case Q.Boolean:return typeof n=="boolean";case Q.Number:return typeof n=="number";case Q.String:return typeof n=="string"}return!0}function ui(n,e){if(!Po(n,e))throw new TypeError(`Value must be ${Q[e]}`)}function $n(n){return n&&n.prototype?n.prototype.toJSON&&n.prototype.fromJSON?!0:$n(n.prototype):!!(n&&n.toJSON&&n.fromJSON)}class Oo{constructor(){this.items=new Map}has(e){return this.items.has(e)||!!this.findParentSchema(e)}get(e){const t=this.items.get(e)||this.findParentSchema(e);if(!t)throw new Error("Cannot get schema for current target");return t}create(e){const t={names:{}},r=this.findParentSchema(e);if(r){Object.assign(t,r),t.names={};for(const i in r.names)t.names[i]=Object.assign({},r.names[i])}return t.target=e,t}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;return t?this.items.get(t)||this.findParentSchema(t):null}}const To="default",yt=new Oo;class Uo{constructor(e){this.pattern=new RegExp(e)}validate(e){const t=new RegExp(this.pattern.source,this.pattern.flags);if(typeof e!="string")throw new We("Incoming value must be string");if(!t.exec(e))throw new We(`Value doesn't match to pattern '${t.toString()}'`)}}class Vo{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(ui(e,Q.Number),!(this.min<=e&&e<=this.max)){const t=this.min===Number.MIN_VALUE?"MIN":this.min,r=this.max===Number.MAX_VALUE?"MAX":this.max;throw new We(`Value doesn't match to diapason [${t},${r}]`)}}}class Ro{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(ui(e,Q.Number),!(this.min<e&&e<this.max)){const t=this.min===Number.MIN_VALUE?"MIN":this.min,r=this.max===Number.MAX_VALUE?"MAX":this.max;throw new We(`Value doesn't match to diapason (${t},${r})`)}}}class Xo{constructor(e,t,r){this.length=e,this.minLength=t,this.maxLength=r}validate(e){if(this.length!==void 0){if(e.length!==this.length)throw new We(`Value length must be exactly ${this.length}.`);return}if(this.minLength!==void 0&&e.length<this.minLength)throw new We(`Value length must be more than ${this.minLength}.`);if(this.maxLength!==void 0&&e.length>this.maxLength)throw new We(`Value length must be less than ${this.maxLength}.`)}}class Lo{constructor(e){this.enumeration=e}validate(e){if(ui(e,Q.String),!this.enumeration.includes(e))throw new We(`Value must be one of ${this.enumeration.map(t=>`'${t}'`).join(", ")}`)}}function Ho(n){const e=[];return n.pattern&&e.push(new Uo(n.pattern)),(n.type===Q.Number||n.type===Q.Any)&&((n.minInclusive!==void 0||n.maxInclusive!==void 0)&&e.push(new Vo(n.minInclusive,n.maxInclusive)),(n.minExclusive!==void 0||n.maxExclusive!==void 0)&&e.push(new Ro(n.minExclusive,n.maxExclusive)),n.enumeration!==void 0&&e.push(new Lo(n.enumeration))),(n.type===Q.String||n.repeated||n.type===Q.Any)&&(n.length!==void 0||n.minLength!==void 0||n.maxLength!==void 0)&&e.push(new Xo(n.length,n.minLength,n.maxLength)),e}const Be=(n={})=>(e,t)=>{const r=`Cannot set type for ${t} property of ${e.constructor.name} schema`;let i;yt.has(e.constructor)?(i=yt.get(e.constructor),i.target!==e.constructor&&(i=yt.create(e.constructor),yt.set(e.constructor,i))):(i=yt.create(e.constructor),yt.set(e.constructor,i));const s={type:Q.Any,validations:[]},o=Object.assign(s,n);if(o.validations=Ho(o),typeof o.type!="number"&&!yt.has(o.type)&&!$n(o.type))throw new Error(`${r}. Assigning type doesn't have schema.`);let a;Array.isArray(n.schema)?a=n.schema:a=[n.schema||To];for(const c of a){i.names[c]||(i.names[c]={});const h=i.names[c];h[t]=o}};/*!
 Copyright (c) Peculiar Ventures, LLC
*/class Fn extends Error{}class Mo extends Fn{}class Jn{static toArrayBuffer(e){const t=e.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace(`
`,"");return y.FromBase64(t)}static toUint8Array(e){const t=this.toArrayBuffer(e);return new Uint8Array(t)}static fromBufferSource(e,t){const r=y.ToBase64(e);let i,s=0;const o=[];for(;s<r.length&&(i=r.slice(s,s+64),i.length);){o.push(i);s+=64}const a=t.toUpperCase();return`-----BEGIN ${a}-----
${o.join(`
`)}
-----END ${a}-----`}static isPEM(e){return/-----BEGIN .+-----[A-Za-z0-9+/+=\s\n]+-----END .+-----/i.test(e)}static getTagName(e){if(!this.isPEM(e))throw new Error("Bad parameter. Incoming data is not right PEM");const t=/-----BEGIN (.+)-----/.exec(e);if(!t)throw new Error("Cannot get tag from PEM");return t[1]}static hasTagName(e,t){const r=this.getTagName(e);return t.toLowerCase()===r.toLowerCase()}static isCertificate(e){return this.hasTagName(e,"certificate")}static isCertificateRequest(e){return this.hasTagName(e,"certificate request")}static isCRL(e){return this.hasTagName(e,"x509 crl")}static isPublicKey(e){return this.hasTagName(e,"public key")}}const _o=["secret","private","public"];class qo{static create(e,t,r,i){const s=new this;return s.algorithm=e,s.type=t,s.extractable=r,s.usages=i,s}static isKeyType(e){return _o.indexOf(e)!==-1}get[Symbol.toStringTag](){return"CryptoKey"}}let Or=class{constructor(e){e&&(this.value=e)}};l([D({type:E.ObjectIdentifier})],Or.prototype,"value",void 0),Or=l([Qt({type:j.Choice})],Or);class xt{constructor(e){Object.assign(this,e)}}l([D({type:E.ObjectIdentifier})],xt.prototype,"algorithm",void 0),l([D({type:E.Any,optional:!0})],xt.prototype,"parameters",void 0);class er{constructor(){this.version=0,this.privateKeyAlgorithm=new xt,this.privateKey=new ArrayBuffer(0)}}l([D({type:E.Integer})],er.prototype,"version",void 0),l([D({type:xt})],er.prototype,"privateKeyAlgorithm",void 0),l([D({type:E.OctetString})],er.prototype,"privateKey",void 0),l([D({type:E.Any,optional:!0})],er.prototype,"attributes",void 0);class jn{constructor(){this.publicKeyAlgorithm=new xt,this.publicKey=new ArrayBuffer(0)}}l([D({type:xt})],jn.prototype,"publicKeyAlgorithm",void 0),l([D({type:E.BitString})],jn.prototype,"publicKey",void 0);const Se={fromJSON:n=>y.FromBase64Url(n),toJSON:n=>y.ToBase64Url(new Uint8Array(n))},Oe={fromASN:n=>{const e=n.valueBlock.valueHex;return new Uint8Array(e)[0]?n.valueBlock.valueHex:n.valueBlock.valueHex.slice(1)},toASN:n=>{const e=new Uint8Array(n)[0]>127?mt(new Uint8Array([0]).buffer,n):n;return new me({valueHex:e})}};class Te{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}l([D({type:E.Integer,converter:ai})],Te.prototype,"version",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"n",converter:Se})],Te.prototype,"modulus",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"e",converter:Se})],Te.prototype,"publicExponent",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"d",converter:Se})],Te.prototype,"privateExponent",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"p",converter:Se})],Te.prototype,"prime1",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"q",converter:Se})],Te.prototype,"prime2",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"dp",converter:Se})],Te.prototype,"exponent1",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"dq",converter:Se})],Te.prototype,"exponent2",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"qi",converter:Se})],Te.prototype,"coefficient",void 0),l([D({type:E.Any,optional:!0})],Te.prototype,"otherPrimeInfos",void 0);class Gn{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}l([D({type:E.Integer,converter:Oe}),Be({name:"n",converter:Se})],Gn.prototype,"modulus",void 0),l([D({type:E.Integer,converter:Oe}),Be({name:"e",converter:Se})],Gn.prototype,"publicExponent",void 0);let tr=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){let e=new Uint8Array(this.value);if(e[0]!==4)throw new Fn("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");e=new Uint8Array(this.value.slice(1));const t=e.length/2,r=0;return{x:y.ToBase64Url(e.buffer.slice(r,r+t)),y:y.ToBase64Url(e.buffer.slice(r+t,r+t+t))}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");if(!("y"in e))throw new Error("y: Missing required property");const t=y.FromBase64Url(e.x),r=y.FromBase64Url(e.y),i=mt(new Uint8Array([4]).buffer,t,r);return this.value=new Uint8Array(i).buffer,this}};l([D({type:E.OctetString})],tr.prototype,"value",void 0),tr=l([Qt({type:j.Choice})],tr);class Tr{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(e){if(!("d"in e))throw new Error("d: Missing required property");if(this.privateKey=y.FromBase64Url(e.d),"x"in e){const t=new tr;t.fromJSON(e);const r=Pr.toASN(t);"valueHex"in r.valueBlock&&(this.publicKey=r.valueBlock.valueHex)}return this}toJSON(){const e={};return e.d=y.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(e,new tr(this.publicKey).toJSON()),e}}l([D({type:E.Integer,converter:ai})],Tr.prototype,"version",void 0),l([D({type:E.OctetString})],Tr.prototype,"privateKey",void 0),l([D({context:0,type:E.Any,optional:!0})],Tr.prototype,"parameters",void 0),l([D({context:1,type:E.BitString,optional:!0})],Tr.prototype,"publicKey",void 0);const zn={fromASN:n=>{const e=new Uint8Array(n.valueBlock.valueHex);return e[0]===0?e.buffer.slice(1):e.buffer},toASN:n=>{const e=new Uint8Array(n);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new me({valueHex:t.buffer})}return new me({valueHex:n})}};class Wn{static decodePoint(e,t){const r=v.toUint8Array(e);if(r.length===0||r[0]!==4)throw new Error("Only uncompressed point format supported");const i=(r.length-1)/2;if(i!==Math.ceil(t/8))throw new Error("Point does not match field size");const s=r.slice(1,i+1),o=r.slice(i+1,i+1+i);return{x:s,y:o}}static encodePoint(e,t){const r=Math.ceil(t/8);if(e.x.byteLength!==r||e.y.byteLength!==r)throw new Error("X,Y coordinates don't match point size criteria");const i=v.toUint8Array(e.x),s=v.toUint8Array(e.y),o=new Uint8Array(r*2+1);return o[0]=4,o.set(i,1),o.set(s,r+1),o}static getSize(e){return Math.ceil(e/8)}static encodeSignature(e,t){const r=this.getSize(t),i=v.toUint8Array(e.r),s=v.toUint8Array(e.s),o=new Uint8Array(r*2);return o.set(this.padStart(i,r)),o.set(this.padStart(s,r),r),o}static decodeSignature(e,t){const r=this.getSize(t),i=v.toUint8Array(e);if(i.length!==r*2)throw new Error("Incorrect size of the signature");const s=i.slice(0,r),o=i.slice(r);return{r:this.trimStart(s),s:this.trimStart(o)}}static trimStart(e){let t=0;for(;t<e.length-1&&e[t]===0;)t++;return t===0?e:e.slice(t,e.length)}static padStart(e,t){if(t===e.length)return e;const r=new Uint8Array(t);return r.set(e,t-e.length),r}}class Ur{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(e){const t=e.byteLength/2,r=Wn.decodeSignature(e,t*8),i=new Ur;return i.r=v.toArrayBuffer(r.r),i.s=v.toArrayBuffer(r.s),i}toWebCryptoSignature(e){if(!e){const r=Math.max(this.r.byteLength,this.s.byteLength);r<=32?e=256:r<=48?e=384:e=521}return Wn.encodeSignature(this,e).buffer}}l([D({type:E.Integer,converter:zn})],Ur.prototype,"r",void 0),l([D({type:E.Integer,converter:zn})],Ur.prototype,"s",void 0);class $o extends er{}l([D({context:1,implicit:!0,type:E.BitString,optional:!0})],$o.prototype,"publicKey",void 0);let hi=class{constructor(){this.value=new ArrayBuffer(0)}fromJSON(e){if(!e.d)throw new Error("d: Missing required property");return this.value=y.FromBase64Url(e.d),this}toJSON(){return{d:y.ToBase64Url(this.value)}}};l([D({type:E.OctetString})],hi.prototype,"value",void 0),hi=l([Qt({type:j.Choice})],hi);let fi=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){return{x:y.ToBase64Url(this.value)}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");return this.value=y.FromBase64Url(e.x),this}};l([D({type:E.BitString})],fi.prototype,"value",void 0),fi=l([Qt({type:j.Choice})],fi);let di=class{};l([D({type:E.OctetString}),Be({type:Q.String,converter:Se})],di.prototype,"d",void 0),di=l([Qt({type:j.Choice})],di);const Fo="1.2.840.10045.3.1.7",yi="1.3.132.0",Jo=`${yi}.34`,jo=`${yi}.35`,Go=`${yi}.10`,ie="1.3.36.3.3.2.8.1.1",zo=`${ie}.1`,Wo=`${ie}.2`,Yo=`${ie}.3`,Zo=`${ie}.4`,Qo=`${ie}.5`,ea=`${ie}.6`,ta=`${ie}.7`,ra=`${ie}.8`,ia=`${ie}.9`,na=`${ie}.10`,sa=`${ie}.11`,oa=`${ie}.12`,aa=`${ie}.13`,ca=`${ie}.14`;class M{constructor(){}static register(e){const t=new Or;t.value=e.id;const r=li.serialize(t);this.items.push({...e,raw:r}),this.names.push(e.name)}static find(e){e=e.toUpperCase();for(const t of this.items)if(t.name.toUpperCase()===e||t.id.toUpperCase()===e)return t;return null}static get(e){const t=this.find(e);if(!t)throw new Error(`Unsupported EC named curve '${e}'`);return t}}M.items=[],M.names=[],M.register({name:"P-256",id:Fo,size:256}),M.register({name:"P-384",id:Jo,size:384}),M.register({name:"P-521",id:jo,size:521}),M.register({name:"K-256",id:Go,size:256}),M.register({name:"brainpoolP160r1",id:zo,size:160}),M.register({name:"brainpoolP160t1",id:Wo,size:160}),M.register({name:"brainpoolP192r1",id:Yo,size:192}),M.register({name:"brainpoolP192t1",id:Zo,size:192}),M.register({name:"brainpoolP224r1",id:Qo,size:224}),M.register({name:"brainpoolP224t1",id:ea,size:224}),M.register({name:"brainpoolP256r1",id:ta,size:256}),M.register({name:"brainpoolP256t1",id:ra,size:256}),M.register({name:"brainpoolP320r1",id:ia,size:320}),M.register({name:"brainpoolP320t1",id:na,size:320}),M.register({name:"brainpoolP384r1",id:sa,size:384}),M.register({name:"brainpoolP384t1",id:oa,size:384}),M.register({name:"brainpoolP512r1",id:aa,size:512}),M.register({name:"brainpoolP512t1",id:ca,size:512});class la{get[Symbol.toStringTag](){return"Crypto"}randomUUID(){const e=this.getRandomValues(new Uint8Array(16));e[6]=e[6]&15|64,e[8]=e[8]&63|128;const t=y.ToHex(e).toLowerCase();return`${t.substring(0,8)}-${t.substring(8,12)}-${t.substring(12,16)}-${t.substring(16,20)}-${t.substring(20)}`}}class ua{constructor(){this.items={}}get(e){return this.items[e.toLowerCase()]||null}set(e){this.items[e.name.toLowerCase()]=e}removeAt(e){const t=this.get(e.toLowerCase());return t&&delete this.items[e],t}has(e){return!!this.get(e)}get length(){return Object.keys(this.items).length}get algorithms(){const e=[];for(const t in this.items){const r=this.items[t];e.push(r.name)}return e.sort()}}const Yn={jwk:["private","public","secret"],pkcs8:["private"],spki:["public"],raw:["secret","public"]},ha=["pkcs8","spki","raw"];let fa=class ss{constructor(){this.providers=new ua}static isHashedAlgorithm(e){return!!(e&&typeof e=="object"&&"name"in e&&"hash"in e)}get[Symbol.toStringTag](){return"SubtleCrypto"}async digest(...e){this.checkRequiredArguments(e,2,"digest");const[t,r,...i]=e,s=this.prepareAlgorithm(t),o=v.toArrayBuffer(r);return await this.getProvider(s.name).digest(s,o,...i)}async generateKey(...e){this.checkRequiredArguments(e,3,"generateKey");const[t,r,i,...s]=e,o=this.prepareAlgorithm(t),a=this.getProvider(o.name);return await a.generateKey({...o,name:a.name},r,i,...s)}async sign(...e){this.checkRequiredArguments(e,3,"sign");const[t,r,i,...s]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=v.toArrayBuffer(i),c=this.getProvider(o.name);return await c.sign({...o,name:c.name},r,a,...s)}async verify(...e){this.checkRequiredArguments(e,4,"verify");const[t,r,i,s,...o]=e;this.checkCryptoKey(r);const a=this.prepareAlgorithm(t),c=v.toArrayBuffer(s),h=v.toArrayBuffer(i),d=this.getProvider(a.name);return await d.verify({...a,name:d.name},r,h,c,...o)}async encrypt(...e){this.checkRequiredArguments(e,3,"encrypt");const[t,r,i,...s]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=v.toArrayBuffer(i),c=this.getProvider(o.name);return await c.encrypt({...o,name:c.name},r,a,{keyUsage:!0},...s)}async decrypt(...e){this.checkRequiredArguments(e,3,"decrypt");const[t,r,i,...s]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=v.toArrayBuffer(i),c=this.getProvider(o.name);return await c.decrypt({...o,name:c.name},r,a,{keyUsage:!0},...s)}async deriveBits(...e){this.checkRequiredArguments(e,3,"deriveBits");const[t,r,i,...s]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=this.getProvider(o.name);return await a.deriveBits({...o,name:a.name},r,i,{keyUsage:!0},...s)}async deriveKey(...e){this.checkRequiredArguments(e,5,"deriveKey");const[t,r,i,s,o,...a]=e,c=this.prepareAlgorithm(i);this.getProvider(c.name).checkDerivedKeyParams(c);const d=this.prepareAlgorithm(t),f=this.getProvider(d.name);f.checkCryptoKey(r,"deriveKey");const b=await f.deriveBits({...d,name:f.name},r,i.length||512,{keyUsage:!1},...a);return this.importKey("raw",b,i,s,o,...a)}async exportKey(...e){this.checkRequiredArguments(e,2,"exportKey");const[t,r,...i]=e;if(this.checkCryptoKey(r),!Yn[t])throw new TypeError("Invalid keyFormat argument");if(!Yn[t].includes(r.type))throw new DOMException("The key is not of the expected type");return await this.getProvider(r.algorithm.name).exportKey(t,r,...i)}async importKey(...e){this.checkRequiredArguments(e,5,"importKey");const[t,r,i,s,o,...a]=e,c=this.prepareAlgorithm(i),h=this.getProvider(c.name);if(t==="jwk"){if(typeof r!="object"||!r.kty)throw new TypeError("Key data must be an object for JWK import")}else if(ha.includes(t)){if(!v.isBufferSource(r))throw new TypeError("Key data must be a BufferSource for non-JWK formats")}else throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView or JsonWebKey)'");return h.importKey(t,r,{...c,name:h.name},s,o,...a)}async wrapKey(e,t,r,i,...s){let o=await this.exportKey(e,t,...s);if(e==="jwk"){const d=JSON.stringify(o);o=y.FromUtf8String(d)}const a=this.prepareAlgorithm(i),c=v.toArrayBuffer(o),h=this.getProvider(a.name);return h.encrypt({...a,name:h.name},r,c,{keyUsage:!1},...s)}async unwrapKey(e,t,r,i,s,o,a,...c){const h=this.prepareAlgorithm(i),d=v.toArrayBuffer(t),f=this.getProvider(h.name);let b=await f.decrypt({...h,name:f.name},r,d,{keyUsage:!1},...c);if(e==="jwk")try{b=JSON.parse(y.ToUtf8String(b))}catch(S){const L=new TypeError("wrappedKey: Is not a JSON");throw L.internal=S,L}return this.importKey(e,b,s,o,a,...c)}checkRequiredArguments(e,t,r){if(e.length<t)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${t} arguments required, but only ${e.length} present`)}prepareAlgorithm(e){if(typeof e=="string")return{name:e};if(ss.isHashedAlgorithm(e)){const t={...e};return t.hash=this.prepareAlgorithm(e.hash),t}return{...e}}getProvider(e){const t=this.providers.get(e);if(!t)throw new Mo("Unrecognized name");return t}checkCryptoKey(e){if(!(e instanceof qo))throw new TypeError("Key is not of type 'CryptoKey'")}};function Ea(n){return n}function da(n){return n instanceof Object&&"name"in n&&"hash"in n}function ee(n){if(n instanceof w)return n;const e=new w;if(typeof n=="string")e.fromAlgorithm({name:n});else if(da(n)){const t={...n};t.hash=ee(n.hash),e.fromAlgorithm(t)}else e.fromAlgorithm({...n});return e}function ya(n){return n instanceof I}function pa(n){return n instanceof O}function ne(n,e){if(!(n&&(typeof n=="object"||typeof n=="string")))throw new TypeError(`${e}: Is wrong type. Must be Object or String`);if(typeof n=="object"&&!("name"in n))throw new TypeError(`${e}: Required property 'name' is missed`)}function de(n,e){if(!ya(n))throw new TypeError(`${e}: Is not type CryptoKey`)}function Vr(n,e){if(!pa(n))throw new TypeError(`${e}: Is not type CryptoCertificate`)}function Ye(n,e){if(!v.isBufferSource(n))throw new TypeError(`${e}: Is wrong type. Must be ArrayBuffer or ArrayBuffer view`)}function pt(n,e){if(!Array.isArray(n))throw new TypeError(`${e}: Is not type Array`)}function _(n,e,t){if(typeof n!==e)throw new TypeError(`${t}: Is not type '${e}'`)}const Zn=["raw","pem","x509","request"];class Qn{static isX509Certificate(e){return e instanceof z}static isCertificateRequest(e){return e instanceof Ze}constructor(e){this.provider=e}async indexOf(e){Vr(e,"item");const t=new tt;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return r?y.ToUtf8String(r):null}async hasItem(e){return!!await this.indexOf(e)}async exportCert(e,t){_(e,"string","format"),Vr(t,"item");const r=new Ve;r.providerID=this.provider.id,r.format="raw",r.item=t;const i=await this.provider.client.send(r);if(e==="raw")return i;{let s="";switch(t.type){case"x509":{s="CERTIFICATE";break}case"request":{s="CERTIFICATE REQUEST";break}default:throw new Error("Cannot create PEM for unknown type of certificate item")}return Jn.fromBufferSource(i,s)}}async importCert(e,t,r,i){if(_(e,"string","format"),!~Zn.indexOf(e))throw new TypeError(`format: Is invalid value. Must be ${Zn.join(", ")}`);e==="pem"?_(t,"string","data"):Ye(t,"data"),ne(r,"algorithm"),pt(i,"keyUsages");const s=ee(r);let o;if(v.isBufferSource(t))o=v.toArrayBuffer(t);else if(typeof t=="string")o=Jn.toArrayBuffer(t);else throw new TypeError("data: Is not type String, ArrayBuffer or ArrayBufferView");const a=new ae;a.providerID=this.provider.id,a.format="raw",a.data=o,a.algorithm=s,a.keyUsages=i;const c=await this.provider.client.send(a),h=await O.importProto(c);if((e==="request"||e==="x509")&&h.type!==e)throw new TypeError(`Imported item is not ${e}`);return this.prepareCertItem(h)}async keys(){const e=new Lt;e.providerID=this.provider.id;const t=await this.provider.client.send(e);return t?y.ToUtf8String(t).split(","):[]}async getValue(e){_(e,"string","key");const t=new Qe;t.providerID=this.provider.id,t.key=e;const r=await this.provider.client.send(t);return r||null}async getItem(e,t,r){_(e,"string","key"),t&&(ne(t,"algorithm"),pt(r,"keyUsages"));const i=new Ae;i.providerID=this.provider.id,i.key=e,t&&(i.algorithm=ee(t),i.keyUsages=r);const s=await this.provider.client.send(i);if(s&&s.byteLength){const o=await O.importProto(s);return this.prepareCertItem(o)}throw new Error("Cannot get CryptoCertificate from storage by index")}async setItem(e){Vr(e,"value");const t=new Je;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return y.ToUtf8String(r)}async removeItem(e){_(e,"string","key");const t=new et;t.providerID=this.provider.id,t.key=e,await this.provider.client.send(t)}async clear(){const e=new Ht;e.providerID=this.provider.id,await this.provider.client.send(e)}async getChain(e){Vr(e,"value");const t=new It;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return(await bt.importProto(r)).items}async getCRL(e){_(e,"string","url");const t=new rt;return t.providerID=this.provider.id,t.url=e,await this.provider.client.send(t)}async getOCSP(e,t,r){_(e,"string","url"),Ye(t,"request");const i=new be;if(i.providerID=this.provider.id,i.url=e,i.request=v.toArrayBuffer(t),r)for(const o in r)i.options[o]=r[o];return await this.provider.client.send(i)}async findPrivateKey(e){let t=typeof e=="string"?e:await this.provider.certStorage.indexOf(e);t||(t="");const[,,r]=t.split("-"),i=(await this.provider.keyStorage.keys()).find(s=>{const[o,,a]=s.split("-");return o==="private"&&a===r});return i?await this.provider.keyStorage.getItem(i):null}async prepareCertItem(e){const t=await e.exportProto();let r;switch(e.type){case"x509":{r=await z.importProto(t);break}case"request":{r=await Ze.importProto(t);break}default:throw new Error(`Unsupported CertificateItem type '${e.type}'`)}return r.provider=this.provider,r}}class es{constructor(e){this.service=e}async keys(){const e=new Mt;e.providerID=this.service.id;const t=await this.service.client.send(e);return t?y.ToUtf8String(t).split(","):[]}async indexOf(e){de(e,"item");const t=new ot;t.providerID=this.service.id,t.item=e;const r=await this.service.client.send(t);return r?y.ToUtf8String(r):null}async hasItem(e){return!!await this.indexOf(e)}async getItem(e,t,r,i){_(e,"string","key"),t&&(ne(t,"algorithm"),_(r,"boolean","extractable"),pt(i,"usages"));const s=new ce;s.providerID=this.service.id,s.key=e,t&&(s.algorithm=ee(t),s.extractable=r,s.keyUsages=i);const o=await this.service.client.send(s);let a;if(o&&o.byteLength)a=await I.importProto(o);else throw new Error("Cannot get CryptoKey from key storage by index");return a}async setItem(e){de(e,"value");const t=new nt;t.providerID=this.service.id,t.item=e;const r=await this.service.client.send(t);return y.ToUtf8String(r)}async removeItem(e){_(e,"string","key");const t=new st;t.providerID=this.service.id,t.key=e,await this.service.client.send(t)}async clear(){const e=new _t;e.providerID=this.service.id,await this.service.client.send(e)}}class ga extends fa{constructor(e){super(),this.service=e}async encrypt(e,t,r){return this.encryptData(e,t,r,"encrypt")}async decrypt(e,t,r){return this.encryptData(e,t,r,"decrypt")}async deriveBits(e,t,r){ne(e,"algorithm"),de(t,"baseKey"),_(r,"number","length");const i=ee(e);de(i.public,"algorithm.public"),i.public=await i.public.exportProto();const s=new Ne;return s.providerID=this.service.id,s.algorithm=i,s.key=t,s.length=r,await this.service.client.send(s)}async deriveKey(e,t,r,i,s){ne(e,"algorithm"),de(t,"baseKey"),ne(r,"algorithm"),_(i,"boolean","extractable"),pt(s,"keyUsages");const o=ee(e);de(o.public,"algorithm.public"),o.public=await o.public.exportProto();const a=ee(r),c=new W;c.providerID=this.service.id,c.algorithm=o,c.derivedKeyType.fromAlgorithm(a),c.key=t,c.extractable=i,c.usage=s;const h=await this.service.client.send(c);return await I.importProto(h)}async digest(e,t){return k().crypto.subtle.digest(e,t)}async generateKey(e,t,r){ne(e,"algorithm"),_(t,"boolean","extractable"),pt(r,"keyUsages");const i=ee(e),s=new Ie;s.providerID=this.service.id,s.algorithm=i,s.extractable=t,s.usage=r;const o=await this.service.client.send(s);try{return await $e.importProto(o)}catch{return await I.importProto(o)}}async exportKey(e,t){_(e,"string","format"),de(t,"key");const r=new Re;r.providerID=this.service.id,r.format=e,r.key=t;const i=await this.service.client.send(r);return e==="jwk"?JSON.parse(y.ToBinary(i)):i}async importKey(e,t,r,i,s){_(e,"string","format"),ne(r,"algorithm"),_(i,"boolean","extractable"),pt(s,"keyUsages");const o=ee(r);let a;e==="jwk"?a=y.FromUtf8String(JSON.stringify(t)):(Ye(t,"keyData"),a=v.toArrayBuffer(t));const c=new Y;c.providerID=this.service.id,c.algorithm=o,c.keyData=a,c.format=e,c.extractable=i,c.keyUsages=s;const h=await this.service.client.send(c);return await I.importProto(h)}async sign(e,t,r){ne(e,"algorithm"),de(t,"key"),Ye(r,"data");const i=ee(e),s=v.toArrayBuffer(r),o=new $;return o.providerID=this.service.id,o.algorithm=i,o.key=t,o.data=s,await this.service.client.send(o)}async verify(e,t,r,i){ne(e,"algorithm"),de(t,"key"),Ye(r,"signature"),Ye(i,"data");const s=ee(e),o=v.toArrayBuffer(r),a=v.toArrayBuffer(i),c=new ct;c.providerID=this.service.id,c.algorithm=s,c.key=t,c.data=a,c.signature=o;const h=await this.service.client.send(c);return!!new Uint8Array(h)[0]}async wrapKey(e,t,r,i){_(e,"string","format"),de(t,"key"),de(r,"wrappingKey"),ne(i,"wrapAlgorithm");const s=ee(i),o=new ue;return o.providerID=this.service.id,o.wrapAlgorithm=s,o.key=t,o.wrappingKey=r,o.format=e,await this.service.client.send(o)}async unwrapKey(e,t,r,i,s,o,a){_(e,"string","format"),Ye(t,"wrappedKey"),de(r,"unwrappingKey"),ne(i,"unwrapAlgorithm"),ne(s,"unwrappedKeyAlgorithm"),_(o,"boolean","extractable"),pt(a,"keyUsages");const c=ee(i),h=ee(s),d=v.toArrayBuffer(t),f=new q;f.providerID=this.service.id,f.format=e,f.unwrapAlgorithm=c,f.unwrappedKeyAlgorithm=h,f.unwrappingKey=r,f.wrappedKey=d,f.extractable=o,f.keyUsage=a;const b=await this.service.client.send(f);return await I.importProto(b)}async encryptData(e,t,r,i){ne(e,"algorithm"),de(t,"key"),Ye(r,"data");const s=ee(e),o=v.toArrayBuffer(r);let a;i==="encrypt"?a=$t:a=Ft;const c=new a;return c.providerID=this.service.id,c.algorithm=s,c.key=t,c.data=o,await this.service.client.send(c)}}class ts extends la{constructor(e,t){super(),this.client=e,this.id=t,this.subtle=new ga(this),this.keyStorage=new es(this),this.certStorage=new Qn(this)}getRandomValues(e){return k().crypto.getRandomValues(e)}async login(){const e=new Ut;return e.providerID=this.id,this.client.send(e)}async logout(){const e=new Vt;return e.providerID=this.id,this.client.send(e)}async reset(){const e=new Xt;return e.providerID=this.id,this.client.send(e)}async isLoggedIn(){const e=new Rt;e.providerID=this.id;const t=await this.client.send(e);return!!new Uint8Array(t)[0]}}class Rr extends P{get state(){return this.client.state}constructor(e){super(),this.client=new qs(e.storage),this.cardReader=new Vs(this.client)}connect(e=Rr.FORTIFY,t){return this.removeAllListeners(),this.client.connect(e,t).on("error",r=>{this.emit("error",r.error)}).on("event",r=>{(async()=>{switch(r.action){case ge.ACTION:{const i=await ge.importProto(await r.exportProto());this.emit("token",i)}case Nt.ACTION:{const i=await Nt.importProto(await r.exportProto());this.emit("auth",i)}}})()}).on("listening",r=>{this.emit("listening",e)}).on("close",r=>{this.emit("close",r.remoteAddress)}),this}close(){this.client.close()}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async info(){const e=new qt,t=await this.client.send(e);return await je.importProto(t)}async challenge(){return this.client.challenge()}async isLoggedIn(){return this.client.isLoggedIn()}async login(){return this.client.login()}async getCrypto(e){const t=new at;return t.cryptoID=e,await this.client.send(t),new ts(this.client,e)}}Rr.FORTIFY="127.0.0.1:31337";class pi{}function rs(n,e){return e={exports:{}},n(e,e.exports),e.exports}var ma=rs(function(n){(function(){function e(A){return Array.prototype.slice.call(A)}function t(A){return new Promise(function(B,T){A.onsuccess=function(){B(A.result)},A.onerror=function(){T(A.error)}})}function r(A,B,T){var R,K=new Promise(function(xe,rr){R=A[B].apply(A,T),t(R).then(xe,rr)});return K.request=R,K}function i(A,B,T){var R=r(A,B,T);return R.then(function(K){if(K)return new d(K,R.request)})}function s(A,B,T){T.forEach(function(R){Object.defineProperty(A.prototype,R,{get:function(){return this[B][R]},set:function(K){this[B][R]=K}})})}function o(A,B,T,R){R.forEach(function(K){K in T.prototype&&(A.prototype[K]=function(){return r(this[B],K,arguments)})})}function a(A,B,T,R){R.forEach(function(K){K in T.prototype&&(A.prototype[K]=function(){return this[B][K].apply(this[B],arguments)})})}function c(A,B,T,R){R.forEach(function(K){K in T.prototype&&(A.prototype[K]=function(){return i(this[B],K,arguments)})})}function h(A){this._index=A}s(h,"_index",["name","keyPath","multiEntry","unique"]),o(h,"_index",IDBIndex,["get","getKey","getAll","getAllKeys","count"]),c(h,"_index",IDBIndex,["openCursor","openKeyCursor"]);function d(A,B){this._cursor=A,this._request=B}s(d,"_cursor",["direction","key","primaryKey","value"]),o(d,"_cursor",IDBCursor,["update","delete"]),["advance","continue","continuePrimaryKey"].forEach(function(A){A in IDBCursor.prototype&&(d.prototype[A]=function(){var B=this,T=arguments;return Promise.resolve().then(function(){return B._cursor[A].apply(B._cursor,T),t(B._request).then(function(R){if(R)return new d(R,B._request)})})})});function f(A){this._store=A}f.prototype.createIndex=function(){return new h(this._store.createIndex.apply(this._store,arguments))},f.prototype.index=function(){return new h(this._store.index.apply(this._store,arguments))},s(f,"_store",["name","keyPath","indexNames","autoIncrement"]),o(f,"_store",IDBObjectStore,["put","add","delete","clear","get","getAll","getKey","getAllKeys","count"]),c(f,"_store",IDBObjectStore,["openCursor","openKeyCursor"]),a(f,"_store",IDBObjectStore,["deleteIndex"]);function b(A){this._tx=A,this.complete=new Promise(function(B,T){A.oncomplete=function(){B()},A.onerror=function(){T(A.error)},A.onabort=function(){T(A.error)}})}b.prototype.objectStore=function(){return new f(this._tx.objectStore.apply(this._tx,arguments))},s(b,"_tx",["objectStoreNames","mode"]),a(b,"_tx",IDBTransaction,["abort"]);function S(A,B,T){this._db=A,this.oldVersion=B,this.transaction=new b(T)}S.prototype.createObjectStore=function(){return new f(this._db.createObjectStore.apply(this._db,arguments))},s(S,"_db",["name","version","objectStoreNames"]),a(S,"_db",IDBDatabase,["deleteObjectStore","close"]);function L(A){this._db=A}L.prototype.transaction=function(){return new b(this._db.transaction.apply(this._db,arguments))},s(L,"_db",["name","version","objectStoreNames"]),a(L,"_db",IDBDatabase,["close"]),["openCursor","openKeyCursor"].forEach(function(A){[f,h].forEach(function(B){A in B.prototype&&(B.prototype[A.replace("open","iterate")]=function(){var T=e(arguments),R=T[T.length-1],K=this._store||this._index,xe=K[A].apply(K,T.slice(0,-1));xe.onsuccess=function(){R(xe.result)}})})}),[h,f].forEach(function(A){A.prototype.getAll||(A.prototype.getAll=function(B,T){var R=this,K=[];return new Promise(function(xe){R.iterateCursor(B,function(rr){if(!rr){xe(K);return}if(K.push(rr.value),T!==void 0&&K.length==T){xe(K);return}rr.continue()})})})});var Ue={open:function(A,B,T){var R=r(indexedDB,"open",[A,B]),K=R.request;return K&&(K.onupgradeneeded=function(xe){T&&T(new S(K.result,xe.oldVersion,K.transaction))}),R.then(function(xe){return new L(xe)})},delete:function(A){return r(indexedDB,"deleteDatabase",[A])}};n.exports=Ue,n.exports.default=n.exports})()}),is=rs(function(n){typeof indexedDB<"u"?n.exports=ma:n.exports={open:function(){return Promise.reject("IDB requires a browser environment")},delete:function(){return Promise.reject("IDB requires a browser environment")}}});is.open;class V extends pi{static async create(){const e=await is.open(this.STORAGE_NAME,2,t=>{t.oldVersion===1&&(t.deleteObjectStore(this.SESSION_STORAGE),t.deleteObjectStore(this.IDENTITY_STORAGE),t.deleteObjectStore(this.REMOTE_STORAGE)),t.createObjectStore(this.SESSION_STORAGE),t.createObjectStore(this.IDENTITY_STORAGE),t.createObjectStore(this.REMOTE_STORAGE)});return new V(e)}constructor(e){super(),this.db=e}async loadWrapKey(){const e=await this.db.transaction(V.IDENTITY_STORAGE).objectStore(V.IDENTITY_STORAGE).get(V.WRAP_KEY);return e?(J.iv=e.iv,e.key instanceof ArrayBuffer?{key:await k().crypto.subtle.importKey("raw",e.key,{name:J.name,length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),iv:e.iv}:{key:e.key,iv:e.iv}):null}async saveWrapKey(e){let t;Jt()||jt()?t={key:await k().crypto.subtle.exportKey("raw",e.key),iv:e.iv}:t={...e},await this.db.transaction(V.IDENTITY_STORAGE,"readwrite").objectStore(V.IDENTITY_STORAGE).put(t,V.WRAP_KEY)}async loadIdentity(){const e=await this.db.transaction(V.IDENTITY_STORAGE).objectStore(V.IDENTITY_STORAGE).get(V.IDENTITY);let t=null;if(e){if(qr()||Jt()||jt()){const r=await this.loadWrapKey();if(!(r&&r.key.usages.some(i=>i==="encrypt")&&e.exchangeKey.privateKey instanceof ArrayBuffer))return null;e.exchangeKey.privateKey=await k().crypto.subtle.unwrapKey("jwk",e.exchangeKey.privateKey,r.key,J,$r,!1,["deriveKey","deriveBits"]),e.signingKey.privateKey=await k().crypto.subtle.unwrapKey("jwk",e.signingKey.privateKey,r.key,J,Fr,!1,["sign"]),e.exchangeKey.publicKey=await k().crypto.subtle.unwrapKey("jwk",e.exchangeKey.publicKey,r.key,J,$r,!0,[]),e.signingKey.publicKey=await k().crypto.subtle.unwrapKey("jwk",e.signingKey.publicKey,r.key,J,Fr,!0,["verify"])}t=await sr.fromJSON(e)}return t}async saveIdentity(e){let t;if(qr()||Jt()||jt()){t={key:await k().crypto.subtle.generateKey({name:J.name,length:256},Jt()||jt(),["wrapKey","unwrapKey","encrypt","decrypt"]),iv:k().crypto.getRandomValues(new Uint8Array(J.iv)).buffer},await this.saveWrapKey(t);const i=await k().crypto.subtle.generateKey(e.exchangeKey.privateKey.algorithm,!0,["deriveKey","deriveBits"]);e.exchangeKey.privateKey=i.privateKey,await Li(e.exchangeKey.publicKey,i.publicKey);const s=await k().crypto.subtle.generateKey(e.signingKey.privateKey.algorithm,!0,["sign","verify"]);e.signingKey.privateKey=s.privateKey,await Li(e.signingKey.publicKey,s.publicKey)}const r=await e.toJSON();t&&(r.exchangeKey.privateKey=await k().crypto.subtle.wrapKey("jwk",e.exchangeKey.privateKey,t.key,J),r.signingKey.privateKey=await k().crypto.subtle.wrapKey("jwk",e.signingKey.privateKey,t.key,J),r.exchangeKey.publicKey=await k().crypto.subtle.wrapKey("jwk",e.exchangeKey.publicKey.key,t.key,J),r.signingKey.publicKey=await k().crypto.subtle.wrapKey("jwk",e.signingKey.publicKey.key,t.key,J)),await this.db.transaction(V.IDENTITY_STORAGE,"readwrite").objectStore(V.IDENTITY_STORAGE).put(r,V.IDENTITY)}async loadRemoteIdentity(e){const t=await this.db.transaction(V.REMOTE_STORAGE).objectStore(V.REMOTE_STORAGE).get(e);let r=null;if(t){const i=await this.loadWrapKey();i&&(t.exchangeKey=await k().crypto.subtle.unwrapKey("jwk",t.exchangeKey,i.key,J,$r,!0,[]),t.signingKey=await k().crypto.subtle.unwrapKey("jwk",t.signingKey,i.key,J,Fr,!0,["verify"])),r=await Dt.fromJSON(t)}return r}async saveRemoteIdentity(e,t){const r=await t.toJSON(),i=await this.loadWrapKey();i&&(r.exchangeKey=await k().crypto.subtle.wrapKey("jwk",r.exchangeKey,i.key,J),r.signingKey=await k().crypto.subtle.wrapKey("jwk",r.signingKey,i.key,J)),await this.db.transaction(V.REMOTE_STORAGE,"readwrite").objectStore(V.REMOTE_STORAGE).put(r,e)}async loadSession(e){const t=await this.db.transaction(V.SESSION_STORAGE).objectStore(V.SESSION_STORAGE).get(e);let r=null;if(t){const i=await this.loadIdentity();if(!i)throw new Error("Identity is empty");const s=await this.loadRemoteIdentity(e);if(!s)throw new Error("Remote identity is not found");r=await Kt.fromJSON(i,s,t)}return r}async saveSession(e,t){const r=await t.toJSON();await this.db.transaction(V.SESSION_STORAGE,"readwrite").objectStore(V.SESSION_STORAGE).put(r,e)}}V.STORAGE_NAME="webcrypto-remote",V.IDENTITY_STORAGE="identity",V.SESSION_STORAGE="sessions",V.REMOTE_STORAGE="remoteIdentity",V.WRAP_KEY="wkey",V.IDENTITY="identity";class va extends pi{constructor(){super(...arguments),this.remoteIdentities={},this.sessions={}}async loadIdentity(){return this.identity||null}async saveIdentity(e){this.identity=e}async loadRemoteIdentity(e){return this.remoteIdentities[e]||null}async saveRemoteIdentity(e,t){this.remoteIdentities[e]=t}async loadSession(e){return this.sessions[e]||null}async saveSession(e,t){this.sessions[e]=t}}return Ee.BrowserStorage=V,Ee.CertificateStorage=Qn,Ee.CryptoServerError=Xi,Ee.KeyStorage=es,Ee.MemoryStorage=va,Ee.RatchetStorage=pi,Ee.SocketCrypto=ts,Ee.SocketProvider=Rr,Ee.getEngine=k,Ee.setEngine=Is,Ee}({},protobuf,WebSocket);self.WebcryptoSocket=wa;
