var nc=function(he,an,cn){/*!
 * MIT License
 *
 * Copyright (c) 2017-2022 Peculiar Ventures, LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */const zs="[object ArrayBuffer]";class v{static isArrayBuffer(e){return Object.prototype.toString.call(e)===zs}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e).slice().buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=v.toUint8Array(e),i=v.toUint8Array(t);if(r.length!==i.byteLength)return!1;for(let s=0;s<r.length;s++)if(r[s]!==i[s])return!1;return!0}static concat(...e){if(Array.isArray(e[0])){const t=e[0];let r=0;for(const o of t)r+=o.byteLength;const i=new Uint8Array(r);let s=0;for(const o of t){const a=this.toUint8Array(o);i.set(a,s),s+=a.length}return e[1]?this.toView(i,e[1]):i.buffer}else return this.concat(e)}}class ln{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return r.buffer}static toString(e){const t=v.toUint8Array(e);let r="";for(let s=0;s<t.length;s++)r+=String.fromCharCode(t[s]);return decodeURIComponent(escape(r))}}class we{static toString(e,t=!1){const r=v.toArrayBuffer(e),i=new DataView(r);let s="";for(let o=0;o<r.byteLength;o+=2){const a=i.getUint16(o,t);s+=String.fromCharCode(a)}return s}static fromString(e,t=!1){const r=new ArrayBuffer(e.length*2),i=new DataView(r);for(let s=0;s<e.length;s++)i.setUint16(s*2,e.charCodeAt(s),t);return r}}class y{static isHex(e){return typeof e=="string"&&/^[a-z0-9]+$/i.test(e)}static isBase64(e){return typeof e=="string"&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}static isBase64Url(e){return typeof e=="string"&&/^[a-zA-Z0-9-_]+$/i.test(e)}static ToString(e,t="utf8"){const r=v.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return we.toString(r,!0);case"utf16":case"utf16be":return we.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return we.fromString(e,!0);case"utf16":case"utf16be":return we.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=v.toUint8Array(e);if(typeof btoa<"u"){const r=this.ToString(t,"binary");return btoa(r)}else return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!y.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!y.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=y.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return ln.fromString(e);case"utf16":case"utf16be":return we.fromString(e);case"utf16le":case"usc2":return we.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=y.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return ln.toString(e);case"utf16":case"utf16be":return we.toString(e);case"utf16le":case"usc2":return we.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.charCodeAt(i);return r.buffer}static ToBinary(e){const t=v.toUint8Array(e);let r="";for(let i=0;i<t.length;i++)r+=String.fromCharCode(t[i]);return r}static ToHex(e){const t=v.toUint8Array(e),r="",i=[],s=t.length;for(let o=0;o<s;o++){const a=t[o].toString(16).padStart(2,"0");i.push(a)}return i.join(r)}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!y.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let i=0;i<t.length;i=i+2){const s=t.slice(i,i+2);r[i/2]=parseInt(s,16)}return r.buffer}static ToUtf16String(e,t=!1){return we.toString(e,t)}static FromUtf16String(e,t=!1){return we.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(e==null?void 0:e.replace(/[\n\r\t ]/g,""))||""}}y.DEFAULT_UTF8_ENCODING="utf8";function ut(n,...e){const t=arguments[0];for(let r=1;r<arguments.length;r++){const i=arguments[r];for(const s in i)t[s]=i[s]}return t}function ht(...n){const e=n.map(i=>i.byteLength).reduce((i,s)=>i+s),t=new Uint8Array(e);let r=0;return n.map(i=>new Uint8Array(i)).forEach(i=>{for(const s of i)t[r++]=s}),t.buffer}function un(n,e){if(!(n&&e)||n.byteLength!==e.byteLength)return!1;const t=new Uint8Array(n),r=new Uint8Array(e);for(let i=0;i<n.byteLength;i++)if(t[i]!==r[i])return!1;return!0}function l(n,e,t,r){var i=arguments.length,s=i<3?e:r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,e,t,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(e,t,s):o(e,t))||s);return i>3&&s&&Object.defineProperty(e,t,s),s}class se{static async set(e){return new Uint8Array(e)}static async get(e){return new Uint8Array(e).buffer}}function g(n){return e=>{const t=e;t.localName=n.name||t.name||t.toString().match(/^function\s*([^\s(]+)/)[1],t.items=t.items||{},t.target=e,t.items=ut({},t.items);const r=new an.Type(t.localName);for(const i in t.items){const s=t.items[i];let o;s.repeated?o="repeated":s.required&&(o="required"),r.add(new an.Field(s.name,s.id,s.type,o))}t.protobuf=r}}function Ws(n,e,t){const r=`_${e}`,i={set:function(s){this[r]!==s&&(this.raw=null,this[r]=s)},get:function(){if(this[r]===void 0){let s=t.defaultValue;t.parser&&!t.repeated&&(s=new t.parser),this[r]=s}return this[r]},enumerable:!0};Object.defineProperty(n,r,{writable:!0,enumerable:!1}),Object.defineProperty(n,e,i)}function u(n){return(e,t)=>{const r=e.constructor,i=t;r.items=r.items||{},r.target!==r&&(r.items=ut({},r.items),r.target=r),r.items[i]={id:n.id,type:n.type||"bytes",defaultValue:n.defaultValue,converter:n.converter||null,parser:n.parser||null},n.name=n.name||i,r.items[i].name=n.name,r.items[i].required=n.required||!1,r.items[i].repeated=n.repeated||!1,Ws(e,i,r.items[i])}}class Nr{static async importProto(e){const t=new this;return await t.importProto(e),t}isEmpty(){return this.raw===void 0}hasChanged(){if(this.raw===null)return!0;const e=this.constructor,t=this;for(const r in e.items){const i=e.items[r];if(i.repeated){if(i.parser)return t[r].some(s=>s.hasChanged())}else if(i.parser&&t[r]&&t[r].hasChanged())return!0}return!1}async importProto(e){const t=this.constructor,r=this;let i,s;e instanceof Nr?s=await e.exportProto():s=e;try{i=t.protobuf.decode(new Uint8Array(s))}catch(o){throw new Error(`Error: Cannot decode message for ${t.localName}.
$ProtobufError: ${o.message}`)}for(const o in t.items){const a=t.items[o];let c=i[a.name];ArrayBuffer.isView(c)&&(c=new Uint8Array(c)),Array.isArray(c)||(a.repeated?r[o]=c=[]:c=[c]),a.repeated&&!r[o]&&(r[o]=[]);for(const h of c)a.repeated?r[o].push(await this.importItem(a,h)):r[o]=await this.importItem(a,h)}this.raw=s}async exportProto(){if(!this.hasChanged())return this.raw;const e=this.constructor,t=this,r={};for(const i in e.items){const s=e.items[i];let o=t[i];Array.isArray(o)||(o=o===void 0?[]:[o]);for(const a of o){const c=await this.exportItem(s,a);s.repeated?(r[s.name]||(r[s.name]=[]),r[s.name].push(c)):r[s.name]=c}}return this.raw=new Uint8Array(e.protobuf.encode(r).finish()).buffer,this.raw}async exportItem(e,t){const r=this.constructor;let i;if(e.parser){const o=await t.exportProto();if(e.required&&!o)throw new Error(`Error: Paramter '${e.name}' is required in '${r.localName}' protobuf message.`);o&&(i=new Uint8Array(o))}else{if(e.required&&t===void 0)throw new Error(`Error: Paramter '${e.name}' is required in '${r.localName}' protobuf message.`);e.converter?t!==void 0&&(i=await e.converter.set(t)):(t instanceof ArrayBuffer&&(t=new Uint8Array(t)),i=t)}return i}async importItem(e,t){const r=this.constructor;let i;if(e.parser){const s=e.parser;if(t&&t.byteLength)i=await s.importProto(new Uint8Array(t).buffer);else if(e.required)throw new Error(`Error: Parameter '${e.name}' is required in '${r.localName}' protobuf message.`)}else if(e.converter){if(t&&t.byteLength)i=await e.converter.get(t);else if(e.required)throw new Error(`Error: Parameter '${e.name}' is required in '${r.localName}' protobuf message.`)}else i=t;return i}}var Ys;function He(){}He.prototype=Object.create(null);function D(){D.init.call(this)}D.EventEmitter=D,D.usingDomains=!1,D.prototype.domain=void 0,D.prototype._events=void 0,D.prototype._maxListeners=void 0,D.defaultMaxListeners=10,D.init=function(){this.domain=null,D.usingDomains&&Ys.active,(!this._events||this._events===Object.getPrototypeOf(this)._events)&&(this._events=new He,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},D.prototype.setMaxListeners=function(e){if(typeof e!="number"||e<0||isNaN(e))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=e,this};function hn(n){return n._maxListeners===void 0?D.defaultMaxListeners:n._maxListeners}D.prototype.getMaxListeners=function(){return hn(this)};function Zs(n,e,t){if(e)n.call(t);else for(var r=n.length,i=Ht(n,r),s=0;s<r;++s)i[s].call(t)}function Qs(n,e,t,r){if(e)n.call(t,r);else for(var i=n.length,s=Ht(n,i),o=0;o<i;++o)s[o].call(t,r)}function eo(n,e,t,r,i){if(e)n.call(t,r,i);else for(var s=n.length,o=Ht(n,s),a=0;a<s;++a)o[a].call(t,r,i)}function to(n,e,t,r,i,s){if(e)n.call(t,r,i,s);else for(var o=n.length,a=Ht(n,o),c=0;c<o;++c)a[c].call(t,r,i,s)}function ro(n,e,t,r){if(e)n.apply(t,r);else for(var i=n.length,s=Ht(n,i),o=0;o<i;++o)s[o].apply(t,r)}D.prototype.emit=function(e){var t,r,i,s,o,a,c,h=e==="error";if(a=this._events,a)h=h&&a.error==null;else if(!h)return!1;if(c=this.domain,h){if(t=arguments[1],c)t||(t=new Error('Uncaught, unspecified "error" event')),t.domainEmitter=this,t.domain=c,t.domainThrown=!1,c.emit("error",t);else{if(t instanceof Error)throw t;var d=new Error('Uncaught, unspecified "error" event. ('+t+")");throw d.context=t,d}return!1}if(r=a[e],!r)return!1;var f=typeof r=="function";switch(i=arguments.length,i){case 1:Zs(r,f,this);break;case 2:Qs(r,f,this,arguments[1]);break;case 3:eo(r,f,this,arguments[1],arguments[2]);break;case 4:to(r,f,this,arguments[1],arguments[2],arguments[3]);break;default:for(s=new Array(i-1),o=1;o<i;o++)s[o-1]=arguments[o];ro(r,f,this,s)}return!0};function fn(n,e,t,r){var i,s,o;if(typeof t!="function")throw new TypeError('"listener" argument must be a function');if(s=n._events,s?(s.newListener&&(n.emit("newListener",e,t.listener?t.listener:t),s=n._events),o=s[e]):(s=n._events=new He,n._eventsCount=0),!o)o=s[e]=t,++n._eventsCount;else if(typeof o=="function"?o=s[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),!o.warned&&(i=hn(n),i&&i>0&&o.length>i)){o.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+e+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=n,a.type=e,a.count=o.length,io(a)}return n}function io(n){typeof console.warn=="function"?console.warn(n):console.log(n)}D.prototype.addListener=function(e,t){return fn(this,e,t,!1)},D.prototype.on=D.prototype.addListener,D.prototype.prependListener=function(e,t){return fn(this,e,t,!0)};function dn(n,e,t){var r=!1;function i(){n.removeListener(e,i),r||(r=!0,t.apply(n,arguments))}return i.listener=t,i}D.prototype.once=function(e,t){if(typeof t!="function")throw new TypeError('"listener" argument must be a function');return this.on(e,dn(this,e,t)),this},D.prototype.prependOnceListener=function(e,t){if(typeof t!="function")throw new TypeError('"listener" argument must be a function');return this.prependListener(e,dn(this,e,t)),this},D.prototype.removeListener=function(e,t){var r,i,s,o,a;if(typeof t!="function")throw new TypeError('"listener" argument must be a function');if(i=this._events,!i)return this;if(r=i[e],!r)return this;if(r===t||r.listener&&r.listener===t)--this._eventsCount===0?this._events=new He:(delete i[e],i.removeListener&&this.emit("removeListener",e,r.listener||t));else if(typeof r!="function"){for(s=-1,o=r.length;o-- >0;)if(r[o]===t||r[o].listener&&r[o].listener===t){a=r[o].listener,s=o;break}if(s<0)return this;if(r.length===1){if(r[0]=void 0,--this._eventsCount===0)return this._events=new He,this;delete i[e]}else no(r,s);i.removeListener&&this.emit("removeListener",e,a||t)}return this},D.prototype.removeAllListeners=function(e){var t,r;if(r=this._events,!r)return this;if(!r.removeListener)return arguments.length===0?(this._events=new He,this._eventsCount=0):r[e]&&(--this._eventsCount===0?this._events=new He:delete r[e]),this;if(arguments.length===0){for(var i=Object.keys(r),s=0,o;s<i.length;++s)o=i[s],o!=="removeListener"&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=new He,this._eventsCount=0,this}if(t=r[e],typeof t=="function")this.removeListener(e,t);else if(t)do this.removeListener(e,t[t.length-1]);while(t[0]);return this},D.prototype.listeners=function(e){var t,r,i=this._events;return i?(t=i[e],t?typeof t=="function"?r=[t.listener||t]:r=so(t):r=[]):r=[],r},D.listenerCount=function(n,e){return typeof n.listenerCount=="function"?n.listenerCount(e):yn.call(n,e)},D.prototype.listenerCount=yn;function yn(n){var e=this._events;if(e){var t=e[n];if(typeof t=="function")return 1;if(t)return t.length}return 0}D.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};function no(n,e){for(var t=e,r=t+1,i=n.length;r<i;t+=1,r+=1)n[t]=n[r];n.pop()}function Ht(n,e){for(var t=new Array(e);e--;)t[e]=n[e];return t}function so(n){for(var e=new Array(n.length),t=0;t<e.length;++t)e[t]=n[t].listener||n[t];return e}const oo="ECDSA",ao="ECDH",gn="AES-CBC",pn="SHA-256",mn="HMAC",vn=20,wn=y.FromBinary("InfoText"),co=y.FromBinary("InfoRatchet"),En=y.FromBinary("InfoMessageKeys");let kr=null;typeof self<"u"&&(kr={crypto:self.crypto,name:"WebCrypto"});function lo(n,e){kr={crypto:e,name:n}}function I(){if(!kr)throw new Error("WebCrypto engine is empty. Use setEngine to resolve it.");return kr}let S=(()=>{class n{static async generateKeyPair(t,r){const i=t,s=t==="ECDSA"?["sign","verify"]:["deriveKey","deriveBits"],o=await I().crypto.subtle.generateKey({name:i,namedCurve:this.NAMED_CURVE},r,s),a=await oe.create(o.publicKey);return{privateKey:o.privateKey,publicKey:a}}static deriveBytes(t,r){return I().crypto.subtle.deriveBits({name:"ECDH",public:r.key},t,256)}static verify(t,r,i){return I().crypto.subtle.verify({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t.key,i,r)}static async sign(t,r){return I().crypto.subtle.sign({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t,r)}static async ecKeyPairToJson(t){return{privateKey:t.privateKey,publicKey:t.publicKey.key,thumbprint:await t.publicKey.thumbprint()}}static async ecKeyPairFromJson(t){return{privateKey:t.privateKey,publicKey:await oe.create(t.publicKey)}}}return n.NAMED_CURVE="P-256",n.DIGEST_ALGORITHM="SHA-512",n})();const uo={name:"AES-CBC",length:256};class L{static randomBytes(e){const t=new Uint8Array(e);return I().crypto.getRandomValues(t),t.buffer}static digest(e,t){return I().crypto.subtle.digest(e,t)}static encrypt(e,t,r){return I().crypto.subtle.encrypt({name:gn,iv:new Uint8Array(r)},e,t)}static decrypt(e,t,r){return I().crypto.subtle.decrypt({name:gn,iv:new Uint8Array(r)},e,t)}static importHMAC(e){return I().crypto.subtle.importKey("raw",e,{name:mn,hash:{name:pn}},!1,["sign","verify"])}static importAES(e){return I().crypto.subtle.importKey("raw",e,uo,!1,["encrypt","decrypt"])}static async sign(e,t){return await I().crypto.subtle.sign({name:mn,hash:pn},e,t)}static async HKDF(e,t=1,r,i=new ArrayBuffer(0)){r||(r=await this.importHMAC(new Uint8Array(32).buffer));const s=await this.sign(r,e);new ArrayBuffer(32+i.byteLength+1);const o=await this.importHMAC(s),a=[new ArrayBuffer(0)];for(let c=0;c<t;c++)a[c+1]=await this.sign(o,ht(a[c],i,new Uint8Array([c+1]).buffer));return a.slice(1)}}class oe{static async create(e){const t=new this,r=e.algorithm.name.toUpperCase();if(!(r==="ECDH"||r==="ECDSA"))throw new Error("Error: Unsupported asymmetric key algorithm.");if(e.type!=="public")throw new Error("Error: Expected key type to be public but it was not.");t.key=e;const i=await I().crypto.subtle.exportKey("jwk",e);if(!(i.x&&i.y))throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const s=y.FromBase64Url(i.x),o=y.FromBase64Url(i.y),a=y.ToBinary(s)+y.ToBinary(o);return t.serialized=y.FromBinary(a),t.id=await t.thumbprint(),t}static async importKey(e,t){const r=y.ToBase64Url(e.slice(0,32)),i=y.ToBase64Url(e.slice(32)),s={crv:S.NAMED_CURVE,kty:"EC",x:r,y:i},o=t==="ECDSA"?["verify"]:[],a=await I().crypto.subtle.importKey("jwk",s,{name:t,namedCurve:S.NAMED_CURVE},!0,o);return await oe.create(a)}serialize(){return this.serialized}async thumbprint(){const e=await this.serialize(),t=await L.digest("SHA-256",e);return y.ToHex(t)}async isEqual(e){return e&&e instanceof oe?un(this.serialized,e.serialized):!1}}class Br{constructor(e,t,r){this.id=e,this.signingKey=t,this.exchangeKey=r,this.preKeys=[],this.signedPreKeys=[]}static async fromJSON(e){const t=await S.ecKeyPairFromJson(e.signingKey),r=await S.ecKeyPairFromJson(e.exchangeKey),i=new this(e.id,t,r);return i.createdAt=new Date(e.createdAt),await i.fromJSON(e),i}static async create(e,t=0,r=0,i=!1){const s=await S.generateKeyPair(oo,i),o=await S.generateKeyPair(ao,i),a=new Br(e,s,o);a.createdAt=new Date;for(let c=0;c<r;c++)a.preKeys.push(await S.generateKeyPair("ECDH",i));for(let c=0;c<t;c++)a.signedPreKeys.push(await S.generateKeyPair("ECDH",i));return a}async toJSON(){const e=[],t=[];for(const r of this.preKeys)e.push(await S.ecKeyPairToJson(r));for(const r of this.signedPreKeys)t.push(await S.ecKeyPairToJson(r));return{createdAt:this.createdAt.toISOString(),exchangeKey:await S.ecKeyPairToJson(this.exchangeKey),id:this.id,preKeys:e,signedPreKeys:t,signingKey:await S.ecKeyPairToJson(this.signingKey)}}async fromJSON(e){this.id=e.id,this.signingKey=await S.ecKeyPairFromJson(e.signingKey),this.exchangeKey=await S.ecKeyPairFromJson(e.exchangeKey),this.preKeys=[];for(const t of e.preKeys)this.preKeys.push(await S.ecKeyPairFromJson(t));this.signedPreKeys=[];for(const t of e.signedPreKeys)this.signedPreKeys.push(await S.ecKeyPairFromJson(t))}}class _t{static fill(e){const t=new _t;return t.fill(e),t}static async fromJSON(e){const t=new this;return await t.fromJSON(e),t}fill(e){this.signingKey=e.signingKey,this.exchangeKey=e.exchangeKey,this.signature=e.signature,this.createdAt=e.createdAt}verify(){return S.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async toJSON(){return{createdAt:this.createdAt.toISOString(),exchangeKey:await this.exchangeKey.key,id:this.id,signature:this.signature,signingKey:await this.signingKey.key,thumbprint:await this.signingKey.thumbprint()}}async fromJSON(e){if(this.id=e.id,this.signature=e.signature,this.signingKey=await oe.create(e.signingKey),this.exchangeKey=await oe.create(e.exchangeKey),this.createdAt=new Date(e.createdAt),!await this.verify())throw new Error("Error: Wrong signature for RemoteIdentity")}}let ft=(()=>{let n=class extends Nr{};return l([u({id:0,type:"uint32",defaultValue:1})],n.prototype,"version",void 0),n=l([g({name:"Base"})],n),n})();class An{static async set(e){return new Uint8Array(e.serialize())}static async get(e){return oe.importKey(e.buffer,"ECDSA")}}class Sr{static async set(e){return new Uint8Array(e.serialize())}static async get(e){return oe.importKey(e.buffer,"ECDH")}}let ho=class{static async set(e){return new Uint8Array(y.FromString(e.toISOString()))}static async get(e){return new Date(y.ToString(e))}},bn=(()=>{var n;let e=n=class extends ft{static async fill(r){const i=new n;return await i.fill(r),i}async sign(r){this.signature=await S.sign(r,this.exchangeKey.serialize())}async verify(){return await S.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async fill(r){this.signingKey=r.signingKey.publicKey,this.exchangeKey=r.exchangeKey.publicKey,this.createdAt=r.createdAt,await this.sign(r.signingKey.privateKey)}};return l([u({id:1,converter:An})],e.prototype,"signingKey",void 0),l([u({id:2,converter:Sr})],e.prototype,"exchangeKey",void 0),l([u({id:3})],e.prototype,"signature",void 0),l([u({id:4,converter:ho})],e.prototype,"createdAt",void 0),e=n=l([g({name:"Identity"})],e),e})(),fo=(()=>{let n=class extends ft{};return l([u({id:1,converter:Sr,required:!0})],n.prototype,"senderRatchetKey",void 0),l([u({id:2,type:"uint32",required:!0})],n.prototype,"counter",void 0),l([u({id:3,type:"uint32",required:!0})],n.prototype,"previousCounter",void 0),l([u({id:4,converter:se,required:!0})],n.prototype,"cipherText",void 0),n=l([g({name:"Message"})],n),n})(),yi=(()=>{let n=class extends ft{async sign(t){this.signature=await this.signHMAC(t)}async verify(t){const r=await this.signHMAC(t);return un(r,this.signature)}async getSignedRaw(){const t=this.receiverKey.serialize(),r=this.senderKey.serialize(),i=await this.message.exportProto();return ht(t,r,i)}async signHMAC(t){const r=await this.getSignedRaw();return await L.sign(t,r)}};return l([u({id:1,converter:An,required:!0})],n.prototype,"senderKey",void 0),l([u({id:2,parser:fo,required:!0})],n.prototype,"message",void 0),l([u({id:3,required:!0})],n.prototype,"signature",void 0),n=l([g({name:"MessageSigned"})],n),n})(),yo=(()=>{let n=class extends ft{};return l([u({id:1,type:"uint32",required:!0})],n.prototype,"registrationId",void 0),l([u({id:2,type:"uint32"})],n.prototype,"preKeyId",void 0),l([u({id:3,type:"uint32",required:!0})],n.prototype,"preKeySignedId",void 0),l([u({id:4,converter:Sr,required:!0})],n.prototype,"baseKey",void 0),l([u({id:5,parser:bn,required:!0})],n.prototype,"identity",void 0),l([u({id:6,parser:yi,required:!0})],n.prototype,"signedMessage",void 0),n=l([g({name:"PreKeyMessage"})],n),n})(),In=(()=>{let n=class extends ft{};return l([u({id:1,type:"uint32",required:!0})],n.prototype,"id",void 0),l([u({id:2,converter:Sr,required:!0})],n.prototype,"key",void 0),n=l([g({name:"PreKey"})],n),n})(),go=(()=>{let n=class extends In{async sign(t){this.signature=await S.sign(t,this.key.serialize())}verify(t){return S.verify(t,this.key.serialize(),this.signature)}};return l([u({id:3,converter:se,required:!0})],n.prototype,"signature",void 0),n=l([g({name:"PreKeySigned"})],n),n})(),Nn=(()=>{let n=class extends ft{};return l([u({id:1,type:"uint32",required:!0})],n.prototype,"registrationId",void 0),l([u({id:2,parser:bn,required:!0})],n.prototype,"identity",void 0),l([u({id:3,parser:In})],n.prototype,"preKey",void 0),l([u({id:4,parser:go,required:!0})],n.prototype,"preKeySigned",void 0),n=l([g({name:"PreKeyBundle"})],n),n})();class po{constructor(e=20){this.items=[],this.maxSize=e}get length(){return this.items.length}get latest(){return this.items[this.length-1]}push(e){this.length===this.maxSize&&(this.items=this.items.slice(1)),this.items.push(e)}async toJSON(){const e=[];for(const t of this.items)e.push(await t.toJSON());return e}async fromJSON(e){this.items=e}}const mo=new Uint8Array([1]).buffer,vo=new Uint8Array([2]).buffer;class kn{constructor(e){this.counter=0,this.rootKey=e}static async fromJSON(e){const t=new this(e.rootKey);return t.fromJSON(e),t}async toJSON(){return{counter:this.counter,rootKey:this.rootKey}}async fromJSON(e){this.counter=e.counter,this.rootKey=e.rootKey}async calculateKey(e){const t=await L.sign(e,mo),r=await L.sign(e,vo);return{cipher:t,rootKey:await L.importHMAC(r)}}async click(){const e=this.rootKey,t=await this.calculateKey(e);return this.rootKey=t.rootKey,this.counter++,t.cipher}}class Bn extends kn{async encrypt(e){const t=await this.click(),r=await L.HKDF(t,3,void 0,En),i=await L.importAES(r[0]),s=await L.importHMAC(r[1]),o=r[2].slice(0,16);return{cipherText:await L.encrypt(i,e,o),hmacKey:s}}}class Sn extends kn{constructor(){super(...arguments),this.keys=[]}async toJSON(){const e=await super.toJSON();return e.keys=this.keys,e}async fromJSON(e){await super.fromJSON(e),this.keys=e.keys}async decrypt(e,t){const r=await this.getKey(t),i=await L.HKDF(r,3,void 0,En),s=await L.importAES(i[0]),o=await L.importHMAC(i[1]),a=i[2].slice(0,16);return{cipherText:await L.decrypt(s,e,a),hmacKey:o}}async getKey(e){for(;this.counter<=e;){const r=await this.click();this.keys.push(r)}return this.keys[e]}}async function wo(n,e,t,r,i){const s=await S.deriveBytes(n.exchangeKey.privateKey,r),o=await S.deriveBytes(e.privateKey,t),a=await S.deriveBytes(e.privateKey,r);let c=new ArrayBuffer(0);i&&(c=await S.deriveBytes(e.privateKey,i));const h=new Uint8Array(32);for(let B=0;B<h.length;B++)h[B]=255;const d=h.buffer,f=ht(d,s,o,a,c),b=await L.HKDF(f,1,void 0,wn);return await L.importHMAC(b[0])}async function Eo(n,e,t,r,i){const s=await S.deriveBytes(e.privateKey,t),o=await S.deriveBytes(n.exchangeKey.privateKey,r),a=await S.deriveBytes(e.privateKey,r);let c=new ArrayBuffer(0);i&&(c=await S.deriveBytes(i,r));const h=new Uint8Array(32);for(let B=0;B<h.length;B++)h[B]=255;const d=h.buffer,f=ht(d,s,o,a,c),b=await L.HKDF(f,1,void 0,wn);return await L.importHMAC(b[0])}class Mt extends D{constructor(e={}){super(),this.options=e,this.counter=0,this.currentStep=new gi,this.steps=new Ao(vn),this.promises={}}static async create(e,t,r={}){let i;const s=new Mt(r);if(t instanceof Nn){if(!await t.identity.verify())throw new Error("Error: Remote client's identity key is invalid.");if(!await t.preKeySigned.verify(t.identity.signingKey))throw new Error("Error: Remote client's signed prekey is invalid.");s.currentRatchetKey=await s.generateRatchetKey(),s.currentStep.remoteRatchetKey=t.preKeySigned.key,s.remoteIdentity=_t.fill(t.identity),s.remoteIdentity.id=t.registrationId,s.remotePreKeyId=t.preKey.id,s.remotePreKeySignedId=t.preKeySigned.id,i=await wo(e,s.currentRatchetKey,t.identity.exchangeKey,t.preKeySigned.key,t.preKey.key)}else{if(!await t.identity.verify())throw new Error("Error: Remote client's identity key is invalid.");const o=e.signedPreKeys[t.preKeySignedId];if(!o)throw new Error(`Error: PreKey with id ${t.preKeySignedId} not found`);let a;t.preKeyId!==void 0&&(a=e.preKeys[t.preKeyId]),s.remoteIdentity=_t.fill(t.identity),s.currentRatchetKey=o,i=await Eo(e,s.currentRatchetKey,t.identity.exchangeKey,t.signedMessage.message.senderRatchetKey,a&&a.privateKey)}return s.identity=e,s.id=e.id,s.rootKey=i,s}static async fromJSON(e,t,r){const i=new Mt;return i.identity=e,i.remoteIdentity=t,await i.fromJSON(r),i}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async decrypt(e){return this.queuePromise("encrypt",async()=>{const t=e.message.senderRatchetKey,r=e.message;if(e.message.previousCounter<this.counter-vn)throw new Error("Error: Too old message");let i=this.steps.getStep(t);if(!i){const o=new gi;o.remoteRatchetKey=t,this.steps.push(o),this.currentStep=o,i=o}i.receivingChain||(i.receivingChain=await this.createChain(this.currentRatchetKey.privateKey,t,Sn));const s=await i.receivingChain.decrypt(r.cipherText,r.counter);if(this.update(),e.senderKey=this.remoteIdentity.signingKey,e.receiverKey=this.identity.signingKey.publicKey,!await e.verify(s.hmacKey))throw new Error("Error: The Message did not successfully verify!");return s.cipherText})}async encrypt(e){return this.queuePromise("encrypt",async()=>{if(this.currentStep.receivingChain&&!this.currentStep.sendingChain&&(this.counter++,this.currentRatchetKey=await this.generateRatchetKey()),!this.currentStep.sendingChain){if(!this.currentStep.remoteRatchetKey)throw new Error("currentStep has empty remoteRatchetKey");this.currentStep.sendingChain=await this.createChain(this.currentRatchetKey.privateKey,this.currentStep.remoteRatchetKey,Bn)}const t=await this.currentStep.sendingChain.encrypt(e);this.update();let r;this.steps.length===0&&!this.currentStep.receivingChain&&this.currentStep.sendingChain.counter===1&&(r=new yo,r.registrationId=this.identity.id,r.preKeyId=this.remotePreKeyId,r.preKeySignedId=this.remotePreKeySignedId,r.baseKey=this.currentRatchetKey.publicKey,await r.identity.fill(this.identity));const i=new yi;return i.receiverKey=this.remoteIdentity.signingKey,i.senderKey=this.identity.signingKey.publicKey,i.message.cipherText=t.cipherText,i.message.counter=this.currentStep.sendingChain.counter-1,i.message.previousCounter=this.counter,i.message.senderRatchetKey=this.currentRatchetKey.publicKey,await i.sign(t.hmacKey),r?(r.signedMessage=i,r):i})}async hasRatchetKey(e){let t;e instanceof oe?t=e:t=await oe.create(e);for(const r of this.steps.items)if(await r.remoteRatchetKey.isEqual(t))return!0;return!1}async toJSON(){return{counter:this.counter,ratchetKey:await S.ecKeyPairToJson(this.currentRatchetKey),remoteIdentity:await this.remoteIdentity.signingKey.thumbprint(),rootKey:this.rootKey,steps:await this.steps.toJSON()}}async fromJSON(e){this.currentRatchetKey=await S.ecKeyPairFromJson(e.ratchetKey),this.counter=e.counter,this.rootKey=e.rootKey;for(const t of e.steps)this.currentStep=await gi.fromJSON(t),this.steps.push(this.currentStep)}update(){this.emit("update")}generateRatchetKey(){return S.generateKeyPair("ECDH",!!this.options.exportableKeys)}async createChain(e,t,r){const i=await S.deriveBytes(e,t),s=await L.HKDF(i,2,this.rootKey,co),o=await L.importHMAC(s[0]),a=await L.importHMAC(s[1]),c=new r(a);return this.rootKey=o,c}queuePromise(e,t){const r=this.promises[e]||Promise.resolve(),i=this.promises[e]=r.then(t,t);return i.then(()=>{this.promises[e]===i&&delete this.promises[e]}),i}}class gi{static async fromJSON(e){const t=new this;return await t.fromJSON(e),t}async toJSON(){const e={};return this.remoteRatchetKey&&(e.remoteRatchetKey=this.remoteRatchetKey.key),this.sendingChain&&(e.sendingChain=await this.sendingChain.toJSON()),this.receivingChain&&(e.receivingChain=await this.receivingChain.toJSON()),e}async fromJSON(e){e.remoteRatchetKey&&(this.remoteRatchetKey=await oe.create(e.remoteRatchetKey)),e.sendingChain&&(this.sendingChain=await Bn.fromJSON(e.sendingChain)),e.receivingChain&&(this.receivingChain=await Sn.fromJSON(e.receivingChain))}}class Ao extends po{getStep(e){let t;return this.items.some(r=>(r.remoteRatchetKey.id===e.id&&(t=r),!!t)),t}}class xn{static async set(e){return new Uint8Array(y.FromUtf8String(e.toISOString()))}static async get(e){return new Date(y.ToUtf8String(e))}}class xr{static async set(e){return new Uint8Array(y.FromHex(e))}static async get(e){return y.ToHex(e)}}class Cr{static async set(e){return new Uint8Array(y.FromUtf8String(e.toString(10)))}static async get(e){return parseInt(y.ToUtf8String(e),10)}}var pi,Dr,mi,J,qt,$t,Kr,ze,Ft;let T=pi=class extends Nr{constructor(){super(...arguments),this.version=0}};T.INDEX=1,l([u({id:pi.INDEX++,type:"uint32",required:!0,defaultValue:1})],T.prototype,"version",void 0),T=pi=l([g({name:"BaseMessage"})],T);let K=Dr=class extends T{constructor(){super(),this.actionId="",this.action=this.constructor.ACTION}};K.INDEX=T.INDEX,K.ACTION="action",l([u({id:Dr.INDEX++,type:"string",required:!0})],K.prototype,"action",void 0),l([u({id:Dr.INDEX++,type:"string",required:!1})],K.prototype,"actionId",void 0),K=Dr=l([g({name:"Action"})],K);let Ce=mi=class extends T{constructor(){super(...arguments),this.name=""}isEmpty(){return!this.name}toAlgorithm(){return{name:this.name}}fromAlgorithm(e){this.name=e.name}};Ce.INDEX=T.INDEX,l([u({id:mi.INDEX++,type:"string",required:!0})],Ce.prototype,"name",void 0),Ce=mi=l([g({name:"BaseAlgorithm"})],Ce);let A=J=class extends Ce{toAlgorithm(){const e={},t=this.constructor;for(const r in t.items){if(r==="version")continue;const i=this[r];if(r==="labelStr"){e.label=i;continue}i!==void 0&&(i instanceof Ce?i.isEmpty()||(e[r]=i.toAlgorithm()):e[r]=i)}return e}fromAlgorithm(e){e instanceof J&&(e=e.toAlgorithm());const t=this.constructor;for(const r in e)if(t.items&&r in t.items){const i=t.items[r];if(i.parser)switch(i.parser){case Ce:{this[r].fromAlgorithm(e[r]);break}default:throw new Error(`Unsupported parser '${i.parser.name}'`)}else r==="label"&&typeof e.label=="string"?this.labelStr=e.label:this[r]=e[r]}}};A.INDEX=Ce.INDEX,l([u({id:J.INDEX++,type:"bytes",parser:Ce})],A.prototype,"hash",void 0),l([u({id:J.INDEX++,type:"bytes"})],A.prototype,"publicExponent",void 0),l([u({id:J.INDEX++,type:"uint32"})],A.prototype,"modulusLength",void 0),l([u({id:J.INDEX++,type:"uint32"})],A.prototype,"saltLength",void 0),l([u({id:J.INDEX++,type:"bytes"})],A.prototype,"label",void 0),l([u({id:J.INDEX++,type:"string"})],A.prototype,"namedCurve",void 0),l([u({id:J.INDEX++,converter:se})],A.prototype,"public",void 0),l([u({id:J.INDEX++,type:"uint32"})],A.prototype,"length",void 0),l([u({id:J.INDEX++})],A.prototype,"iv",void 0),l([u({id:J.INDEX++,type:"bool"})],A.prototype,"token",void 0),l([u({id:J.INDEX++,type:"bool"})],A.prototype,"sensitive",void 0),l([u({id:J.INDEX++,type:"string"})],A.prototype,"labelStr",void 0),A=J=l([g({name:"Algorithm"})],A);let Ee=qt=class extends T{constructor(){super(...arguments),this.providerID="",this.id="",this.type=""}};Ee.INDEX=T.INDEX,l([u({id:qt.INDEX++,type:"string",required:!0})],Ee.prototype,"providerID",void 0),l([u({id:qt.INDEX++,type:"bytes",required:!0,converter:xr})],Ee.prototype,"id",void 0),l([u({id:qt.INDEX++,type:"string",required:!0})],Ee.prototype,"type",void 0),Ee=qt=l([g({name:"CryptoItem"})],Ee);class bo{static async set(e){const t=new A;t.fromAlgorithm(e);const r=await t.exportProto();return new Uint8Array(r)}static async get(e){const t=new A;return await t.importProto(e),t.toAlgorithm()}}let N=$t=class extends Ee{constructor(){super(...arguments),this.type="secret",this.algorithm={name:""},this.extractable=!1,this.usages=[]}};N.INDEX=Ee.INDEX,l([u({id:$t.INDEX++,type:"bytes",required:!0,converter:bo})],N.prototype,"algorithm",void 0),l([u({id:$t.INDEX++,type:"bool"})],N.prototype,"extractable",void 0),l([u({id:$t.INDEX++,type:"string",repeated:!0})],N.prototype,"usages",void 0),N=$t=l([g({name:"CryptoKey"})],N);let dt=Kr=class extends T{constructor(){super(...arguments),this.privateKey=new N,this.publicKey=new N}};dt.INDEX=T.INDEX,l([u({id:Kr.INDEX++,name:"privateKey",type:"bytes",required:!0,parser:N})],dt.prototype,"privateKey",void 0),l([u({id:Kr.INDEX++,name:"publicKey",type:"bytes",parser:N})],dt.prototype,"publicKey",void 0),dt=Kr=l([g({name:"CryptoKeyPair"})],dt);let Ae=ze=class extends T{constructor(e,t=0,r="error"){super(),this.code=0,this.type="error",this.message="",this.name="Error",this.stack="",e&&(this.message=e,this.code=t,this.type=r)}};Ae.INDEX=T.INDEX,l([u({id:ze.INDEX++,type:"uint32",defaultValue:0})],Ae.prototype,"code",void 0),l([u({id:ze.INDEX++,type:"string",defaultValue:"error"})],Ae.prototype,"type",void 0),l([u({id:ze.INDEX++,type:"string",defaultValue:""})],Ae.prototype,"message",void 0),l([u({id:ze.INDEX++,type:"string",defaultValue:"Error"})],Ae.prototype,"name",void 0),l([u({id:ze.INDEX++,type:"string",defaultValue:""})],Ae.prototype,"stack",void 0),Ae=ze=l([g({name:"Error"})],Ae);let We=Ft=class extends K{constructor(e){super(),this.status=!1,e&&(this.actionId=e.actionId,this.action=e.action)}};We.INDEX=K.INDEX,l([u({id:Ft.INDEX++,type:"bool",defaultValue:!1})],We.prototype,"status",void 0),l([u({id:Ft.INDEX++,type:"bytes",parser:Ae})],We.prototype,"error",void 0),l([u({id:Ft.INDEX++,type:"bytes",converter:se})],We.prototype,"data",void 0),We=Ft=l([g({name:"Result"})],We);let Pr=class extends K{};Pr.INDEX=K.INDEX,Pr.ACTION="auth",Pr=l([g({name:"AuthRequest"})],Pr);let Jt=class extends K{};Jt.INDEX=K.INDEX,Jt.ACTION="server/login",Jt=l([g({})],Jt);let Gt=class extends K{};Gt.INDEX=K.INDEX,Gt.ACTION="server/isLoggedIn",Gt=l([g({})],Gt);var Or;let yt=class extends K{};yt.INDEX=K.INDEX,yt.ACTION="cardReader",yt=l([g({})],yt);let jt=class extends K{};jt.INDEX=K.INDEX,jt.ACTION="cardReader/readers",jt=l([g({})],jt);let fe=Or=class extends yt{constructor(e,t){super(),this.reader="",this.atr="",e&&t&&(this.reader=e,this.atr=t)}};fe.INDEX=yt.INDEX,l([u({id:Or.INDEX++,required:!0,type:"string",defaultValue:""})],fe.prototype,"reader",void 0),l([u({id:Or.INDEX++,required:!0,converter:xr})],fe.prototype,"atr",void 0),fe=Or=l([g({})],fe);let gt=class extends fe{};gt.INDEX=fe.INDEX,gt.ACTION=fe.ACTION+"/insert",gt=l([g({})],gt);let pt=class extends fe{};pt.INDEX=fe.INDEX,pt.ACTION=fe.ACTION+"/remove",pt=l([g({})],pt);var vi;let m=vi=class extends K{constructor(){super(...arguments),this.providerID=""}};m.INDEX=K.INDEX,m.ACTION="crypto",l([u({id:vi.INDEX++,required:!0,type:"string"})],m.prototype,"providerID",void 0),m=vi=l([g({})],m);let zt=class extends m{};zt.INDEX=m.INDEX,zt.ACTION="crypto/login",zt=l([g({})],zt);let Wt=class extends m{};Wt.INDEX=m.INDEX,Wt.ACTION="crypto/logout",Wt=l([g({})],Wt);let Yt=class extends m{};Yt.INDEX=m.INDEX,Yt.ACTION="crypto/isLoggedIn",Yt=l([g({})],Yt);let Zt=class extends m{};Zt.INDEX=m.INDEX,Zt.ACTION="crypto/reset",Zt=l([g({})],Zt);var _e,Ye,wi,Tr,Ei,Ai,Qt,bi,Ii,mt,Ur,Ni,ki,Bi,er;let V=_e=class extends Ee{constructor(){super(...arguments),this.id="",this.publicKey=new N,this.type="x509",this.label="",this.token=!1,this.sensitive=!1}};V.INDEX=Ee.INDEX,l([u({id:_e.INDEX++,required:!0,converter:xr})],V.prototype,"id",void 0),l([u({id:_e.INDEX++,required:!0,parser:N})],V.prototype,"publicKey",void 0),l([u({id:_e.INDEX++,required:!0,type:"string"})],V.prototype,"type",void 0),l([u({id:_e.INDEX++,type:"string",defaultValue:""})],V.prototype,"label",void 0),l([u({id:_e.INDEX++,type:"bool",defaultValue:!1})],V.prototype,"token",void 0),l([u({id:_e.INDEX++,type:"bool",defaultValue:!1})],V.prototype,"sensitive",void 0),V=_e=l([g({})],V);let be=Ye=class extends V{constructor(){super(...arguments),this.type="x509",this.serialNumber="",this.issuerName="",this.subjectName="",this.notBefore=new Date,this.notAfter=new Date}};be.INDEX=V.INDEX,l([u({id:Ye.INDEX++,required:!0,converter:xr})],be.prototype,"serialNumber",void 0),l([u({id:Ye.INDEX++,required:!0,type:"string"})],be.prototype,"issuerName",void 0),l([u({id:Ye.INDEX++,required:!0,type:"string"})],be.prototype,"subjectName",void 0),l([u({id:Ye.INDEX++,required:!0,converter:xn})],be.prototype,"notBefore",void 0),l([u({id:Ye.INDEX++,required:!0,converter:xn})],be.prototype,"notAfter",void 0),be=Ye=l([g({})],be);let vt=wi=class extends V{constructor(){super(...arguments),this.type="request",this.subjectName=""}};vt.INDEX=V.INDEX,l([u({id:wi.INDEX++,required:!0,type:"string"})],vt.prototype,"subjectName",void 0),vt=wi=l([g({})],vt);let wt=Tr=class extends T{constructor(){super(...arguments),this.type="",this.value=new ArrayBuffer(0)}};wt.INDEX=T.INDEX,l([u({id:Tr.INDEX++,required:!0,type:"string"})],wt.prototype,"type",void 0),l([u({id:Tr.INDEX++,required:!0,converter:se})],wt.prototype,"value",void 0),wt=Tr=l([g({})],wt);let tr=Ei=class extends T{constructor(){super(...arguments),this.items=[]}};tr.INDEX=T.INDEX,l([u({id:Ei.INDEX++,required:!0,repeated:!0,parser:wt})],tr.prototype,"items",void 0),tr=Ei=l([g({})],tr);let Ze=Ai=class extends m{constructor(){super(...arguments),this.item=new V}};Ze.INDEX=m.INDEX,Ze.ACTION="crypto/certificateStorage/setItem",l([u({id:Ai.INDEX++,required:!0,parser:V})],Ze.prototype,"item",void 0),Ze=Ai=l([g({})],Ze);let Me=Qt=class extends m{constructor(){super(...arguments),this.key="",this.algorithm=new A,this.keyUsages=[]}};Me.INDEX=m.INDEX,Me.ACTION="crypto/certificateStorage/getItem",l([u({id:Qt.INDEX++,required:!0,type:"string"})],Me.prototype,"key",void 0),l([u({id:Qt.INDEX++,parser:A})],Me.prototype,"algorithm",void 0),l([u({id:Qt.INDEX++,repeated:!0,type:"string"})],Me.prototype,"keyUsages",void 0),Me=Qt=l([g({})],Me);let rr=class extends m{};rr.INDEX=m.INDEX,rr.ACTION="crypto/certificateStorage/keys",rr=l([g({})],rr);let Et=bi=class extends m{constructor(){super(...arguments),this.key=""}};Et.INDEX=m.INDEX,Et.ACTION="crypto/certificateStorage/getValue",l([u({id:bi.INDEX++,required:!0,type:"string"})],Et.prototype,"key",void 0),Et=bi=l([g({})],Et);let At=Ii=class extends m{constructor(){super(...arguments),this.key=""}};At.INDEX=m.INDEX,At.ACTION="crypto/certificateStorage/removeItem",l([u({id:Ii.INDEX++,required:!0,type:"string"})],At.prototype,"key",void 0),At=Ii=l([g({})],At);let ir=class extends m{};ir.INDEX=m.INDEX,ir.ACTION="crypto/certificateStorage/clear",ir=l([g({})],ir);let De=mt=class extends m{constructor(){super(...arguments),this.format="raw",this.data=new ArrayBuffer(0),this.algorithm=new A,this.keyUsages=[]}};De.INDEX=m.INDEX,De.ACTION="crypto/certificateStorage/import",l([u({id:mt.INDEX++,required:!0,type:"string"})],De.prototype,"format",void 0),l([u({id:mt.INDEX++,required:!0,converter:se})],De.prototype,"data",void 0),l([u({id:mt.INDEX++,required:!0,parser:A})],De.prototype,"algorithm",void 0),l([u({id:mt.INDEX++,repeated:!0,type:"string"})],De.prototype,"keyUsages",void 0),De=mt=l([g({})],De);let Qe=Ur=class extends m{constructor(){super(...arguments),this.format="raw",this.item=new V}};Qe.INDEX=m.INDEX,Qe.ACTION="crypto/certificateStorage/export",l([u({id:Ur.INDEX++,required:!0,type:"string"})],Qe.prototype,"format",void 0),l([u({id:Ur.INDEX++,required:!0,parser:V})],Qe.prototype,"item",void 0),Qe=Ur=l([g({})],Qe);let bt=Ni=class extends m{constructor(){super(...arguments),this.item=new V}};bt.INDEX=m.INDEX,bt.ACTION="crypto/certificateStorage/indexOf",l([u({id:Ni.INDEX++,required:!0,parser:V})],bt.prototype,"item",void 0),bt=Ni=l([g({})],bt);let It=class extends m{constructor(){super(...arguments),this.item=new V}};It.INDEX=m.INDEX,It.ACTION="crypto/certificateStorage/getChain",l([u({id:Ze.INDEX++,required:!0,parser:V})],It.prototype,"item",void 0),It=l([g({})],It);let Nt=ki=class extends m{constructor(){super(...arguments),this.url=""}};Nt.INDEX=m.INDEX,Nt.ACTION="crypto/certificateStorage/getCRL",l([u({id:ki.INDEX++,required:!0,type:"string"})],Nt.prototype,"url",void 0),Nt=ki=l([g({})],Nt);let kt=Bi=class extends T{constructor(){super(...arguments),this.method="get"}};kt.INDEX=T.INDEX,l([u({id:Bi.INDEX++,required:!1,type:"string",defaultValue:"get"})],kt.prototype,"method",void 0),kt=Bi=l([g({})],kt);let qe=er=class extends m{constructor(){super(...arguments),this.url="",this.request=new ArrayBuffer(0),this.options=new kt}};qe.INDEX=m.INDEX,qe.ACTION="crypto/certificateStorage/getOCSP",l([u({id:er.INDEX++,required:!0,type:"string"})],qe.prototype,"url",void 0),l([u({id:er.INDEX++,required:!0,converter:se})],qe.prototype,"request",void 0),l([u({id:er.INDEX++,required:!1,parser:kt})],qe.prototype,"options",void 0),qe=er=l([g({})],qe);var Si,Bt,xi,Ci;let St=Si=class extends m{constructor(){super(...arguments),this.item=new N}};St.INDEX=m.INDEX,St.ACTION="crypto/keyStorage/setItem",l([u({id:Si.INDEX++,required:!0,parser:N})],St.prototype,"item",void 0),St=Si=l([g({})],St);let Ke=Bt=class extends m{constructor(){super(...arguments),this.key="",this.algorithm=new A,this.extractable=!1,this.keyUsages=[]}};Ke.INDEX=m.INDEX,Ke.ACTION="crypto/keyStorage/getItem",l([u({id:Bt.INDEX++,required:!0,type:"string"})],Ke.prototype,"key",void 0),l([u({id:Bt.INDEX++,parser:A})],Ke.prototype,"algorithm",void 0),l([u({id:Bt.INDEX++,type:"bool"})],Ke.prototype,"extractable",void 0),l([u({id:Bt.INDEX++,repeated:!0,type:"string"})],Ke.prototype,"keyUsages",void 0),Ke=Bt=l([g({})],Ke);let nr=class extends m{};nr.INDEX=m.INDEX,nr.ACTION="crypto/keyStorage/keys",nr=l([g({})],nr);let xt=xi=class extends m{constructor(){super(...arguments),this.key=""}};xt.INDEX=m.INDEX,xt.ACTION="crypto/keyStorage/removeItem",l([u({id:xi.INDEX++,required:!0,type:"string"})],xt.prototype,"key",void 0),xt=xi=l([g({})],xt);let sr=class extends m{};sr.INDEX=m.INDEX,sr.ACTION="crypto/keyStorage/clear",sr=l([g({})],sr);let Ct=Ci=class extends m{constructor(){super(...arguments),this.item=new N}};Ct.INDEX=m.INDEX,Ct.ACTION="crypto/keyStorage/indexOf",l([u({id:Ci.INDEX++,required:!0,parser:N})],Ct.prototype,"item",void 0),Ct=Ci=l([g({})],Ct);var Vr,M,de,Rr,Di,or;let ye=Vr=class extends T{constructor(e){super(),this.major=0,this.minor=0,e&&ut(this,e)}};ye.INDEX=T.INDEX,l([u({id:Vr.INDEX++,required:!0,type:"uint32"})],ye.prototype,"major",void 0),l([u({id:Vr.INDEX++,required:!0,type:"uint32"})],ye.prototype,"minor",void 0),ye=Vr=l([g({})],ye);let R=M=class extends T{constructor(e){super(),this.label="",this.manufacturerID="",this.model="",this.serialNumber="",this.flags=0,this.hardwareVersion=new ye,this.firmwareVersion=new ye,this.maxSessionCount=0,this.sessionCount=0,this.maxRwSessionCount=0,this.rwSessionCount=0,this.maxPinLen=0,this.minPinLen=0,this.totalPublicMemory=0,this.freePublicMemory=0,this.totalPrivateMemory=0,this.freePrivateMemory=0,e&&(ut(this,e),this.firmwareVersion=new ye(e.firmwareVersion),this.hardwareVersion=new ye(e.hardwareVersion))}};R.INDEX=T.INDEX,l([u({id:M.INDEX++,required:!0,type:"string"})],R.prototype,"label",void 0),l([u({id:M.INDEX++,required:!0,type:"string"})],R.prototype,"manufacturerID",void 0),l([u({id:M.INDEX++,required:!0,type:"string"})],R.prototype,"model",void 0),l([u({id:M.INDEX++,required:!0,type:"string"})],R.prototype,"serialNumber",void 0),l([u({id:M.INDEX++,required:!0,type:"uint32"})],R.prototype,"flags",void 0),l([u({id:M.INDEX++,required:!0,parser:ye})],R.prototype,"hardwareVersion",void 0),l([u({id:M.INDEX++,required:!0,parser:ye})],R.prototype,"firmwareVersion",void 0),l([u({id:M.INDEX++,required:!0,type:"uint32"})],R.prototype,"maxSessionCount",void 0),l([u({id:M.INDEX++,required:!0,type:"uint32"})],R.prototype,"sessionCount",void 0),l([u({id:M.INDEX++,required:!0,type:"uint32"})],R.prototype,"maxRwSessionCount",void 0),l([u({id:M.INDEX++,required:!0,type:"uint32"})],R.prototype,"rwSessionCount",void 0),l([u({id:M.INDEX++,required:!0,type:"uint32"})],R.prototype,"maxPinLen",void 0),l([u({id:M.INDEX++,required:!0,type:"uint32"})],R.prototype,"minPinLen",void 0),l([u({id:M.INDEX++,required:!0,converter:Cr})],R.prototype,"totalPublicMemory",void 0),l([u({id:M.INDEX++,required:!0,converter:Cr})],R.prototype,"freePublicMemory",void 0),l([u({id:M.INDEX++,required:!0,converter:Cr})],R.prototype,"totalPrivateMemory",void 0),l([u({id:M.INDEX++,required:!0,converter:Cr})],R.prototype,"freePrivateMemory",void 0),R=M=l([g({})],R);let G=de=class extends T{constructor(e){super(),this.id="",this.name="",this.readOnly=!1,this.algorithms=[],this.isRemovable=!1,this.atr="",this.isHardware=!1,this.card="",e&&(ut(this,e),e.token&&(this.token=new R(e.token)))}};G.INDEX=T.INDEX,l([u({id:de.INDEX++,required:!0,type:"string"})],G.prototype,"id",void 0),l([u({id:de.INDEX++,required:!0,type:"string"})],G.prototype,"name",void 0),l([u({id:de.INDEX++,type:"bool",defaultValue:!1})],G.prototype,"readOnly",void 0),l([u({id:de.INDEX++,repeated:!0,type:"string"})],G.prototype,"algorithms",void 0),l([u({id:de.INDEX++,type:"bool",defaultValue:!1})],G.prototype,"isRemovable",void 0),l([u({id:de.INDEX++,type:"string"})],G.prototype,"atr",void 0),l([u({id:de.INDEX++,type:"bool",defaultValue:!1})],G.prototype,"isHardware",void 0),l([u({id:de.INDEX++,type:"string"})],G.prototype,"card",void 0),l([u({id:de.INDEX++,parser:R})],G.prototype,"token",void 0),G=de=l([g({})],G);let Dt=Rr=class extends T{constructor(){super(...arguments),this.name="",this.providers=[]}};Dt.INDEX=T.INDEX,l([u({id:Rr.INDEX++,type:"string",required:!0})],Dt.prototype,"name",void 0),l([u({id:Rr.INDEX++,repeated:!0,parser:G})],Dt.prototype,"providers",void 0),Dt=Rr=l([g({})],Dt);let ar=class extends K{};ar.INDEX=K.INDEX,ar.ACTION="provider/action/info",ar=l([g({})],ar);let Kt=Di=class extends K{constructor(){super(...arguments),this.cryptoID=""}};Kt.INDEX=K.INDEX,Kt.ACTION="provider/action/getCrypto",l([u({id:Di.INDEX++,required:!0,type:"string"})],Kt.prototype,"cryptoID",void 0),Kt=Di=l([g({})],Kt);let Pt=class extends K{};Pt.INDEX=K.INDEX,Pt.ACTION="provider/event/authorized",Pt=l([g({})],Pt);let Pe=or=class extends K{constructor(e){super(),this.added=[],this.removed=[],e&&ut(this,e)}};Pe.INDEX=K.INDEX,Pe.ACTION="provider/event/token",l([u({id:or.INDEX++,repeated:!0,parser:G})],Pe.prototype,"added",void 0),l([u({id:or.INDEX++,repeated:!0,parser:G})],Pe.prototype,"removed",void 0),l([u({id:or.INDEX++,type:"bytes",parser:Ae})],Pe.prototype,"error",void 0),Pe=or=l([g({name:"ProviderTokenEvent"})],Pe);var Xr,cr,lr,Ki,ur,et,Oe,Ot,Lr,tt;let Tt=Xr=class extends m{constructor(){super(...arguments),this.algorithm=new A,this.data=new ArrayBuffer(0)}};Tt.INDEX=m.INDEX,Tt.ACTION="crypto/subtle/digest",l([u({id:Xr.INDEX++,required:!0,parser:A})],Tt.prototype,"algorithm",void 0),l([u({id:Xr.INDEX++,required:!0,converter:se})],Tt.prototype,"data",void 0),Tt=Xr=l([g({})],Tt);let $e=cr=class extends m{constructor(){super(...arguments),this.algorithm=new A,this.extractable=!1,this.usage=[]}};$e.INDEX=m.INDEX,$e.ACTION="crypto/subtle/generateKey",l([u({id:cr.INDEX++,type:"bytes",required:!0,parser:A})],$e.prototype,"algorithm",void 0),l([u({id:cr.INDEX++,type:"bool",required:!0})],$e.prototype,"extractable",void 0),l([u({id:cr.INDEX++,type:"string",repeated:!0})],$e.prototype,"usage",void 0),$e=cr=l([g({})],$e);let Y=lr=class extends m{constructor(){super(...arguments),this.algorithm=new A,this.key=new N,this.data=new ArrayBuffer(0)}};Y.INDEX=m.INDEX,Y.ACTION="crypto/subtle/sign",l([u({id:lr.INDEX++,required:!0,parser:A})],Y.prototype,"algorithm",void 0),l([u({id:lr.INDEX++,required:!0,parser:N})],Y.prototype,"key",void 0),l([u({id:lr.INDEX++,required:!0,converter:se})],Y.prototype,"data",void 0),Y=lr=l([g({})],Y);let Ut=Ki=class extends Y{constructor(){super(...arguments),this.signature=new ArrayBuffer(0)}};Ut.INDEX=Y.INDEX,Ut.ACTION="crypto/subtle/verify",l([u({id:Ki.INDEX++,required:!0,converter:se})],Ut.prototype,"signature",void 0),Ut=Ki=l([g({})],Ut);let hr=class extends Y{};hr.INDEX=Y.INDEX,hr.ACTION="crypto/subtle/encrypt",hr=l([g({})],hr);let fr=class extends Y{};fr.INDEX=Y.INDEX,fr.ACTION="crypto/subtle/decrypt",fr=l([g({})],fr);let Fe=ur=class extends m{constructor(){super(...arguments),this.algorithm=new A,this.key=new N,this.length=0}};Fe.INDEX=m.INDEX,Fe.ACTION="crypto/subtle/deriveBits",l([u({id:ur.INDEX++,required:!0,parser:A})],Fe.prototype,"algorithm",void 0),l([u({id:ur.INDEX++,required:!0,parser:N})],Fe.prototype,"key",void 0),l([u({id:ur.INDEX++,required:!0,type:"uint32"})],Fe.prototype,"length",void 0),Fe=ur=l([g({})],Fe);let Ie=et=class extends m{constructor(){super(...arguments),this.algorithm=new A,this.key=new N,this.derivedKeyType=new A,this.extractable=!1,this.usage=[]}};Ie.INDEX=m.INDEX,Ie.ACTION="crypto/subtle/deriveKey",l([u({id:et.INDEX++,required:!0,parser:A})],Ie.prototype,"algorithm",void 0),l([u({id:et.INDEX++,required:!0,parser:N})],Ie.prototype,"key",void 0),l([u({id:et.INDEX++,required:!0,parser:A})],Ie.prototype,"derivedKeyType",void 0),l([u({id:et.INDEX++,type:"bool"})],Ie.prototype,"extractable",void 0),l([u({id:et.INDEX++,type:"string",repeated:!0})],Ie.prototype,"usage",void 0),Ie=et=l([g({})],Ie);let ae=Oe=class extends m{constructor(){super(...arguments),this.format="raw",this.wrappedKey=new ArrayBuffer(0),this.unwrappingKey=new N,this.unwrapAlgorithm=new A,this.unwrappedKeyAlgorithm=new A,this.extractable=!1,this.keyUsage=[]}};ae.INDEX=m.INDEX,ae.ACTION="crypto/subtle/unwrapKey",l([u({id:Oe.INDEX++,required:!0,type:"string"})],ae.prototype,"format",void 0),l([u({id:Oe.INDEX++,required:!0,converter:se})],ae.prototype,"wrappedKey",void 0),l([u({id:Oe.INDEX++,required:!0,parser:N})],ae.prototype,"unwrappingKey",void 0),l([u({id:Oe.INDEX++,required:!0,parser:A})],ae.prototype,"unwrapAlgorithm",void 0),l([u({id:Oe.INDEX++,required:!0,parser:A})],ae.prototype,"unwrappedKeyAlgorithm",void 0),l([u({id:Oe.INDEX++,type:"bool"})],ae.prototype,"extractable",void 0),l([u({id:Oe.INDEX++,type:"string",repeated:!0})],ae.prototype,"keyUsage",void 0),ae=Oe=l([g({})],ae);let Te=Ot=class extends m{constructor(){super(...arguments),this.format="raw",this.key=new N,this.wrappingKey=new N,this.wrapAlgorithm=new A}};Te.INDEX=m.INDEX,Te.ACTION="crypto/subtle/wrapKey",l([u({id:Ot.INDEX++,required:!0,type:"string"})],Te.prototype,"format",void 0),l([u({id:Ot.INDEX++,required:!0,parser:N})],Te.prototype,"key",void 0),l([u({id:Ot.INDEX++,required:!0,parser:N})],Te.prototype,"wrappingKey",void 0),l([u({id:Ot.INDEX++,required:!0,parser:A})],Te.prototype,"wrapAlgorithm",void 0),Te=Ot=l([g({})],Te);let rt=Lr=class extends m{constructor(){super(...arguments),this.format="raw",this.key=new N}};rt.INDEX=m.INDEX,rt.ACTION="crypto/subtle/exportKey",l([u({id:Lr.INDEX++,type:"string",required:!0})],rt.prototype,"format",void 0),l([u({id:Lr.INDEX++,required:!0,parser:N})],rt.prototype,"key",void 0),rt=Lr=l([g({})],rt);let Ne=tt=class extends m{constructor(){super(...arguments),this.format="raw",this.keyData=new ArrayBuffer(0),this.algorithm=new A,this.extractable=!1,this.keyUsages=[]}};Ne.INDEX=m.INDEX,Ne.ACTION="crypto/subtle/importKey",l([u({id:tt.INDEX++,type:"string",required:!0})],Ne.prototype,"format",void 0),l([u({id:tt.INDEX++,required:!0,converter:se})],Ne.prototype,"keyData",void 0),l([u({id:tt.INDEX++,required:!0,parser:A})],Ne.prototype,"algorithm",void 0),l([u({id:tt.INDEX++,required:!0,type:"bool"})],Ne.prototype,"extractable",void 0),l([u({id:tt.INDEX++,type:"string",repeated:!0})],Ne.prototype,"keyUsages",void 0),Ne=tt=l([g({})],Ne);class Io extends D{constructor(e){super(),this.client=e,this.onEvent=this.onEvent.bind(this),this.client.on("listening",()=>{this.client.on("event",this.onEvent)}).on("close",()=>{this.client.removeListener("event",this.onEvent)})}async readers(){const e=await this.client.send(new jt);return JSON.parse(y.ToString(e))}on(e,t){return super.on(e,t)}emit(e,...t){return super.emit(e,...t)}onEvent(e){(async()=>{switch(e.action){case gt.ACTION:this.onInsert(await gt.importProto(e));break;case pt.ACTION:this.onRemove(await pt.importProto(e));break}})().catch(t=>this.emit("error",t))}onInsert(e){this.emit("insert",e)}onRemove(e){this.emit("remove",e)}}async function No(n,e){const t=await n.thumbprint(),r=await e.thumbprint(),i=y.FromHex(t+r),s=await I().crypto.subtle.digest("SHA-256",i);return parseInt(y.ToHex(s),16).toString().substr(2,6)}const ko="/.well-known/webcrypto-socket";class Bo{constructor(e,t){this.target=e,this.event=t}}class Cn extends Error{constructor(e){super(e.message),this.name="CryptoServerError",this.code=e.code,this.type=e.type}}class Pi extends Bo{}class So extends Pi{constructor(e,t,r,i){super(e,"close"),this.remoteAddress=t,this.reasonCode=r,this.description=i}}class Hr extends Pi{constructor(e,t){super(e,"error"),this.error=t}}class xo extends Pi{constructor(e,t){super(e,"listening"),this.address=t}}function Oi(){return typeof self<"u"&&/firefox\/([\w\.-]+)$/i.test(self.navigator.userAgent)}function dr(){return typeof self<"u"&&/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i.test(self.navigator.userAgent)}function yr(){return typeof self<"u"&&/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i.test(self.navigator.userAgent)}const Ti={name:"ECDH",namedCurve:"P-256"},Ui={name:"ECDSA",namedCurve:"P-256"},$={name:"AES-CBC",iv:new ArrayBuffer(16)};async function Co(n){const e=n.algorithm.name.toUpperCase();if(!(e==="ECDH"||e==="ECDSA"))throw new Error("Error: Unsupported asymmetric key algorithm.");if(n.type!=="public")throw new Error("Error: Expected key type to be public but it was not.");const t=await I().crypto.subtle.exportKey("jwk",n);if(!(t.x&&t.y))throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const r=y.FromBase64Url(t.x),i=y.FromBase64Url(t.y),s=y.ToBinary(r)+y.ToBinary(i),o=n,a=y.FromBinary(s);return{id:y.ToHex(await I().crypto.subtle.digest("SHA-256",a)),key:o,serialized:a}}async function Dn(n,e){const t=await Co(e);n.id=t.id,n.key=t.key,n.serialized=t.serialized}var _r;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(_r||(_r={}));class Do extends D{get state(){return this.socket?this.socket.readyState:_r.closed}constructor(e){super(),this.stack={},this.messageCounter=0,this.storage=e}connect(e,t){return this.getServerInfo(e).then(r=>{const[i,s,o]=r.version.split(".").map(c=>parseInt(c,10));if(i<1||i===1&&s<2)throw new Error(`Current version of WebCryptoSocket doesn't work with WebCryptoServer v${r.version}. Please update your client to the latest version.`);this.serviceInfo=r;const a=`wss://${e}`;this.socket=t?new cn(a,void 0,t):new cn(a),this.socket.binaryType="arraybuffer",this.socket.onerror=c=>{this.emit("error",new Hr(this,c.error))},this.socket.onopen=()=>{(async()=>{let c=await this.storage.loadIdentity();c||(c=await Br.create(1,0,0,yr()||dr()||Oi()),await this.storage.saveIdentity(c));const h="0",d=await Nn.importProto(y.FromBase64(r.preKey));this.cipher=await Mt.create(c,d),await this.storage.saveRemoteIdentity(h,this.cipher.remoteIdentity),this.emit("listening",new xo(this,e))})().catch(c=>this.emit("error",new Hr(this,c)))},this.socket.onclose=c=>{for(const h in this.stack)this.stack[h].reject(new Error("Cannot finish operation. Session was closed"));this.emit("close",new So(this,e,c.code,c.reason))},this.socket.onmessage=c=>{c.data instanceof ArrayBuffer&&yi.importProto(c.data).then(h=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.decrypt(h)}).then(h=>{this.onMessage(h)}).catch(h=>{this.emit("error",new Hr(this,h))})}}).catch(r=>{this.emit("error",new Hr(this,r))}),this}close(){this.socket&&this.socket.close()}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async challenge(){if(!this.cipher)throw new Error("Client cipher is not initialized");return No(this.cipher.remoteIdentity.signingKey,this.cipher.identity.signingKey.publicKey)}async isLoggedIn(){const e=new Gt,t=await this.send(e);return t?!!new Uint8Array(t)[0]:!1}async login(){const e=new Jt;await this.send(e)}send(e){return new Promise((t,r)=>{this.checkSocketState(),e||(e=new K),e.action=e.action,e.actionId=(this.messageCounter++).toString(),e.exportProto().then(i=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.encrypt(i).then(s=>s.exportProto())}).then(i=>{if(!this.socket)throw new Error("Client socket is not initialized");this.stack[e.actionId]={resolve:t,reject:r},this.socket.send(i)}).catch(r)})}async getServerInfo(e){const t=`https://${e}${ko}`,r=await fetch(t);if(r.status!==200)throw new Error("Cannot get wellknown link");return await r.json()}checkSocketState(){if(this.state!==_r.open)throw new Error("Socket connection is not open")}async onMessage(e){const t=await K.importProto(e),r=this.stack[t.actionId];if(r){delete this.stack[t.actionId];const i=await We.importProto(await t.exportProto());if(i.error&&i.error.message){const s=i.error,o=new Cn(s);r.reject(o)}else r.resolve(i.data)}else this.emit("event",t)}}/*!
 Copyright (c) Peculiar Ventures, LLC
*/function Vt(n,e){let t=0;if(n.length===1)return n[0];for(let r=n.length-1;r>=0;r--)t+=n[n.length-1-r]*Math.pow(2,e*r);return t}function it(n,e,t=-1){const r=t;let i=n,s=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(n<o){let c;if(r<0)c=new ArrayBuffer(a),s=a;else{if(r<a)return new ArrayBuffer(0);c=new ArrayBuffer(r),s=r}const h=new Uint8Array(c);for(let d=a-1;d>=0;d--){const f=Math.pow(2,d*e);h[s-d-1]=Math.floor(i/f),i-=h[s-d-1]*f}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function Vi(...n){let e=0,t=0;for(const s of n)e+=s.length;const r=new ArrayBuffer(e),i=new Uint8Array(r);for(const s of n)i.set(s,t),t+=s.length;return i}function Kn(){const n=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const a=n[0]===255&&n[1]&128,c=n[0]===0&&(n[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=n[0]&128;const r=Vt(t,8),i=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(i);for(let a=0;a<this.valueHex.byteLength;a++)s[a]=n[a];return s[0]&=127,Vt(s,8)-r}function Ko(n){const e=n<0?n*-1:n;let t=128;for(let r=1;r<8;r++){if(e<=t){if(n<0){const o=t-e,a=it(o,8,r),c=new Uint8Array(a);return c[0]|=128,a}let i=it(e,8,r),s=new Uint8Array(i);if(s[0]&128){const o=i.slice(0),a=new Uint8Array(o);i=new ArrayBuffer(i.byteLength+1),s=new Uint8Array(i);for(let c=0;c<o.byteLength;c++)s[c+1]=a[c];s[0]=0}return i}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function Po(n,e){if(n.byteLength!==e.byteLength)return!1;const t=new Uint8Array(n),r=new Uint8Array(e);for(let i=0;i<t.length;i++)if(t[i]!==r[i])return!1;return!0}function re(n,e){const t=n.toString(10);if(e<t.length)return"";const r=e-t.length,i=new Array(r);for(let o=0;o<r;o++)i[o]="0";return i.join("").concat(t)}/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 *
 * Author 2014-2019, Yury Strozhevsky
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */function Mr(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function Ri(n){let e=0,t=0;for(let i=0;i<n.length;i++){const s=n[i];e+=s.byteLength}const r=new Uint8Array(e);for(let i=0;i<n.length;i++){const s=n[i];r.set(new Uint8Array(s),t),t+=s.byteLength}return r.buffer}function Ue(n,e,t,r){return e instanceof Uint8Array?e.byteLength?t<0?(n.error="Wrong parameter: inputOffset less than zero",!1):r<0?(n.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-r<0?(n.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(n.error="Wrong parameter: inputBuffer has zero length",!1):(n.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class qr{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return Ri(this.items)}}const gr=[new Uint8Array([1])],Pn="0123456789",Xi="name",On="valueHexView",Oo="isHexOnly",To="idBlock",Uo="tagClass",Vo="tagNumber",Ro="isConstructed",Xo="fromBER",Lo="toBER",Ho="local",Z="",ge=new ArrayBuffer(0),$r=new Uint8Array(0),pr="EndOfContent",Tn="OCTET STRING",Un="BIT STRING";function ke(n){var e;return e=class extends n{constructor(...r){var i;super(...r);const s=r[0]||{};this.isHexOnly=(i=s.isHexOnly)!==null&&i!==void 0?i:!1,this.valueHexView=s.valueHex?v.toUint8Array(s.valueHex):$r}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(r){this.valueHexView=new Uint8Array(r)}fromBER(r,i,s){const o=r instanceof ArrayBuffer?new Uint8Array(r):r;if(!Ue(this,o,i,s))return-1;const a=i+s;return this.valueHexView=o.subarray(i,a),this.valueHexView.length?(this.blockLength=s,a):(this.warnings.push("Zero buffer length"),i)}toBER(r=!1){return this.isHexOnly?r?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",ge)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:y.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}class nt{constructor({blockLength:e=0,error:t=Z,warnings:r=[],valueBeforeDecode:i=$r}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=v.toUint8Array(i)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:y.ToHex(this.valueBeforeDecodeView)}}}nt.NAME="baseBlock";class j extends nt{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}j.NAME="valueBlock";class Vn extends ke(nt){constructor({idBlock:e={}}={}){var t,r,i,s;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?v.toUint8Array(e.valueHex):$r,this.tagClass=(r=e.tagClass)!==null&&r!==void 0?r:-1,this.tagNumber=(i=e.tagNumber)!==null&&i!==void 0?i:-1,this.isConstructed=(s=e.isConstructed)!==null&&s!==void 0?s:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",ge}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const i=new Uint8Array(1);if(!e){let s=this.tagNumber;s&=31,t|=s,i[0]=t}return i.buffer}if(!this.isHexOnly){const i=it(this.tagNumber,7),s=new Uint8Array(i),o=i.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=s[c]|128;a[o]=s[o-1]}return a.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=t|31,!e){const i=this.valueHexView;for(let s=0;s<i.length-1;s++)r[s+1]=i[s]|128;r[this.valueHexView.byteLength]=i[i.length-1]}return r.buffer}fromBER(e,t,r){const i=v.toUint8Array(e);if(!Ue(this,i,t,r))return-1;const s=i.subarray(t,t+r);if(s.length===0)return this.error="Zero buffer length",-1;switch(s[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(s[0]&32)===32,this.isHexOnly=!1;const a=s[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,h=this.valueHexView=new Uint8Array(255),d=255;for(;s[c]&128;){if(h[c-1]=s[c]&127,c++,c>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(c===d){d+=255;const b=new Uint8Array(d);for(let B=0;B<h.length;B++)b[B]=h[B];h=this.valueHexView=new Uint8Array(d)}}this.blockLength=c+1,h[c-1]=s[c]&127;const f=new Uint8Array(c);for(let b=0;b<c;b++)f[b]=h[b];h=this.valueHexView=new Uint8Array(c),h.set(f),this.blockLength<=9?this.tagNumber=Vt(h,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}Vn.NAME="identificationBlock";class Rn extends nt{constructor({lenBlock:e={}}={}){var t,r,i;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(r=e.longFormUsed)!==null&&r!==void 0?r:!1,this.length=(i=e.length)!==null&&i!==void 0?i:0}fromBER(e,t,r){const i=v.toUint8Array(e);if(!Ue(this,i,t,r))return-1;const s=i.subarray(t,t+r);if(s.length===0)return this.error="Zero buffer length",-1;if(s[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=s[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(s[0]&128),this.longFormUsed===!1)return this.length=s[0],this.blockLength=1,t+this.blockLength;const o=s[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const a=t+1,c=i.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Vt(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const i=it(this.length,8);if(i.byteLength>127)return this.error="Too big length",ge;if(t=new ArrayBuffer(i.byteLength+1),e)return t;const s=new Uint8Array(i);r=new Uint8Array(t),r[0]=i.byteLength|128;for(let o=0;o<i.byteLength;o++)r[o+1]=s[o];return t}return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}Rn.NAME="lengthBlock";const p={};class q extends nt{constructor({name:e=Z,optional:t=!1,primitiveSchema:r,...i}={},s){super(i),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new Vn(i),this.lenBlock=new Rn(i),this.valueBlock=s?new s(i):new j(i)}fromBER(e,t,r){const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}toBER(e,t){const r=t||new qr;t||Xn(this);const i=this.idBlock.toBER(e);if(r.write(i),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const s=this.valueBlock.toBER(e);this.lenBlock.length=s.byteLength;const o=this.lenBlock.toBER(e);r.write(o),r.write(s)}return t?ge:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():y.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${y.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;const t=this.toBER(),r=e.toBER();return Po(t,r)}}q.NAME="BaseBlock";function Xn(n){if(n instanceof p.Constructed)for(const e of n.valueBlock.value)Xn(e)&&(n.lenBlock.isIndefiniteForm=!0);return!!n.lenBlock.isIndefiniteForm}class Li extends q{constructor({value:e=Z,...t}={},r){super(t,r),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,r){const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}Li.NAME="BaseStringBlock";class Ln extends ke(j){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}Ln.NAME="PrimitiveValueBlock";var Hn;class mr extends q{constructor(e={}){super(e,Ln),this.idBlock.isConstructed=!1}}Hn=mr,p.Primitive=Hn,mr.NAME="PRIMITIVE";function _o(n,e){if(n instanceof e)return n;const t=new e;return t.idBlock=n.idBlock,t.lenBlock=n.lenBlock,t.warnings=n.warnings,t.valueBeforeDecodeView=n.valueBeforeDecodeView,t}function Rt(n,e=0,t=n.length){const r=e;let i=new q({},j);const s=new nt;if(!Ue(s,n,e,t))return i.error=s.error,{offset:-1,result:i};if(!n.subarray(e,e+t).length)return i.error="Zero buffer length",{offset:-1,result:i};let a=i.idBlock.fromBER(n,e,t);if(i.idBlock.warnings.length&&i.warnings.concat(i.idBlock.warnings),a===-1)return i.error=i.idBlock.error,{offset:-1,result:i};if(e=a,t-=i.idBlock.blockLength,a=i.lenBlock.fromBER(n,e,t),i.lenBlock.warnings.length&&i.warnings.concat(i.lenBlock.warnings),a===-1)return i.error=i.lenBlock.error,{offset:-1,result:i};if(e=a,t-=i.lenBlock.blockLength,!i.idBlock.isConstructed&&i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let c=q;switch(i.idBlock.tagClass){case 1:if(i.idBlock.tagNumber>=37&&i.idBlock.isHexOnly===!1)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};c=p.EndOfContent;break;case 1:c=p.Boolean;break;case 2:c=p.Integer;break;case 3:c=p.BitString;break;case 4:c=p.OctetString;break;case 5:c=p.Null;break;case 6:c=p.ObjectIdentifier;break;case 10:c=p.Enumerated;break;case 12:c=p.Utf8String;break;case 13:c=p.RelativeObjectIdentifier;break;case 14:c=p.TIME;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:c=p.Sequence;break;case 17:c=p.Set;break;case 18:c=p.NumericString;break;case 19:c=p.PrintableString;break;case 20:c=p.TeletexString;break;case 21:c=p.VideotexString;break;case 22:c=p.IA5String;break;case 23:c=p.UTCTime;break;case 24:c=p.GeneralizedTime;break;case 25:c=p.GraphicString;break;case 26:c=p.VisibleString;break;case 27:c=p.GeneralString;break;case 28:c=p.UniversalString;break;case 29:c=p.CharacterString;break;case 30:c=p.BmpString;break;case 31:c=p.DATE;break;case 32:c=p.TimeOfDay;break;case 33:c=p.DateTime;break;case 34:c=p.Duration;break;default:{const h=i.idBlock.isConstructed?new p.Constructed:new p.Primitive;h.idBlock=i.idBlock,h.lenBlock=i.lenBlock,h.warnings=i.warnings,i=h}}break;case 2:case 3:case 4:default:c=i.idBlock.isConstructed?p.Constructed:p.Primitive}return i=_o(i,c),a=i.fromBER(n,e,i.lenBlock.isIndefiniteForm?t:i.lenBlock.length),i.valueBeforeDecodeView=n.subarray(r,r+i.blockLength),{offset:a,result:i}}function Xt(n){if(!n.byteLength){const e=new q({},j);return e.error="Input buffer has zero length",{offset:-1,result:e}}return Rt(v.toUint8Array(n).slice(),0,n.byteLength)}function Mo(n,e){return n?1:e}class Je extends j{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const i=v.toUint8Array(e);if(!Ue(this,i,t,r))return-1;if(this.valueBeforeDecodeView=i.subarray(t,t+r),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let s=t;for(;Mo(this.isIndefiniteForm,r)>0;){const o=Rt(i,s,r);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(s=o.offset,this.blockLength+=o.result.blockLength,r-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===pr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===pr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(e,t){const r=t||new qr;for(let i=0;i<this.value.length;i++)this.value[i].toBER(e,r);return t?ge:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}Je.NAME="ConstructedValueBlock";var _n;class Q extends q{constructor(e={}){super(e,Je),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){const e=[];for(const r of this.valueBlock.value)e.push(r.toString("ascii").split(`
`).map(i=>`  ${i}`).join(`
`));const t=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :
${e.join(`
`)}`:`${t} :`}}_n=Q,p.Constructed=_n,Q.NAME="CONSTRUCTED";class Mn extends j{fromBER(e,t,r){return t}toBER(e){return ge}}Mn.override="EndOfContentValueBlock";var qn;class Hi extends q{constructor(e={}){super(e,Mn),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}qn=Hi,p.EndOfContent=qn,Hi.NAME=pr;var $n;class st extends q{constructor(e={}){super(e,j),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const i=new Uint8Array(r);i[0]=5,i[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}$n=st,p.Null=$n,st.NAME="NULL";class Fn extends ke(j){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=v.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,r){const i=v.toUint8Array(e);return Ue(this,i,t,r)?(this.valueHexView=i.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,Kn.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}Fn.NAME="BooleanValueBlock";var Jn;class Fr extends q{constructor(e={}){super(e,Fn),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}Jn=Fr,p.Boolean=Jn,Fr.NAME="BOOLEAN";class Gn extends ke(Je){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let i=0;if(this.isConstructed){if(this.isHexOnly=!1,i=Je.prototype.fromBER.call(this,e,t,r),i===-1)return i;for(let s=0;s<this.value.length;s++){const o=this.value[s].constructor.NAME;if(o===pr){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==Tn)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,i=super.fromBER(e,t,r),this.blockLength=r;return i}toBER(e,t){return this.isConstructed?Je.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}Gn.NAME="OctetStringValueBlock";var jn;let Jr=class Gs extends q{constructor({idBlock:e={},lenBlock:t={},...r}={}){var i,s;(i=r.isConstructed)!==null&&i!==void 0||(r.isConstructed=!!(!((s=r.value)===null||s===void 0)&&s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},Gn),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,r===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const s=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(s.byteLength){const o=Rt(s,0,s.byteLength);o.offset!==-1&&o.offset===r&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(e,t,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?Q.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${y.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof Gs&&e.push(t.valueBlock.valueHexView);return v.concat(e)}};jn=Jr,p.OctetString=jn,Jr.NAME=Tn;class zn extends ke(Je){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let i=-1;if(this.isConstructed){if(i=Je.prototype.fromBER.call(this,e,t,r),i===-1)return i;for(const a of this.value){const c=a.constructor.NAME;if(c===pr){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==Un)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const h=a.valueBlock;if(this.unusedBits>0&&h.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=h.unusedBits}return i}const s=v.toUint8Array(e);if(!Ue(this,s,t,r))return-1;const o=s.subarray(t,t+r);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const a=o.subarray(1);try{if(a.byteLength){const c=Rt(a,0,a.byteLength);c.offset!==-1&&c.offset===r-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+r}toBER(e,t){if(this.isConstructed)return Je.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return ge;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}zn.NAME="BitStringValueBlock";var Wn;let Gr=class extends q{constructor({idBlock:e={},lenBlock:t={},...r}={}){var i,s;(i=r.isConstructed)!==null&&i!==void 0||(r.isConstructed=!!(!((s=r.value)===null||s===void 0)&&s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},zn),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Q.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const i of t)e.push(i.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}};Wn=Gr,p.BitString=Wn,Gr.NAME=Un;var Yn;function qo(n,e){const t=new Uint8Array([0]),r=new Uint8Array(n),i=new Uint8Array(e);let s=r.slice(0);const o=s.length-1,a=i.slice(0),c=a.length-1;let h=0;const d=c<o?o:c;let f=0;for(let b=d;b>=0;b--,f++){switch(!0){case f<a.length:h=s[o-f]+a[c-f]+t[0];break;default:h=s[o-f]+t[0]}switch(t[0]=h/10,!0){case f>=s.length:s=Vi(new Uint8Array([h%10]),s);break;default:s[o-f]=h%10}}return t[0]>0&&(s=Vi(t,s)),s}function Zn(n){if(n>=gr.length)for(let e=gr.length;e<=n;e++){const t=new Uint8Array([0]);let r=gr[e-1].slice(0);for(let i=r.length-1;i>=0;i--){const s=new Uint8Array([(r[i]<<1)+t[0]]);t[0]=s[0]/10,r[i]=s[0]%10}t[0]>0&&(r=Vi(t,r)),gr.push(r)}return gr[n]}function $o(n,e){let t=0;const r=new Uint8Array(n),i=new Uint8Array(e),s=r.slice(0),o=s.length-1,a=i.slice(0),c=a.length-1;let h,d=0;for(let f=c;f>=0;f--,d++)switch(h=s[o-d]-a[c-d]-t,!0){case h<0:t=1,s[o-d]=h+10;break;default:t=0,s[o-d]=h}if(t>0)for(let f=o-c+1;f>=0;f--,d++)if(h=s[o-d]-t,h<0)t=1,s[o-d]=h+10;else{t=0,s[o-d]=h;break}return s.slice()}class _i extends ke(j){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=Kn.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(Ko(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,i=0){const s=this.fromBER(e,t,r);if(s===-1)return s;const o=this.valueHexView;return o[0]===0&&o[1]&128?this.valueHexView=o.subarray(1):i!==0&&o.length<i&&(i-o.length>1&&(i=o.length+1),this.valueHexView=o.subarray(i-o.length)),s}toDER(e=!1){const t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{const r=new Uint8Array(this.valueHexView.length+1);r[0]=0,r.set(t,1),this.valueHexView=r}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,r){const i=super.fromBER(e,t,r);return i===-1||this.setValueHex(),i}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=this.valueHexView.length*8-1;let t=new Uint8Array(this.valueHexView.length*8/3),r=0,i;const s=this.valueHexView;let o="",a=!1;for(let c=s.byteLength-1;c>=0;c--){i=s[c];for(let h=0;h<8;h++){if((i&1)===1)switch(r){case e:t=$o(Zn(r),t),o="-";break;default:t=qo(t,Zn(r))}r++,i>>=1}}for(let c=0;c<t.length;c++)t[c]&&(a=!0),a&&(o+=Pn.charAt(t[c]));return a===!1&&(o+=Pn.charAt(0)),o}}Yn=_i,_i.NAME="IntegerValueBlock",Object.defineProperty(Yn.prototype,"valueHex",{set:function(n){this.valueHexView=new Uint8Array(n),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var Qn;class ce extends q{constructor(e={}){super(e,_i),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return Mr(),BigInt(this.valueBlock.toString())}static fromBigInt(e){Mr();const t=BigInt(e),r=new qr,i=t.toString(16).replace(/^-/,""),s=new Uint8Array(y.FromHex(i));if(t<0){const a=new Uint8Array(s.length+(s[0]&128?1:0));a[0]|=128;const h=BigInt(`0x${y.ToHex(a)}`)+t,d=v.toUint8Array(y.FromHex(h.toString(16)));d[0]|=128,r.write(d)}else s[0]&128&&r.write(new Uint8Array([0])),r.write(s);return new ce({valueHex:r.final()})}convertToDER(){const e=new ce({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new ce({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}Qn=ce,p.Integer=Qn,ce.NAME="INTEGER";var es;class jr extends ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}es=jr,p.Enumerated=es,jr.NAME="ENUMERATED";class Mi extends ke(j){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const i=v.toUint8Array(e);if(!Ue(this,i,t,r))return-1;const s=i.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=s[a]&127,this.blockLength++,!!(s[a]&128));a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,s[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Vt(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){Mr();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let i=0;i<r.length;i++)r[i]=parseInt(t.slice(i*7,i*7+7),2)+(i+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const i=this.valueHexView,s=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)s[o]=i[o]|128;return s[this.blockLength-1]=i[this.blockLength-1],s.buffer}const t=it(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",ge;const r=new Uint8Array(t.byteLength);if(!e){const i=new Uint8Array(t),s=t.byteLength-1;for(let o=0;o<s;o++)r[o]=i[o]|128;r[s]=i[s]}return r}toString(){let e="";if(this.isHexOnly)e=y.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}Mi.NAME="sidBlock";class ts extends j{constructor({value:e=Z,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let i=t;for(;r>0;){const s=new Mi;if(i=s.fromBER(e,i,r),i===-1)return this.blockLength=0,this.error=s.error,i;this.value.length===0&&(s.isFirstSid=!0),this.blockLength+=s.blockLength,r-=s.blockLength,this.value.push(s)}return i}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(e);if(i.byteLength===0)return this.error=this.value[r].error,ge;t.push(i)}return Ri(t)}fromString(e){this.value=[];let t=0,r=0,i="",s=!1;do if(r=e.indexOf(".",t),r===-1?i=e.substring(t):i=e.substring(t,r),t=r+1,s){const o=this.value[0];let a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}const c=parseInt(i,10);if(isNaN(c))return;o.valueDec=c+a,s=!1}else{const o=new Mi;if(i>Number.MAX_SAFE_INTEGER){Mr();const a=BigInt(i);o.valueBigInt=a}else if(o.valueDec=parseInt(i,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,s=!0),this.value.push(o)}while(r!==-1)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let i=this.value[r].toString();r!==0&&(e=`${e}.`),t?(i=`{${i}}`,this.value[r].isFirstSid?e=`2.{${i} - 80}`:e+=i):e+=i}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}ts.NAME="ObjectIdentifierValueBlock";var rs;let zr=class extends q{constructor(e={}){super(e,ts),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}};rs=zr,p.ObjectIdentifier=rs,zr.NAME="OBJECT IDENTIFIER";class qi extends ke(nt){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(r===0)return t;const i=v.toUint8Array(e);if(!Ue(this,i,t,r))return-1;const s=i.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=s[a]&127,this.blockLength++,!!(s[a]&128));a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,s[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Vt(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const i=this.valueHexView,s=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)s[o]=i[o]|128;return s[this.blockLength-1]=i[this.blockLength-1],s.buffer}const t=it(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",ge;const r=new Uint8Array(t.byteLength);if(!e){const i=new Uint8Array(t),s=t.byteLength-1;for(let o=0;o<s;o++)r[o]=i[o]|128;r[s]=i[s]}return r.buffer}toString(){let e="";return this.isHexOnly?e=y.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}qi.NAME="relativeSidBlock";class is extends j{constructor({value:e=Z,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let i=t;for(;r>0;){const s=new qi;if(i=s.fromBER(e,i,r),i===-1)return this.blockLength=0,this.error=s.error,i;this.blockLength+=s.blockLength,r-=s.blockLength,this.value.push(s)}return i}toBER(e,t){const r=[];for(let i=0;i<this.value.length;i++){const s=this.value[i].toBER(e);if(s.byteLength===0)return this.error=this.value[i].error,ge;r.push(s)}return Ri(r)}fromString(e){this.value=[];let t=0,r=0,i="";do{r=e.indexOf(".",t),r===-1?i=e.substring(t):i=e.substring(t,r),t=r+1;const s=new qi;if(s.valueDec=parseInt(i,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(r!==-1);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let i=this.value[r].toString();r!==0&&(e=`${e}.`),t&&(i=`{${i}}`),e+=i}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}is.NAME="RelativeObjectIdentifierValueBlock";var ns;class $i extends q{constructor(e={}){super(e,is),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}ns=$i,p.RelativeObjectIdentifier=ns,$i.NAME="RelativeObjectIdentifier";var ss;class Ve extends Q{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}ss=Ve,p.Sequence=ss,Ve.NAME="SEQUENCE";var os;class Re extends Q{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}os=Re,p.Set=os,Re.NAME="SET";class as extends ke(j){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=Z}toJSON(){return{...super.toJSON(),value:this.value}}}as.NAME="StringValueBlock";class cs extends as{}cs.NAME="SimpleStringValueBlock";class ie extends Li{constructor({...e}={}){super(e,cs)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,v.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.charCodeAt(i);this.valueBlock.value=e}}ie.NAME="SIMPLE STRING";class ls extends ie{fromBuffer(e){this.valueBlock.valueHexView=v.toUint8Array(e);try{this.valueBlock.value=y.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=y.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(y.FromUtf8String(e)),this.valueBlock.value=e}}ls.NAME="Utf8StringValueBlock";var us;class Xe extends ls{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}us=Xe,p.Utf8String=us,Xe.NAME="UTF8String";class hs extends ie{fromBuffer(e){this.valueBlock.value=y.ToUtf16String(e),this.valueBlock.valueHexView=v.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(y.FromUtf16String(e))}}hs.NAME="BmpStringValueBlock";var fs;class Wr extends hs{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}fs=Wr,p.BmpString=fs,Wr.NAME="BMPString";class ds extends ie{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let i=0;i<r.length;i+=4)r[i]=r[i+3],r[i+1]=r[i+2],r[i+2]=0,r[i+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let i=0;i<t;i++){const s=it(e.charCodeAt(i),8),o=new Uint8Array(s);if(o.length>4)continue;const a=4-o.length;for(let c=o.length-1;c>=0;c--)r[i*4+c+a]=o[c]}this.valueBlock.value=e}}ds.NAME="UniversalStringValueBlock";var ys;class Yr extends ds{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}ys=Yr,p.UniversalString=ys,Yr.NAME="UniversalString";var gs;class Zr extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}gs=Zr,p.NumericString=gs,Zr.NAME="NumericString";var ps;class Qr extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}ps=Qr,p.PrintableString=ps,Qr.NAME="PrintableString";var ms;class ei extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}ms=ei,p.TeletexString=ms,ei.NAME="TeletexString";var vs;class ti extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}vs=ti,p.VideotexString=vs,ti.NAME="VideotexString";var ws;class ri extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}ws=ri,p.IA5String=ws,ri.NAME="IA5String";var Es;class ii extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}Es=ii,p.GraphicString=Es,ii.NAME="GraphicString";var As;class vr extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}As=vr,p.VisibleString=As,vr.NAME="VisibleString";var bs;class ni extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}bs=ni,p.GeneralString=bs,ni.NAME="GeneralString";var Is;class si extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}Is=si,p.CharacterString=Is,si.NAME="CharacterString";var Ns;class wr extends vr{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let i=0;i<e.length;i++)this.valueBlock.valueHexView[i]=e.charCodeAt(i)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,v.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let i=0;i<e.length;i++)r[i]=e.charCodeAt(i);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const r=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(r===null){this.error="Wrong input string for conversion";return}const i=parseInt(r[1],10);i>=50?this.year=1900+i:this.year=2e3+i,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(e="iso"){if(e==="iso"){const t=new Array(7);return t[0]=re(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=re(this.month,2),t[2]=re(this.day,2),t[3]=re(this.hour,2),t[4]=re(this.minute,2),t[5]=re(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}Ns=wr,p.UTCTime=Ns,wr.NAME="UTCTime";var ks;class oi extends wr{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t=!1,r="",i="",s=0,o,a=0,c=0;if(e[e.length-1]==="Z")r=e.substring(0,e.length-1),t=!0;else{const f=new Number(e[e.length-1]);if(isNaN(f.valueOf()))throw new Error("Wrong input string for conversion");r=e}if(t){if(r.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(r.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let f=1,b=r.indexOf("+"),B="";if(b===-1&&(b=r.indexOf("-"),f=-1),b!==-1){if(B=r.substring(b+1),r=r.substring(0,b),B.length!==2&&B.length!==4)throw new Error("Wrong input string for conversion");let X=parseInt(B.substring(0,2),10);if(isNaN(X.valueOf()))throw new Error("Wrong input string for conversion");if(a=f*X,B.length===4){if(X=parseInt(B.substring(2,4),10),isNaN(X.valueOf()))throw new Error("Wrong input string for conversion");c=f*X}}}let h=r.indexOf(".");if(h===-1&&(h=r.indexOf(",")),h!==-1){const f=new Number(`0${r.substring(h)}`);if(isNaN(f.valueOf()))throw new Error("Wrong input string for conversion");s=f.valueOf(),i=r.substring(0,h)}else i=r;switch(!0){case i.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,h!==-1)throw new Error("Wrong input string for conversion");break;case i.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let f=60*s;this.minute=Math.floor(f),f=60*(f-this.minute),this.second=Math.floor(f),f=1e3*(f-this.second),this.millisecond=Math.floor(f)}break;case i.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let f=60*s;this.second=Math.floor(f),f=1e3*(f-this.second),this.millisecond=Math.floor(f)}break;case i.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,h!==-1){const f=1e3*s;this.millisecond=Math.floor(f)}break;default:throw new Error("Wrong input string for conversion")}const d=o.exec(i);if(d===null)throw new Error("Wrong input string for conversion");for(let f=1;f<d.length;f++)switch(f){case 1:this.year=parseInt(d[f],10);break;case 2:this.month=parseInt(d[f],10);break;case 3:this.day=parseInt(d[f],10);break;case 4:this.hour=parseInt(d[f],10)+a;break;case 5:this.minute=parseInt(d[f],10)+c;break;case 6:this.second=parseInt(d[f],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){const f=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=f.getUTCFullYear(),this.month=f.getUTCMonth(),this.day=f.getUTCDay(),this.hour=f.getUTCHours(),this.minute=f.getUTCMinutes(),this.second=f.getUTCSeconds(),this.millisecond=f.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){const t=[];return t.push(re(this.year,4)),t.push(re(this.month,2)),t.push(re(this.day,2)),t.push(re(this.hour,2)),t.push(re(this.minute,2)),t.push(re(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(re(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}ks=oi,p.GeneralizedTime=ks,oi.NAME="GeneralizedTime";var Bs;class Fi extends Xe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}Bs=Fi,p.DATE=Bs,Fi.NAME="DATE";var Ss;class Ji extends Xe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}Ss=Ji,p.TimeOfDay=Ss,Ji.NAME="TimeOfDay";var xs;class Gi extends Xe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}xs=Gi,p.DateTime=xs,Gi.NAME="DateTime";var Cs;class ji extends Xe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}Cs=ji,p.Duration=Cs,ji.NAME="Duration";var Ds;class zi extends Xe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}Ds=zi,p.TIME=Ds,zi.NAME="TIME";class ot{constructor({name:e=Z,optional:t=!1}={}){this.name=e,this.optional=t}}class Wi extends ot{constructor({value:e=[],...t}={}){super(t),this.value=e}}class ai extends ot{constructor({value:e=new ot,local:t=!1,...r}={}){super(r),this.value=e,this.local=t}}class Fo{constructor({data:e=$r}={}){this.dataView=v.toUint8Array(e)}get data(){return this.dataView.slice().buffer}set data(e){this.dataView=v.toUint8Array(e)}fromBER(e,t,r){const i=t+r;return this.dataView=v.toUint8Array(e).subarray(t,i),i}toBER(e){return this.dataView.slice().buffer}}function at(n,e,t){if(t instanceof Wi){for(let s=0;s<t.value.length;s++)if(at(n,e,t.value[s]).verified)return{verified:!0,result:n};{const s={verified:!1,result:{error:"Wrong values for Choice type"}};return t.hasOwnProperty(Xi)&&(s.name=t.name),s}}if(t instanceof ot)return t.hasOwnProperty(Xi)&&(n[t.name]=e),{verified:!0,result:n};if(!(n instanceof Object))return{verified:!1,result:{error:"Wrong root object"}};if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(!(t instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(To in t))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Xo in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Lo in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const r=t.idBlock.toBER(!1);if(r.byteLength===0)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(t.idBlock.fromBER(r,0,r.byteLength)===-1)return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(t.idBlock.hasOwnProperty(Uo)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:n};if(t.idBlock.hasOwnProperty(Vo)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:n};if(t.idBlock.hasOwnProperty(Ro)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:n};if(!(Oo in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:n};if(t.idBlock.isHexOnly){if(!(On in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=t.idBlock.valueHexView,o=e.idBlock.valueHexView;if(s.length!==o.length)return{verified:!1,result:n};for(let a=0;a<s.length;a++)if(s[a]!==o[1])return{verified:!1,result:n}}if(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Z),t.name&&(n[t.name]=e)),t instanceof p.Constructed){let s=0,o={verified:!1,result:{error:"Unknown error"}},a=t.valueBlock.value.length;if(a>0&&t.valueBlock.value[0]instanceof ai&&(a=e.valueBlock.value.length),a===0)return{verified:!0,result:n};if(e.valueBlock.value.length===0&&t.valueBlock.value.length!==0){let c=!0;for(let h=0;h<t.valueBlock.value.length;h++)c=c&&(t.valueBlock.value[h].optional||!1);return c?{verified:!0,result:n}:(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Z),t.name&&delete n[t.name]),n.error="Inconsistent object length",{verified:!1,result:n})}for(let c=0;c<a;c++)if(c-s>=e.valueBlock.value.length){if(t.valueBlock.value[c].optional===!1){const h={verified:!1,result:n};return n.error="Inconsistent length between ASN.1 data and schema",t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Z),t.name&&(delete n[t.name],h.name=t.name)),h}}else if(t.valueBlock.value[0]instanceof ai){if(o=at(n,e.valueBlock.value[c],t.valueBlock.value[0].value),o.verified===!1)if(t.valueBlock.value[0].optional)s++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Z),t.name&&delete n[t.name]),o;if(Xi in t.valueBlock.value[0]&&t.valueBlock.value[0].name.length>0){let h={};Ho in t.valueBlock.value[0]&&t.valueBlock.value[0].local?h=e:h=n,typeof h[t.valueBlock.value[0].name]>"u"&&(h[t.valueBlock.value[0].name]=[]),h[t.valueBlock.value[0].name].push(e.valueBlock.value[c])}}else if(o=at(n,e.valueBlock.value[c-s],t.valueBlock.value[c]),o.verified===!1)if(t.valueBlock.value[c].optional)s++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Z),t.name&&delete n[t.name]),o;if(o.verified===!1){const c={verified:!1,result:n};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Z),t.name&&(delete n[t.name],c.name=t.name)),c}return{verified:!0,result:n}}if(t.primitiveSchema&&On in e.valueBlock){const s=Rt(e.valueBlock.valueHexView);if(s.offset===-1){const o={verified:!1,result:s.result};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Z),t.name&&(delete n[t.name],o.name=t.name)),o}return at(n,s.result,t.primitiveSchema)}return{verified:!0,result:n}}function Jo(n,e){if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const t=Rt(v.toUint8Array(n));return t.offset===-1?{verified:!1,result:t.result}:at(t.result,t.result,e)}var Ks=Object.freeze({__proto__:null,Any:ot,BaseBlock:q,BaseStringBlock:Li,BitString:Gr,BmpString:Wr,Boolean:Fr,CharacterString:si,Choice:Wi,Constructed:Q,DATE:Fi,DateTime:Gi,Duration:ji,EndOfContent:Hi,Enumerated:jr,GeneralString:ni,GeneralizedTime:oi,GraphicString:ii,HexBlock:ke,IA5String:ri,Integer:ce,Null:st,NumericString:Zr,ObjectIdentifier:zr,OctetString:Jr,Primitive:mr,PrintableString:Qr,RawData:Fo,RelativeObjectIdentifier:$i,Repeated:ai,Sequence:Ve,Set:Re,TIME:zi,TeletexString:ei,TimeOfDay:Ji,UTCTime:wr,UniversalString:Yr,Utf8String:Xe,ValueBlock:j,VideotexString:ti,ViewWriter:qr,VisibleString:vr,compareSchema:at,fromBER:Xt,verifySchema:Jo}),F;(function(n){n[n.Sequence=0]="Sequence",n[n.Set=1]="Set",n[n.Choice=2]="Choice"})(F||(F={}));var w;(function(n){n[n.Any=1]="Any",n[n.Boolean=2]="Boolean",n[n.OctetString=3]="OctetString",n[n.BitString=4]="BitString",n[n.Integer=5]="Integer",n[n.Enumerated=6]="Enumerated",n[n.ObjectIdentifier=7]="ObjectIdentifier",n[n.Utf8String=8]="Utf8String",n[n.BmpString=9]="BmpString",n[n.UniversalString=10]="UniversalString",n[n.NumericString=11]="NumericString",n[n.PrintableString=12]="PrintableString",n[n.TeletexString=13]="TeletexString",n[n.VideotexString=14]="VideotexString",n[n.IA5String=15]="IA5String",n[n.GraphicString=16]="GraphicString",n[n.VisibleString=17]="VisibleString",n[n.GeneralString=18]="GeneralString",n[n.CharacterString=19]="CharacterString",n[n.UTCTime=20]="UTCTime",n[n.GeneralizedTime=21]="GeneralizedTime",n[n.DATE=22]="DATE",n[n.TimeOfDay=23]="TimeOfDay",n[n.DateTime=24]="DateTime",n[n.Duration=25]="Duration",n[n.TIME=26]="TIME",n[n.Null=27]="Null"})(w||(w={}));const Go={fromASN:n=>n instanceof st?null:n.valueBeforeDecodeView,toASN:n=>{if(n===null)return new st;const e=Xt(n);if(e.result.error)throw new Error(e.result.error);return e.result}},Yi={fromASN:n=>n.valueBlock.valueHexView.byteLength>=4?n.valueBlock.toString():n.valueBlock.valueDec,toASN:n=>new ce({value:+n})},jo={fromASN:n=>n.valueBlock.valueDec,toASN:n=>new jr({value:n})},zo={fromASN:n=>n.valueBlock.valueHexView,toASN:n=>new Gr({valueHex:n})},Wo={fromASN:n=>n.valueBlock.toString(),toASN:n=>new zr({value:n})},Yo={fromASN:n=>n.valueBlock.value,toASN:n=>new Fr({value:n})},Zo={fromASN:n=>n.valueBlock.valueHexView,toASN:n=>new Jr({valueHex:n})};function le(n){return{fromASN:e=>e.valueBlock.value,toASN:e=>new n({value:e})}}const Qo=le(Xe),ea=le(Wr),ta=le(Yr),ra=le(Zr),ia=le(Qr),na=le(ei),sa=le(ti),oa=le(ri),aa=le(ii),ca=le(vr),la=le(ni),ua=le(si),ha={fromASN:n=>n.toDate(),toASN:n=>new wr({valueDate:n})},fa={fromASN:n=>n.toDate(),toASN:n=>new oi({valueDate:n})},da={fromASN:()=>null,toASN:()=>new st};function Zi(n){switch(n){case w.Any:return Go;case w.BitString:return zo;case w.BmpString:return ea;case w.Boolean:return Yo;case w.CharacterString:return ua;case w.Enumerated:return jo;case w.GeneralString:return la;case w.GeneralizedTime:return fa;case w.GraphicString:return aa;case w.IA5String:return oa;case w.Integer:return Yi;case w.Null:return da;case w.NumericString:return ra;case w.ObjectIdentifier:return Wo;case w.OctetString:return Zo;case w.PrintableString:return ia;case w.TeletexString:return na;case w.UTCTime:return ha;case w.UniversalString:return ta;case w.Utf8String:return Qo;case w.VideotexString:return sa;case w.VisibleString:return ca;default:return null}}function Le(n){return typeof n=="function"&&n.prototype?n.prototype.toASN&&n.prototype.fromASN?!0:Le(n.prototype):!!(n&&typeof n=="object"&&"toASN"in n&&"fromASN"in n)}function Ps(n){var e;if(n){const t=Object.getPrototypeOf(n);return((e=t==null?void 0:t.prototype)===null||e===void 0?void 0:e.constructor)===Array?!0:Ps(t)}return!1}function ya(n,e){if(!(n&&e)||n.byteLength!==e.byteLength)return!1;const t=new Uint8Array(n),r=new Uint8Array(e);for(let i=0;i<n.byteLength;i++)if(t[i]!==r[i])return!1;return!0}class ga{constructor(){this.items=new WeakMap}has(e){return this.items.has(e)}get(e,t=!1){const r=this.items.get(e);if(!r)throw new Error(`Cannot get schema for '${e.prototype.constructor.name}' target`);if(t&&!r.schema)throw new Error(`Schema '${e.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);return r}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const t={type:F.Sequence,items:{}},r=this.findParentSchema(e);return r&&(Object.assign(t,r),t.items=Object.assign({},t.items,r.items)),t}create(e,t){const r=this.items.get(e)||this.createDefault(e),i=[];for(const s in r.items){const o=r.items[s],a=t?s:"";let c;if(typeof o.type=="number"){const d=w[o.type],f=Ks[d];if(!f)throw new Error(`Cannot get ASN1 class by name '${d}'`);c=new f({name:a})}else Le(o.type)?c=new o.type().toSchema(a):o.optional?this.get(o.type).type===F.Choice?c=new ot({name:a}):(c=this.create(o.type,!1),c.name=a):c=new ot({name:a});const h=!!o.optional||o.defaultValue!==void 0;if(o.repeated){c.name="";const d=o.repeated==="set"?Re:Ve;c=new d({name:"",value:[new ai({name:a,value:c})]})}if(o.context!==null&&o.context!==void 0)if(o.implicit)if(typeof o.type=="number"||Le(o.type)){const d=o.repeated?Q:mr;i.push(new d({name:a,optional:h,idBlock:{tagClass:3,tagNumber:o.context}}))}else{this.cache(o.type);const d=!!o.repeated;let f=d?c:this.get(o.type,!0).schema;f="valueBlock"in f?f.valueBlock.value:f.value,i.push(new Q({name:d?"":a,optional:h,idBlock:{tagClass:3,tagNumber:o.context},value:f}))}else i.push(new Q({optional:h,idBlock:{tagClass:3,tagNumber:o.context},value:[c]}));else c.optional=h,i.push(c)}switch(r.type){case F.Sequence:return new Ve({value:i,name:""});case F.Set:return new Re({value:i,name:""});case F.Choice:return new Wi({value:i,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=Object.getPrototypeOf(e);return t?this.items.get(t)||this.findParentSchema(t):null}}const ue=new ga,Er=n=>e=>{let t;ue.has(e)?t=ue.get(e):(t=ue.createDefault(e),ue.set(e,t)),Object.assign(t,n)},x=n=>(e,t)=>{let r;ue.has(e.constructor)?r=ue.get(e.constructor):(r=ue.createDefault(e.constructor),ue.set(e.constructor,r));const i=Object.assign({},n);if(typeof i.type=="number"&&!i.converter){const s=Zi(n.type);if(!s)throw new Error(`Cannot get default converter for property '${t}' of ${e.constructor.name}`);i.converter=s}r.items[t]=i};class Os extends Error{constructor(){super(...arguments),this.schemas=[]}}class pa{static parse(e,t){const r=Xt(e);if(r.result.error)throw new Error(r.result.error);return this.fromASN(r.result,t)}static fromASN(e,t){var r;try{if(Le(t))return new t().fromASN(e);const i=ue.get(t);ue.cache(t);let s=i.schema;if(e.constructor===Q&&i.type!==F.Choice){s=new Q({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:i.schema.valueBlock.value});for(const c in i.items)delete e[c]}const o=at({},e,s);if(!o.verified)throw new Os(`Data does not match to ${t.name} ASN1 schema. ${o.result.error}`);const a=new t;if(Ps(t)){if(!("value"in e.valueBlock&&Array.isArray(e.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const c=i.itemType;if(typeof c=="number"){const h=Zi(c);if(!h)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);return t.from(e.valueBlock.value,d=>h.fromASN(d))}else return t.from(e.valueBlock.value,h=>this.fromASN(h,c))}for(const c in i.items){const h=o.result[c];if(!h)continue;const d=i.items[c],f=d.type;if(typeof f=="number"||Le(f)){const b=(r=d.converter)!==null&&r!==void 0?r:Le(f)?new f:null;if(!b)throw new Error("Converter is empty");if(d.repeated)if(d.implicit){const B=d.repeated==="sequence"?Ve:Re,X=new B;X.valueBlock=h.valueBlock;const xe=Xt(X.toBER(!1));if(xe.offset===-1)throw new Error(`Cannot parse the child item. ${xe.result.error}`);if(!("value"in xe.result.valueBlock&&Array.isArray(xe.result.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const E=xe.result.valueBlock.value;a[c]=Array.from(E,k=>b.fromASN(k))}else a[c]=Array.from(h,B=>b.fromASN(B));else{let B=h;if(d.implicit){let X;if(Le(f))X=new f().toSchema("");else{const xe=w[f],E=Ks[xe];if(!E)throw new Error(`Cannot get '${xe}' class from asn1js module`);X=new E}X.valueBlock=B.valueBlock,B=Xt(X.toBER(!1)).result}a[c]=b.fromASN(B)}}else if(d.repeated){if(!Array.isArray(h))throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");a[c]=Array.from(h,b=>this.fromASN(b,f))}else a[c]=this.fromASN(h,f)}return a}catch(i){throw i instanceof Os&&i.schemas.push(t.name),i}}}class ci{static serialize(e){return e instanceof q?e.toBER(!1):this.toASN(e).toBER(!1)}static toASN(e){if(e&&typeof e=="object"&&Le(e))return e.toASN();if(!(e&&typeof e=="object"))throw new TypeError("Parameter 1 should be type of Object.");const t=e.constructor,r=ue.get(t);ue.cache(t);let i=[];if(r.itemType){if(!Array.isArray(e))throw new TypeError("Parameter 1 should be type of Array.");if(typeof r.itemType=="number"){const o=Zi(r.itemType);if(!o)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);i=e.map(a=>o.toASN(a))}else i=e.map(o=>this.toAsnItem({type:r.itemType},"[]",t,o))}else for(const o in r.items){const a=r.items[o],c=e[o];if(c===void 0||a.defaultValue===c||typeof a.defaultValue=="object"&&typeof c=="object"&&ya(this.serialize(a.defaultValue),this.serialize(c)))continue;const h=ci.toAsnItem(a,o,t,c);if(typeof a.context=="number")if(a.implicit)if(!a.repeated&&(typeof a.type=="number"||Le(a.type))){const d={};d.valueHex=h instanceof st?h.valueBeforeDecodeView:h.valueBlock.toBER(),i.push(new mr({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},...d}))}else i.push(new Q({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:h.valueBlock.value}));else i.push(new Q({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:[h]}));else a.repeated?i=i.concat(h):i.push(h)}let s;switch(r.type){case F.Sequence:s=new Ve({value:i});break;case F.Set:s=new Re({value:i});break;case F.Choice:if(!i[0])throw new Error(`Schema '${t.name}' has wrong data. Choice cannot be empty.`);s=i[0];break}return s}static toAsnItem(e,t,r,i){let s;if(typeof e.type=="number"){const o=e.converter;if(!o)throw new Error(`Property '${t}' doesn't have converter for type ${w[e.type]} in schema '${r.name}'`);if(e.repeated){if(!Array.isArray(i))throw new TypeError("Parameter 'objProp' should be type of Array.");const a=Array.from(i,h=>o.toASN(h)),c=e.repeated==="sequence"?Ve:Re;s=new c({value:a})}else s=o.toASN(i)}else if(e.repeated){if(!Array.isArray(i))throw new TypeError("Parameter 'objProp' should be type of Array.");const o=Array.from(i,c=>this.toASN(c)),a=e.repeated==="sequence"?Ve:Re;s=new a({value:o})}else s=this.toASN(i);return s}}class Qi{static serialize(e){return ci.serialize(e)}static parse(e,t){return pa.parse(e,t)}static toString(e){const t=v.isBufferSource(e)?v.toArrayBuffer(e):Qi.serialize(e),r=Xt(t);if(r.offset===-1)throw new Error(`Cannot decode ASN.1 data. ${r.result.error}`);return r.result.toString()}}class ma extends Error{constructor(e,t){super(t?`${e}. See the inner exception for more details.`:e),this.message=e,this.innerError=t}}class Ge extends ma{}var z;(function(n){n[n.Any=0]="Any",n[n.Boolean=1]="Boolean",n[n.Number=2]="Number",n[n.String=3]="String"})(z||(z={}));function va(n,e){switch(e){case z.Boolean:return typeof n=="boolean";case z.Number:return typeof n=="number";case z.String:return typeof n=="string"}return!0}function en(n,e){if(!va(n,e))throw new TypeError(`Value must be ${z[e]}`)}function Ts(n){return n&&n.prototype?n.prototype.toJSON&&n.prototype.fromJSON?!0:Ts(n.prototype):!!(n&&n.toJSON&&n.fromJSON)}class wa{constructor(){this.items=new Map}has(e){return this.items.has(e)||!!this.findParentSchema(e)}get(e){const t=this.items.get(e)||this.findParentSchema(e);if(!t)throw new Error("Cannot get schema for current target");return t}create(e){const t={names:{}},r=this.findParentSchema(e);if(r){Object.assign(t,r),t.names={};for(const i in r.names)t.names[i]=Object.assign({},r.names[i])}return t.target=e,t}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;return t?this.items.get(t)||this.findParentSchema(t):null}}const Ea="default",ct=new wa;class Aa{constructor(e){this.pattern=new RegExp(e)}validate(e){const t=new RegExp(this.pattern.source,this.pattern.flags);if(typeof e!="string")throw new Ge("Incoming value must be string");if(!t.exec(e))throw new Ge(`Value doesn't match to pattern '${t.toString()}'`)}}class ba{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(en(e,z.Number),!(this.min<=e&&e<=this.max)){const t=this.min===Number.MIN_VALUE?"MIN":this.min,r=this.max===Number.MAX_VALUE?"MAX":this.max;throw new Ge(`Value doesn't match to diapason [${t},${r}]`)}}}class Ia{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(en(e,z.Number),!(this.min<e&&e<this.max)){const t=this.min===Number.MIN_VALUE?"MIN":this.min,r=this.max===Number.MAX_VALUE?"MAX":this.max;throw new Ge(`Value doesn't match to diapason (${t},${r})`)}}}class Na{constructor(e,t,r){this.length=e,this.minLength=t,this.maxLength=r}validate(e){if(this.length!==void 0){if(e.length!==this.length)throw new Ge(`Value length must be exactly ${this.length}.`);return}if(this.minLength!==void 0&&e.length<this.minLength)throw new Ge(`Value length must be more than ${this.minLength}.`);if(this.maxLength!==void 0&&e.length>this.maxLength)throw new Ge(`Value length must be less than ${this.maxLength}.`)}}class ka{constructor(e){this.enumeration=e}validate(e){if(en(e,z.String),!this.enumeration.includes(e))throw new Ge(`Value must be one of ${this.enumeration.map(t=>`'${t}'`).join(", ")}`)}}function Ba(n){const e=[];return n.pattern&&e.push(new Aa(n.pattern)),(n.type===z.Number||n.type===z.Any)&&((n.minInclusive!==void 0||n.maxInclusive!==void 0)&&e.push(new ba(n.minInclusive,n.maxInclusive)),(n.minExclusive!==void 0||n.maxExclusive!==void 0)&&e.push(new Ia(n.minExclusive,n.maxExclusive)),n.enumeration!==void 0&&e.push(new ka(n.enumeration))),(n.type===z.String||n.repeated||n.type===z.Any)&&(n.length!==void 0||n.minLength!==void 0||n.maxLength!==void 0)&&e.push(new Na(n.length,n.minLength,n.maxLength)),e}const pe=(n={})=>(e,t)=>{const r=`Cannot set type for ${t} property of ${e.constructor.name} schema`;let i;ct.has(e.constructor)?(i=ct.get(e.constructor),i.target!==e.constructor&&(i=ct.create(e.constructor),ct.set(e.constructor,i))):(i=ct.create(e.constructor),ct.set(e.constructor,i));const s={type:z.Any,validations:[]},o=Object.assign(s,n);if(o.validations=Ba(o),typeof o.type!="number"&&!ct.has(o.type)&&!Ts(o.type))throw new Error(`${r}. Assigning type doesn't have schema.`);let a;Array.isArray(n.schema)?a=n.schema:a=[n.schema||Ea];for(const c of a){i.names[c]||(i.names[c]={});const h=i.names[c];h[t]=o}};/*!
 Copyright (c) Peculiar Ventures, LLC
*/class Us extends Error{}class Sa extends Us{}class Vs{static toArrayBuffer(e){const t=e.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace(`
`,"");return y.FromBase64(t)}static toUint8Array(e){const t=this.toArrayBuffer(e);return new Uint8Array(t)}static fromBufferSource(e,t){const r=y.ToBase64(e);let i,s=0;const o=[];for(;i=r.slice(s,s=s+64),i.length;)if(o.push(i),i.length<64)break;const a=t.toUpperCase();return`-----BEGIN ${a}-----
${o.join(`
`)}
-----END ${a}-----`}static isPEM(e){return/-----BEGIN .+-----[A-Za-z0-9+\/\+\=\s\n]+-----END .+-----/i.test(e)}static getTagName(e){if(!this.isPEM(e))throw new Error("Bad parameter. Incoming data is not right PEM");const t=/-----BEGIN (.+)-----/.exec(e);if(!t)throw new Error("Cannot get tag from PEM");return t[1]}static hasTagName(e,t){const r=this.getTagName(e);return t.toLowerCase()===r.toLowerCase()}static isCertificate(e){return this.hasTagName(e,"certificate")}static isCertificateRequest(e){return this.hasTagName(e,"certificate request")}static isCRL(e){return this.hasTagName(e,"x509 crl")}static isPublicKey(e){return this.hasTagName(e,"public key")}}const xa=["secret","private","public"];class Ca{static create(e,t,r,i){const s=new this;return s.algorithm=e,s.type=t,s.extractable=r,s.usages=i,s}static isKeyType(e){return xa.indexOf(e)!==-1}get[Symbol.toStringTag](){return"CryptoKey"}}let li=class{constructor(e){e&&(this.value=e)}};l([x({type:w.ObjectIdentifier})],li.prototype,"value",void 0),li=l([Er({type:F.Choice})],li);class Lt{constructor(e){Object.assign(this,e)}}l([x({type:w.ObjectIdentifier})],Lt.prototype,"algorithm",void 0),l([x({type:w.Any,optional:!0})],Lt.prototype,"parameters",void 0);class Ar{constructor(){this.version=0,this.privateKeyAlgorithm=new Lt,this.privateKey=new ArrayBuffer(0)}}l([x({type:w.Integer})],Ar.prototype,"version",void 0),l([x({type:Lt})],Ar.prototype,"privateKeyAlgorithm",void 0),l([x({type:w.OctetString})],Ar.prototype,"privateKey",void 0),l([x({type:w.Any,optional:!0})],Ar.prototype,"attributes",void 0);class Rs{constructor(){this.publicKeyAlgorithm=new Lt,this.publicKey=new ArrayBuffer(0)}}l([x({type:Lt})],Rs.prototype,"publicKeyAlgorithm",void 0),l([x({type:w.BitString})],Rs.prototype,"publicKey",void 0);const me={fromJSON:n=>y.FromBase64Url(n),toJSON:n=>y.ToBase64Url(new Uint8Array(n))},Be={fromASN:n=>{const e=n.valueBlock.valueHex;return new Uint8Array(e)[0]?n.valueBlock.valueHex:n.valueBlock.valueHex.slice(1)},toASN:n=>{const e=new Uint8Array(n)[0]>127?ht(new Uint8Array([0]).buffer,n):n;return new ce({valueHex:e})}};class Se{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}l([x({type:w.Integer,converter:Yi})],Se.prototype,"version",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"n",converter:me})],Se.prototype,"modulus",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"e",converter:me})],Se.prototype,"publicExponent",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"d",converter:me})],Se.prototype,"privateExponent",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"p",converter:me})],Se.prototype,"prime1",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"q",converter:me})],Se.prototype,"prime2",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"dp",converter:me})],Se.prototype,"exponent1",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"dq",converter:me})],Se.prototype,"exponent2",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"qi",converter:me})],Se.prototype,"coefficient",void 0),l([x({type:w.Any,optional:!0})],Se.prototype,"otherPrimeInfos",void 0);class Xs{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}l([x({type:w.Integer,converter:Be}),pe({name:"n",converter:me})],Xs.prototype,"modulus",void 0),l([x({type:w.Integer,converter:Be}),pe({name:"e",converter:me})],Xs.prototype,"publicExponent",void 0);let br=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){let e=new Uint8Array(this.value);if(e[0]!==4)throw new Us("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");e=new Uint8Array(this.value.slice(1));const t=e.length/2,r=0;return{x:y.ToBase64Url(e.buffer.slice(r,r+t)),y:y.ToBase64Url(e.buffer.slice(r+t,r+t+t))}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");if(!("y"in e))throw new Error("y: Missing required property");const t=y.FromBase64Url(e.x),r=y.FromBase64Url(e.y),i=ht(new Uint8Array([4]).buffer,t,r);return this.value=new Uint8Array(i).buffer,this}};l([x({type:w.OctetString})],br.prototype,"value",void 0),br=l([Er({type:F.Choice})],br);class ui{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(e){if(!("d"in e))throw new Error("d: Missing required property");if(this.privateKey=y.FromBase64Url(e.d),"x"in e){const t=new br;t.fromJSON(e);const r=ci.toASN(t);"valueHex"in r.valueBlock&&(this.publicKey=r.valueBlock.valueHex)}return this}toJSON(){const e={};return e.d=y.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(e,new br(this.publicKey).toJSON()),e}}l([x({type:w.Integer,converter:Yi})],ui.prototype,"version",void 0),l([x({type:w.OctetString})],ui.prototype,"privateKey",void 0),l([x({context:0,type:w.Any,optional:!0})],ui.prototype,"parameters",void 0),l([x({context:1,type:w.BitString,optional:!0})],ui.prototype,"publicKey",void 0);const Ls={fromASN:n=>{const e=new Uint8Array(n.valueBlock.valueHex);return e[0]===0?e.buffer.slice(1):e.buffer},toASN:n=>{const e=new Uint8Array(n);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new ce({valueHex:t.buffer})}return new ce({valueHex:n})}};class Hs{static decodePoint(e,t){const r=v.toUint8Array(e);if(r.length===0||r[0]!==4)throw new Error("Only uncompressed point format supported");const i=(r.length-1)/2;if(i!==Math.ceil(t/8))throw new Error("Point does not match field size");const s=r.slice(1,i+1),o=r.slice(i+1,i+1+i);return{x:s,y:o}}static encodePoint(e,t){const r=Math.ceil(t/8);if(e.x.byteLength!==r||e.y.byteLength!==r)throw new Error("X,Y coordinates don't match point size criteria");const i=v.toUint8Array(e.x),s=v.toUint8Array(e.y),o=new Uint8Array(r*2+1);return o[0]=4,o.set(i,1),o.set(s,r+1),o}static getSize(e){return Math.ceil(e/8)}static encodeSignature(e,t){const r=this.getSize(t),i=v.toUint8Array(e.r),s=v.toUint8Array(e.s),o=new Uint8Array(r*2);return o.set(this.padStart(i,r)),o.set(this.padStart(s,r),r),o}static decodeSignature(e,t){const r=this.getSize(t),i=v.toUint8Array(e);if(i.length!==r*2)throw new Error("Incorrect size of the signature");const s=i.slice(0,r),o=i.slice(r);return{r:this.trimStart(s),s:this.trimStart(o)}}static trimStart(e){let t=0;for(;t<e.length-1&&e[t]===0;)t++;return t===0?e:e.slice(t,e.length)}static padStart(e,t){if(t===e.length)return e;const r=new Uint8Array(t);return r.set(e,t-e.length),r}}class hi{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(e){const t=e.byteLength/2,r=Hs.decodeSignature(e,t*8),i=new hi;return i.r=v.toArrayBuffer(r.r),i.s=v.toArrayBuffer(r.s),i}toWebCryptoSignature(e){return e??(e=Math.max(this.r.byteLength,this.s.byteLength)*8),Hs.encodeSignature(this,e).buffer}}l([x({type:w.Integer,converter:Ls})],hi.prototype,"r",void 0),l([x({type:w.Integer,converter:Ls})],hi.prototype,"s",void 0);class Da extends Ar{}l([x({context:1,implicit:!0,type:w.BitString,optional:!0})],Da.prototype,"publicKey",void 0);let tn=class{constructor(){this.value=new ArrayBuffer(0)}fromJSON(e){if(!e.d)throw new Error("d: Missing required property");return this.value=y.FromBase64Url(e.d),this}toJSON(){return{d:y.ToBase64Url(this.value)}}};l([x({type:w.OctetString})],tn.prototype,"value",void 0),tn=l([Er({type:F.Choice})],tn);let rn=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){return{x:y.ToBase64Url(this.value)}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");return this.value=y.FromBase64Url(e.x),this}};l([x({type:w.BitString})],rn.prototype,"value",void 0),rn=l([Er({type:F.Choice})],rn);let nn=class{};l([x({type:w.OctetString}),pe({type:z.String,converter:me})],nn.prototype,"d",void 0),nn=l([Er({type:F.Choice})],nn);const Ka="1.2.840.10045.3.1.7",sn="1.3.132.0",Pa=`${sn}.34`,Oa=`${sn}.35`,Ta=`${sn}.10`,ee="1.3.36.3.3.2.8.1.1",Ua=`${ee}.1`,Va=`${ee}.2`,Ra=`${ee}.3`,Xa=`${ee}.4`,La=`${ee}.5`,Ha=`${ee}.6`,_a=`${ee}.7`,Ma=`${ee}.8`,qa=`${ee}.9`,$a=`${ee}.10`,Fa=`${ee}.11`,Ja=`${ee}.12`,Ga=`${ee}.13`,ja=`${ee}.14`;class H{constructor(){}static register(e){const t=new li;t.value=e.id;const r=Qi.serialize(t);this.items.push({...e,raw:r}),this.names.push(e.name)}static find(e){e=e.toUpperCase();for(const t of this.items)if(t.name.toUpperCase()===e||t.id.toUpperCase()===e)return t;return null}static get(e){const t=this.find(e);if(!t)throw new Error(`Unsupported EC named curve '${e}'`);return t}}H.items=[],H.names=[],H.register({name:"P-256",id:Ka,size:256}),H.register({name:"P-384",id:Pa,size:384}),H.register({name:"P-521",id:Oa,size:521}),H.register({name:"K-256",id:Ta,size:256}),H.register({name:"brainpoolP160r1",id:Ua,size:160}),H.register({name:"brainpoolP160t1",id:Va,size:160}),H.register({name:"brainpoolP192r1",id:Ra,size:192}),H.register({name:"brainpoolP192t1",id:Xa,size:192}),H.register({name:"brainpoolP224r1",id:La,size:224}),H.register({name:"brainpoolP224t1",id:Ha,size:224}),H.register({name:"brainpoolP256r1",id:_a,size:256}),H.register({name:"brainpoolP256t1",id:Ma,size:256}),H.register({name:"brainpoolP320r1",id:qa,size:320}),H.register({name:"brainpoolP320t1",id:$a,size:320}),H.register({name:"brainpoolP384r1",id:Fa,size:384}),H.register({name:"brainpoolP384t1",id:Ja,size:384}),H.register({name:"brainpoolP512r1",id:Ga,size:512}),H.register({name:"brainpoolP512t1",id:ja,size:512});class za{get[Symbol.toStringTag](){return"Crypto"}randomUUID(){const e=this.getRandomValues(new Uint8Array(16));e[6]=e[6]&15|64,e[8]=e[8]&63|128;const t=y.ToHex(e).toLowerCase();return`${t.substring(0,8)}-${t.substring(8,12)}-${t.substring(12,16)}-${t.substring(16,20)}-${t.substring(20)}`}}class Wa{constructor(){this.items={}}get(e){return this.items[e.toLowerCase()]||null}set(e){this.items[e.name.toLowerCase()]=e}removeAt(e){const t=this.get(e.toLowerCase());return t&&delete this.items[e],t}has(e){return!!this.get(e)}get length(){return Object.keys(this.items).length}get algorithms(){const e=[];for(const t in this.items){const r=this.items[t];e.push(r.name)}return e.sort()}}let Ya=class js{constructor(){this.providers=new Wa}static isHashedAlgorithm(e){return!!(e&&typeof e=="object"&&"name"in e&&"hash"in e)}get[Symbol.toStringTag](){return"SubtleCrypto"}async digest(...e){this.checkRequiredArguments(e,2,"digest");const[t,r,...i]=e,s=this.prepareAlgorithm(t),o=v.toArrayBuffer(r);return await this.getProvider(s.name).digest(s,o,...i)}async generateKey(...e){this.checkRequiredArguments(e,3,"generateKey");const[t,r,i,...s]=e,o=this.prepareAlgorithm(t),a=this.getProvider(o.name);return await a.generateKey({...o,name:a.name},r,i,...s)}async sign(...e){this.checkRequiredArguments(e,3,"sign");const[t,r,i,...s]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=v.toArrayBuffer(i),c=this.getProvider(o.name);return await c.sign({...o,name:c.name},r,a,...s)}async verify(...e){this.checkRequiredArguments(e,4,"verify");const[t,r,i,s,...o]=e;this.checkCryptoKey(r);const a=this.prepareAlgorithm(t),c=v.toArrayBuffer(s),h=v.toArrayBuffer(i),d=this.getProvider(a.name);return await d.verify({...a,name:d.name},r,h,c,...o)}async encrypt(...e){this.checkRequiredArguments(e,3,"encrypt");const[t,r,i,...s]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=v.toArrayBuffer(i),c=this.getProvider(o.name);return await c.encrypt({...o,name:c.name},r,a,{keyUsage:!0},...s)}async decrypt(...e){this.checkRequiredArguments(e,3,"decrypt");const[t,r,i,...s]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=v.toArrayBuffer(i),c=this.getProvider(o.name);return await c.decrypt({...o,name:c.name},r,a,{keyUsage:!0},...s)}async deriveBits(...e){this.checkRequiredArguments(e,3,"deriveBits");const[t,r,i,...s]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=this.getProvider(o.name);return await a.deriveBits({...o,name:a.name},r,i,{keyUsage:!0},...s)}async deriveKey(...e){this.checkRequiredArguments(e,5,"deriveKey");const[t,r,i,s,o,...a]=e,c=this.prepareAlgorithm(i);this.getProvider(c.name).checkDerivedKeyParams(c);const d=this.prepareAlgorithm(t),f=this.getProvider(d.name);f.checkCryptoKey(r,"deriveKey");const b=await f.deriveBits({...d,name:f.name},r,i.length||512,{keyUsage:!1},...a);return this.importKey("raw",b,i,s,o,...a)}async exportKey(...e){this.checkRequiredArguments(e,2,"exportKey");const[t,r,...i]=e;return this.checkCryptoKey(r),await this.getProvider(r.algorithm.name).exportKey(t,r,...i)}async importKey(...e){this.checkRequiredArguments(e,5,"importKey");const[t,r,i,s,o,...a]=e,c=this.prepareAlgorithm(i),h=this.getProvider(c.name);if(["pkcs8","spki","raw"].indexOf(t)!==-1){const d=v.toArrayBuffer(r);return h.importKey(t,d,{...c,name:h.name},s,o,...a)}else if(!r.kty)throw new TypeError("keyData: Is not JSON");return h.importKey(t,r,{...c,name:h.name},s,o,...a)}async wrapKey(e,t,r,i,...s){let o=await this.exportKey(e,t,...s);if(e==="jwk"){const d=JSON.stringify(o);o=y.FromUtf8String(d)}const a=this.prepareAlgorithm(i),c=v.toArrayBuffer(o),h=this.getProvider(a.name);return h.encrypt({...a,name:h.name},r,c,{keyUsage:!1},...s)}async unwrapKey(e,t,r,i,s,o,a,...c){const h=this.prepareAlgorithm(i),d=v.toArrayBuffer(t),f=this.getProvider(h.name);let b=await f.decrypt({...h,name:f.name},r,d,{keyUsage:!1},...c);if(e==="jwk")try{b=JSON.parse(y.ToUtf8String(b))}catch(B){const X=new TypeError("wrappedKey: Is not a JSON");throw X.internal=B,X}return this.importKey(e,b,s,o,a,...c)}checkRequiredArguments(e,t,r){if(e.length<t)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${t} arguments required, but only ${e.length} present`)}prepareAlgorithm(e){if(typeof e=="string")return{name:e};if(js.isHashedAlgorithm(e)){const t={...e};return t.hash=this.prepareAlgorithm(e.hash),t}return{...e}}getProvider(e){const t=this.providers.get(e);if(!t)throw new Sa("Unrecognized name");return t}checkCryptoKey(e){if(!(e instanceof Ca))throw new TypeError("Key is not of type 'CryptoKey'")}};function sc(n){return n}function Za(n){return n instanceof Object&&"name"in n&&"hash"in n}function W(n){if(n instanceof A)return n;const e=new A;if(typeof n=="string")e.fromAlgorithm({name:n});else if(Za(n)){const t={...n};t.hash=W(n.hash),e.fromAlgorithm(t)}else e.fromAlgorithm({...n});return e}function Qa(n){return n instanceof N}function ec(n){return n instanceof V}function te(n,e){if(!(n&&(typeof n=="object"||typeof n=="string")))throw new TypeError(`${e}: Is wrong type. Must be Object or String`);if(typeof n=="object"&&!("name"in n))throw new TypeError(`${e}: Required property 'name' is missed`)}function ne(n,e){if(!Qa(n))throw new TypeError(`${e}: Is not type CryptoKey`)}function fi(n,e){if(!ec(n))throw new TypeError(`${e}: Is not type CryptoCertificate`)}function je(n,e){if(!v.isBufferSource(n))throw new TypeError(`${e}: Is wrong type. Must be ArrayBuffer or ArrayBuffer view`)}function lt(n,e){if(!Array.isArray(n))throw new TypeError(`${e}: Is not type Array`)}function _(n,e,t){if(typeof n!==e)throw new TypeError(`${t}: Is not type '${e}'`)}const _s=["raw","pem","x509","request"];class Ms{static isX509Certificate(e){return e instanceof be}static isCertificateRequest(e){return e instanceof vt}constructor(e){this.provider=e}async indexOf(e){fi(e,"item");const t=new bt;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return r?y.ToUtf8String(r):null}async hasItem(e){return!!await this.indexOf(e)}async exportCert(e,t){_(e,"string","format"),fi(t,"item");const r=new Qe;r.providerID=this.provider.id,r.format="raw",r.item=t;const i=await this.provider.client.send(r);if(e==="raw")return i;{let s="";switch(t.type){case"x509":{s="CERTIFICATE";break}case"request":{s="CERTIFICATE REQUEST";break}default:throw new Error("Cannot create PEM for unknown type of certificate item")}return Vs.fromBufferSource(i,s)}}async importCert(e,t,r,i){if(_(e,"string","format"),!~_s.indexOf(e))throw new TypeError(`format: Is invalid value. Must be ${_s.join(", ")}`);e==="pem"?_(t,"string","data"):je(t,"data"),te(r,"algorithm"),lt(i,"keyUsages");const s=W(r);let o;if(v.isBufferSource(t))o=v.toArrayBuffer(t);else if(typeof t=="string")o=Vs.toArrayBuffer(t);else throw new TypeError("data: Is not type String, ArrayBuffer or ArrayBufferView");const a=new De;a.providerID=this.provider.id,a.format="raw",a.data=o,a.algorithm=s,a.keyUsages=i;const c=await this.provider.client.send(a),h=await V.importProto(c);if((e==="request"||e==="x509")&&h.type!==e)throw new TypeError(`Imported item is not ${e}`);return this.prepareCertItem(h)}async keys(){const e=new rr;e.providerID=this.provider.id;const t=await this.provider.client.send(e);return t?y.ToUtf8String(t).split(","):[]}async getValue(e){_(e,"string","key");const t=new Et;t.providerID=this.provider.id,t.key=e;const r=await this.provider.client.send(t);return r||null}async getItem(e,t,r){_(e,"string","key"),t&&(te(t,"algorithm"),lt(r,"keyUsages"));const i=new Me;i.providerID=this.provider.id,i.key=e,t&&(i.algorithm=W(t),i.keyUsages=r);const s=await this.provider.client.send(i);if(s&&s.byteLength){const o=await V.importProto(s);return this.prepareCertItem(o)}throw new Error("Cannot get CryptoCertificate from storage by index")}async setItem(e){fi(e,"value");const t=new Ze;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return y.ToUtf8String(r)}async removeItem(e){_(e,"string","key");const t=new At;t.providerID=this.provider.id,t.key=e,await this.provider.client.send(t)}async clear(){const e=new ir;e.providerID=this.provider.id,await this.provider.client.send(e)}async getChain(e){fi(e,"value");const t=new It;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return(await tr.importProto(r)).items}async getCRL(e){_(e,"string","url");const t=new Nt;return t.providerID=this.provider.id,t.url=e,await this.provider.client.send(t)}async getOCSP(e,t,r){_(e,"string","url"),je(t,"request");const i=new qe;if(i.providerID=this.provider.id,i.url=e,i.request=v.toArrayBuffer(t),r)for(const o in r)i.options[o]=r[o];return await this.provider.client.send(i)}async findPrivateKey(e){let t=typeof e=="string"?e:await this.provider.certStorage.indexOf(e);t||(t="");const[,,r]=t.split("-"),i=(await this.provider.keyStorage.keys()).find(s=>{const[o,,a]=s.split("-");return o==="private"&&a===r});return i?await this.provider.keyStorage.getItem(i):null}async prepareCertItem(e){const t=await e.exportProto();let r;switch(e.type){case"x509":{r=await be.importProto(t);break}case"request":{r=await vt.importProto(t);break}default:throw new Error(`Unsupported CertificateItem type '${e.type}'`)}return r.provider=this.provider,r}}class qs{constructor(e){this.service=e}async keys(){const e=new nr;e.providerID=this.service.id;const t=await this.service.client.send(e);return t?y.ToUtf8String(t).split(","):[]}async indexOf(e){ne(e,"item");const t=new Ct;t.providerID=this.service.id,t.item=e;const r=await this.service.client.send(t);return r?y.ToUtf8String(r):null}async hasItem(e){return!!await this.indexOf(e)}async getItem(e,t,r,i){_(e,"string","key"),t&&(te(t,"algorithm"),_(r,"boolean","extractable"),lt(i,"usages"));const s=new Ke;s.providerID=this.service.id,s.key=e,t&&(s.algorithm=W(t),s.extractable=r,s.keyUsages=i);const o=await this.service.client.send(s);let a;if(o&&o.byteLength)a=await N.importProto(o);else throw new Error("Cannot get CryptoKey from key storage by index");return a}async setItem(e){ne(e,"value");const t=new St;t.providerID=this.service.id,t.item=e;const r=await this.service.client.send(t);return y.ToUtf8String(r)}async removeItem(e){_(e,"string","key");const t=new xt;t.providerID=this.service.id,t.key=e,await this.service.client.send(t)}async clear(){const e=new sr;e.providerID=this.service.id,await this.service.client.send(e)}}class tc extends Ya{constructor(e){super(),this.service=e}async encrypt(e,t,r){return this.encryptData(e,t,r,"encrypt")}async decrypt(e,t,r){return this.encryptData(e,t,r,"decrypt")}async deriveBits(e,t,r){te(e,"algorithm"),ne(t,"baseKey"),_(r,"number","length");const i=W(e);ne(i.public,"algorithm.public"),i.public=await i.public.exportProto();const s=new Fe;return s.providerID=this.service.id,s.algorithm=i,s.key=t,s.length=r,await this.service.client.send(s)}async deriveKey(e,t,r,i,s){te(e,"algorithm"),ne(t,"baseKey"),te(r,"algorithm"),_(i,"boolean","extractable"),lt(s,"keyUsages");const o=W(e);ne(o.public,"algorithm.public"),o.public=await o.public.exportProto();const a=W(r),c=new Ie;c.providerID=this.service.id,c.algorithm=o,c.derivedKeyType.fromAlgorithm(a),c.key=t,c.extractable=i,c.usage=s;const h=await this.service.client.send(c);return await N.importProto(h)}async digest(e,t){return I().crypto.subtle.digest(e,t)}async generateKey(e,t,r){te(e,"algorithm"),_(t,"boolean","extractable"),lt(r,"keyUsages");const i=W(e),s=new $e;s.providerID=this.service.id,s.algorithm=i,s.extractable=t,s.usage=r;const o=await this.service.client.send(s);try{return await dt.importProto(o)}catch{return await N.importProto(o)}}async exportKey(e,t){_(e,"string","format"),ne(t,"key");const r=new rt;r.providerID=this.service.id,r.format=e,r.key=t;const i=await this.service.client.send(r);return e==="jwk"?JSON.parse(y.ToBinary(i)):i}async importKey(e,t,r,i,s){_(e,"string","format"),te(r,"algorithm"),_(i,"boolean","extractable"),lt(s,"keyUsages");const o=W(r);let a;e==="jwk"?a=y.FromUtf8String(JSON.stringify(t)):(je(t,"keyData"),a=v.toArrayBuffer(t));const c=new Ne;c.providerID=this.service.id,c.algorithm=o,c.keyData=a,c.format=e,c.extractable=i,c.keyUsages=s;const h=await this.service.client.send(c);return await N.importProto(h)}async sign(e,t,r){te(e,"algorithm"),ne(t,"key"),je(r,"data");const i=W(e),s=v.toArrayBuffer(r),o=new Y;return o.providerID=this.service.id,o.algorithm=i,o.key=t,o.data=s,await this.service.client.send(o)}async verify(e,t,r,i){te(e,"algorithm"),ne(t,"key"),je(r,"signature"),je(i,"data");const s=W(e),o=v.toArrayBuffer(r),a=v.toArrayBuffer(i),c=new Ut;c.providerID=this.service.id,c.algorithm=s,c.key=t,c.data=a,c.signature=o;const h=await this.service.client.send(c);return!!new Uint8Array(h)[0]}async wrapKey(e,t,r,i){_(e,"string","format"),ne(t,"key"),ne(r,"wrappingKey"),te(i,"wrapAlgorithm");const s=W(i),o=new Te;return o.providerID=this.service.id,o.wrapAlgorithm=s,o.key=t,o.wrappingKey=r,o.format=e,await this.service.client.send(o)}async unwrapKey(e,t,r,i,s,o,a){_(e,"string","format"),je(t,"wrappedKey"),ne(r,"unwrappingKey"),te(i,"unwrapAlgorithm"),te(s,"unwrappedKeyAlgorithm"),_(o,"boolean","extractable"),lt(a,"keyUsages");const c=W(i),h=W(s),d=v.toArrayBuffer(t),f=new ae;f.providerID=this.service.id,f.format=e,f.unwrapAlgorithm=c,f.unwrappedKeyAlgorithm=h,f.unwrappingKey=r,f.wrappedKey=d,f.extractable=o,f.keyUsage=a;const b=await this.service.client.send(f);return await N.importProto(b)}async encryptData(e,t,r,i){te(e,"algorithm"),ne(t,"key"),je(r,"data");const s=W(e),o=v.toArrayBuffer(r);let a;i==="encrypt"?a=hr:a=fr;const c=new a;return c.providerID=this.service.id,c.algorithm=s,c.key=t,c.data=o,await this.service.client.send(c)}}class $s extends za{constructor(e,t){super(),this.client=e,this.id=t,this.subtle=new tc(this),this.keyStorage=new qs(this),this.certStorage=new Ms(this)}getRandomValues(e){return I().crypto.getRandomValues(e)}async login(){const e=new zt;return e.providerID=this.id,this.client.send(e)}async logout(){const e=new Wt;return e.providerID=this.id,this.client.send(e)}async reset(){const e=new Zt;return e.providerID=this.id,this.client.send(e)}async isLoggedIn(){const e=new Yt;e.providerID=this.id;const t=await this.client.send(e);return!!new Uint8Array(t)[0]}}class di extends D{get state(){return this.client.state}constructor(e){super(),this.client=new Do(e.storage),this.cardReader=new Io(this.client)}connect(e=di.FORTIFY,t){return this.removeAllListeners(),this.client.connect(e,t).on("error",r=>{this.emit("error",r.error)}).on("event",r=>{(async()=>{switch(r.action){case Pe.ACTION:{const i=await Pe.importProto(await r.exportProto());this.emit("token",i)}case Pt.ACTION:{const i=await Pt.importProto(await r.exportProto());this.emit("auth",i)}}})()}).on("listening",r=>{this.emit("listening",e)}).on("close",r=>{this.emit("close",r.remoteAddress)}),this}close(){this.client.close()}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async info(){const e=new ar,t=await this.client.send(e);return await Dt.importProto(t)}async challenge(){return this.client.challenge()}async isLoggedIn(){return this.client.isLoggedIn()}async login(){return this.client.login()}async getCrypto(e){const t=new Kt;return t.cryptoID=e,await this.client.send(t),new $s(this.client,e)}}di.FORTIFY="127.0.0.1:31337";class on{}function Fs(n,e){return e={exports:{}},n(e,e.exports),e.exports}var rc=Fs(function(n){(function(){function e(E){return Array.prototype.slice.call(E)}function t(E){return new Promise(function(k,P){E.onsuccess=function(){k(E.result)},E.onerror=function(){P(E.error)}})}function r(E,k,P){var U,C=new Promise(function(ve,Ir){U=E[k].apply(E,P),t(U).then(ve,Ir)});return C.request=U,C}function i(E,k,P){var U=r(E,k,P);return U.then(function(C){if(C)return new d(C,U.request)})}function s(E,k,P){P.forEach(function(U){Object.defineProperty(E.prototype,U,{get:function(){return this[k][U]},set:function(C){this[k][U]=C}})})}function o(E,k,P,U){U.forEach(function(C){C in P.prototype&&(E.prototype[C]=function(){return r(this[k],C,arguments)})})}function a(E,k,P,U){U.forEach(function(C){C in P.prototype&&(E.prototype[C]=function(){return this[k][C].apply(this[k],arguments)})})}function c(E,k,P,U){U.forEach(function(C){C in P.prototype&&(E.prototype[C]=function(){return i(this[k],C,arguments)})})}function h(E){this._index=E}s(h,"_index",["name","keyPath","multiEntry","unique"]),o(h,"_index",IDBIndex,["get","getKey","getAll","getAllKeys","count"]),c(h,"_index",IDBIndex,["openCursor","openKeyCursor"]);function d(E,k){this._cursor=E,this._request=k}s(d,"_cursor",["direction","key","primaryKey","value"]),o(d,"_cursor",IDBCursor,["update","delete"]),["advance","continue","continuePrimaryKey"].forEach(function(E){E in IDBCursor.prototype&&(d.prototype[E]=function(){var k=this,P=arguments;return Promise.resolve().then(function(){return k._cursor[E].apply(k._cursor,P),t(k._request).then(function(U){if(U)return new d(U,k._request)})})})});function f(E){this._store=E}f.prototype.createIndex=function(){return new h(this._store.createIndex.apply(this._store,arguments))},f.prototype.index=function(){return new h(this._store.index.apply(this._store,arguments))},s(f,"_store",["name","keyPath","indexNames","autoIncrement"]),o(f,"_store",IDBObjectStore,["put","add","delete","clear","get","getAll","getKey","getAllKeys","count"]),c(f,"_store",IDBObjectStore,["openCursor","openKeyCursor"]),a(f,"_store",IDBObjectStore,["deleteIndex"]);function b(E){this._tx=E,this.complete=new Promise(function(k,P){E.oncomplete=function(){k()},E.onerror=function(){P(E.error)},E.onabort=function(){P(E.error)}})}b.prototype.objectStore=function(){return new f(this._tx.objectStore.apply(this._tx,arguments))},s(b,"_tx",["objectStoreNames","mode"]),a(b,"_tx",IDBTransaction,["abort"]);function B(E,k,P){this._db=E,this.oldVersion=k,this.transaction=new b(P)}B.prototype.createObjectStore=function(){return new f(this._db.createObjectStore.apply(this._db,arguments))},s(B,"_db",["name","version","objectStoreNames"]),a(B,"_db",IDBDatabase,["deleteObjectStore","close"]);function X(E){this._db=E}X.prototype.transaction=function(){return new b(this._db.transaction.apply(this._db,arguments))},s(X,"_db",["name","version","objectStoreNames"]),a(X,"_db",IDBDatabase,["close"]),["openCursor","openKeyCursor"].forEach(function(E){[f,h].forEach(function(k){E in k.prototype&&(k.prototype[E.replace("open","iterate")]=function(){var P=e(arguments),U=P[P.length-1],C=this._store||this._index,ve=C[E].apply(C,P.slice(0,-1));ve.onsuccess=function(){U(ve.result)}})})}),[h,f].forEach(function(E){E.prototype.getAll||(E.prototype.getAll=function(k,P){var U=this,C=[];return new Promise(function(ve){U.iterateCursor(k,function(Ir){if(!Ir){ve(C);return}if(C.push(Ir.value),P!==void 0&&C.length==P){ve(C);return}Ir.continue()})})})});var xe={open:function(E,k,P){var U=r(indexedDB,"open",[E,k]),C=U.request;return C&&(C.onupgradeneeded=function(ve){P&&P(new B(C.result,ve.oldVersion,C.transaction))}),U.then(function(ve){return new X(ve)})},delete:function(E){return r(indexedDB,"deleteDatabase",[E])}};n.exports=xe,n.exports.default=n.exports})()}),Js=Fs(function(n){typeof indexedDB<"u"?n.exports=rc:n.exports={open:function(){return Promise.reject("IDB requires a browser environment")},delete:function(){return Promise.reject("IDB requires a browser environment")}}});Js.open;class O extends on{static async create(){const e=await Js.open(this.STORAGE_NAME,2,t=>{t.oldVersion===1&&(t.deleteObjectStore(this.SESSION_STORAGE),t.deleteObjectStore(this.IDENTITY_STORAGE),t.deleteObjectStore(this.REMOTE_STORAGE)),t.createObjectStore(this.SESSION_STORAGE),t.createObjectStore(this.IDENTITY_STORAGE),t.createObjectStore(this.REMOTE_STORAGE)});return new O(e)}constructor(e){super(),this.db=e}async loadWrapKey(){const e=await this.db.transaction(O.IDENTITY_STORAGE).objectStore(O.IDENTITY_STORAGE).get(O.WRAP_KEY);return e?($.iv=e.iv,e.key instanceof ArrayBuffer?{key:await I().crypto.subtle.importKey("raw",e.key,{name:$.name,length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),iv:e.iv}:{key:e.key,iv:e.iv}):null}async saveWrapKey(e){let t;dr()||yr()?t={key:await I().crypto.subtle.exportKey("raw",e.key),iv:e.iv}:t={...e},await this.db.transaction(O.IDENTITY_STORAGE,"readwrite").objectStore(O.IDENTITY_STORAGE).put(t,O.WRAP_KEY)}async loadIdentity(){const e=await this.db.transaction(O.IDENTITY_STORAGE).objectStore(O.IDENTITY_STORAGE).get(O.IDENTITY);let t=null;if(e){if(Oi()||dr()||yr()){const r=await this.loadWrapKey();if(!(r&&r.key.usages.some(i=>i==="encrypt")&&e.exchangeKey.privateKey instanceof ArrayBuffer))return null;e.exchangeKey.privateKey=await I().crypto.subtle.unwrapKey("jwk",e.exchangeKey.privateKey,r.key,$,Ti,!1,["deriveKey","deriveBits"]),e.signingKey.privateKey=await I().crypto.subtle.unwrapKey("jwk",e.signingKey.privateKey,r.key,$,Ui,!1,["sign"]),e.exchangeKey.publicKey=await I().crypto.subtle.unwrapKey("jwk",e.exchangeKey.publicKey,r.key,$,Ti,!0,[]),e.signingKey.publicKey=await I().crypto.subtle.unwrapKey("jwk",e.signingKey.publicKey,r.key,$,Ui,!0,["verify"])}t=await Br.fromJSON(e)}return t}async saveIdentity(e){let t;if(Oi()||dr()||yr()){t={key:await I().crypto.subtle.generateKey({name:$.name,length:256},dr()||yr(),["wrapKey","unwrapKey","encrypt","decrypt"]),iv:I().crypto.getRandomValues(new Uint8Array($.iv)).buffer},await this.saveWrapKey(t);const i=await I().crypto.subtle.generateKey(e.exchangeKey.privateKey.algorithm,!0,["deriveKey","deriveBits"]);e.exchangeKey.privateKey=i.privateKey,await Dn(e.exchangeKey.publicKey,i.publicKey);const s=await I().crypto.subtle.generateKey(e.signingKey.privateKey.algorithm,!0,["sign","verify"]);e.signingKey.privateKey=s.privateKey,await Dn(e.signingKey.publicKey,s.publicKey)}const r=await e.toJSON();t&&(r.exchangeKey.privateKey=await I().crypto.subtle.wrapKey("jwk",e.exchangeKey.privateKey,t.key,$),r.signingKey.privateKey=await I().crypto.subtle.wrapKey("jwk",e.signingKey.privateKey,t.key,$),r.exchangeKey.publicKey=await I().crypto.subtle.wrapKey("jwk",e.exchangeKey.publicKey.key,t.key,$),r.signingKey.publicKey=await I().crypto.subtle.wrapKey("jwk",e.signingKey.publicKey.key,t.key,$)),await this.db.transaction(O.IDENTITY_STORAGE,"readwrite").objectStore(O.IDENTITY_STORAGE).put(r,O.IDENTITY)}async loadRemoteIdentity(e){const t=await this.db.transaction(O.REMOTE_STORAGE).objectStore(O.REMOTE_STORAGE).get(e);let r=null;if(t){const i=await this.loadWrapKey();i&&(t.exchangeKey=await I().crypto.subtle.unwrapKey("jwk",t.exchangeKey,i.key,$,Ti,!0,[]),t.signingKey=await I().crypto.subtle.unwrapKey("jwk",t.signingKey,i.key,$,Ui,!0,["verify"])),r=await _t.fromJSON(t)}return r}async saveRemoteIdentity(e,t){const r=await t.toJSON(),i=await this.loadWrapKey();i&&(r.exchangeKey=await I().crypto.subtle.wrapKey("jwk",r.exchangeKey,i.key,$),r.signingKey=await I().crypto.subtle.wrapKey("jwk",r.signingKey,i.key,$)),await this.db.transaction(O.REMOTE_STORAGE,"readwrite").objectStore(O.REMOTE_STORAGE).put(r,e)}async loadSession(e){const t=await this.db.transaction(O.SESSION_STORAGE).objectStore(O.SESSION_STORAGE).get(e);let r=null;if(t){const i=await this.loadIdentity();if(!i)throw new Error("Identity is empty");const s=await this.loadRemoteIdentity(e);if(!s)throw new Error("Remote identity is not found");r=await Mt.fromJSON(i,s,t)}return r}async saveSession(e,t){const r=await t.toJSON();await this.db.transaction(O.SESSION_STORAGE,"readwrite").objectStore(O.SESSION_STORAGE).put(r,e)}}O.STORAGE_NAME="webcrypto-remote",O.IDENTITY_STORAGE="identity",O.SESSION_STORAGE="sessions",O.REMOTE_STORAGE="remoteIdentity",O.WRAP_KEY="wkey",O.IDENTITY="identity";class ic extends on{constructor(){super(...arguments),this.remoteIdentities={},this.sessions={}}async loadIdentity(){return this.identity||null}async saveIdentity(e){this.identity=e}async loadRemoteIdentity(e){return this.remoteIdentities[e]||null}async saveRemoteIdentity(e,t){this.remoteIdentities[e]=t}async loadSession(e){return this.sessions[e]||null}async saveSession(e,t){this.sessions[e]=t}}return he.BrowserStorage=O,he.CertificateStorage=Ms,he.CryptoServerError=Cn,he.KeyStorage=qs,he.MemoryStorage=ic,he.RatchetStorage=on,he.SocketCrypto=$s,he.SocketProvider=di,he.getEngine=I,he.setEngine=lo,he}({},protobuf,WebSocket);self.WebcryptoSocket=nc;
