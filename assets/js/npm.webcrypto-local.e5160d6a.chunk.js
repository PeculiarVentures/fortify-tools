(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{"78Ih":function(e,t,r){"use strict";(function(e){function i(t){return"undefined"!==typeof e?new Uint8Array(t):new Uint8Array(t instanceof ArrayBuffer?t:t.buffer)}r.d(t,"a",function(){return n}),r.d(t,"b",function(){return o});class n{static ToString(e,t="utf8"){const r=i(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(t){const r=i(t);if("undefined"!==typeof btoa){const e=this.ToString(r,"binary");return btoa(e)}return e.from(r).toString("base64")}static FromBase64(t){return t=t.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!==typeof atob?this.FromBinary(atob(t)):new Uint8Array(e.from(t,"base64")).buffer}static FromBase64Url(e){return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return r.buffer}static ToUtf8String(e){const t=i(e),r=String.fromCharCode.apply(null,t);return decodeURIComponent(escape(r))}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.charCodeAt(i);return r.buffer}static ToBinary(e){const t=i(e);let r="";const n=t.length;for(let i=0;i<n;i++)r+=String.fromCharCode(t[i]);return r}static ToHex(e){const t=i(e),r=[],n=t.length;for(let i=0;i<n;i++){const e=t[i].toString(16);r.push(1===e.length?"0"+e:e)}return r.join("")}static FromHex(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2){const i=e.slice(r,r+2);t[r/2]=parseInt(i,16)}return t.buffer}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}}function o(e,...t){const r=arguments[0];for(let i=1;i<arguments.length;i++){const e=arguments[i];for(const t in e)r[t]=e[t]}return r}}).call(this,r("tjlA").Buffer)},CVFz:function(e,t,r){"use strict";r.r(t),function(e){r.d(t,"AlgorithmError",function(){return s}),r.d(t,"CryptoError",function(){return o}),r.d(t,"UnsupportedOperationError",function(){return c}),r.d(t,"OperationError",function(){return a}),r.d(t,"RequiredPropertyError",function(){return y}),r.d(t,"AesProvider",function(){return b}),r.d(t,"AesCbcProvider",function(){return l}),r.d(t,"AesCmacProvider",function(){return g}),r.d(t,"AesCtrProvider",function(){return f}),r.d(t,"AesEcbProvider",function(){return m}),r.d(t,"AesGcmProvider",function(){return w}),r.d(t,"AesKwProvider",function(){return v}),r.d(t,"DesProvider",function(){return O}),r.d(t,"RsaProvider",function(){return E}),r.d(t,"RsaSsaProvider",function(){return j}),r.d(t,"RsaPssProvider",function(){return I}),r.d(t,"RsaOaepProvider",function(){return A}),r.d(t,"EllipticProvider",function(){return K}),r.d(t,"EcdsaProvider",function(){return C}),r.d(t,"EcdhProvider",function(){return D}),r.d(t,"HmacProvider",function(){return k}),r.d(t,"Pbkdf2Provider",function(){return P}),r.d(t,"HkdfProvider",function(){return x}),r.d(t,"Crypto",function(){return T}),r.d(t,"ProviderCrypto",function(){return h}),r.d(t,"ProviderStorage",function(){return B}),r.d(t,"SubtleCrypto",function(){return X}),r.d(t,"CryptoKey",function(){return N}),r.d(t,"PemConverter",function(){return d}),r.d(t,"BufferSourceConverter",function(){return u}),r.d(t,"isJWK",function(){return p});var i=r("mrSG"),n=r("oJvU");class o extends Error{}class s extends o{}class c extends o{constructor(e){super(`Unsupported operation: ${e?`${e}`:""}`)}}class a extends o{}class y extends o{constructor(e){super(`${e}: Missing required property`)}}class d{static toArrayBuffer(e){const t=e.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace("\n","");return n.Convert.FromBase64(t)}static toUint8Array(e){const t=this.toArrayBuffer(e);return new Uint8Array(t)}static fromBufferSource(e,t){const r=n.Convert.ToBase64(e);let i,o=0;const s=[];for(;(i=r.slice(o,o+=64)).length&&(s.push(i),!(i.length<64)););const c=t.toUpperCase();return`-----BEGIN ${c}-----\n${s.join("\n")}\n-----END ${c}-----`}static isPEM(e){return/-----BEGIN .+-----[A-Za-z0-9+\/\+\=\s\n]+-----END .+-----/i.test(e)}static getTagName(e){if(!this.isPEM(e))throw new Error("Bad parameter. Incoming data is not right PEM");const t=/-----BEGIN (.+)-----/.exec(e);if(!t)throw new Error("Cannot get tag from PEM");return t[1]}static hasTagName(e,t){const r=this.getTagName(e);return t.toLowerCase()===r.toLowerCase()}static isCertificate(e){return this.hasTagName(e,"certificate")}static isCertificateRequest(e){return this.hasTagName(e,"certificate request")}static isCRL(e){return this.hasTagName(e,"x509 crl")}static isPublicKey(e){return this.hasTagName(e,"public key")}}class u{static toArrayBuffer(t){if(t instanceof ArrayBuffer)return t;if("undefined"!==typeof e&&e.isBuffer(t))return new Uint8Array(t).buffer;if(ArrayBuffer.isView(t))return t.buffer;throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static toUint8Array(e){return new Uint8Array(this.toArrayBuffer(e))}static isBufferSource(e){return ArrayBuffer.isView(e)||e instanceof ArrayBuffer}}function p(e){return"object"===typeof e&&"kty"in e}class h{digest(e,t){return Object(i.a)(this,arguments,void 0,function*(){return this.checkDigest.apply(this,arguments),this.onDigest.apply(this,arguments)})}checkDigest(e,t){this.checkAlgorithmName(e)}onDigest(e,t){return Object(i.a)(this,void 0,void 0,function*(){throw new c("digest")})}generateKey(e,t,r){return Object(i.a)(this,arguments,void 0,function*(){return this.checkGenerateKey.apply(this,arguments),this.onGenerateKey.apply(this,arguments)})}checkGenerateKey(e,t,r){if(this.checkAlgorithmName(e),this.checkGenerateKeyParams(e),!r||!r.length)throw new TypeError("Usages cannot be empty when creating a key.");let i;i=Array.isArray(this.usages)?this.usages:this.usages.privateKey.concat(this.usages.publicKey),this.checkKeyUsages(r,i)}checkGenerateKeyParams(e){}onGenerateKey(e,t,r){return Object(i.a)(this,void 0,void 0,function*(){throw new c("generateKey")})}sign(e,t,r){return Object(i.a)(this,arguments,void 0,function*(){return this.checkSign.apply(this,arguments),this.onSign.apply(this,arguments)})}checkSign(e,t,r){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"sign")}onSign(e,t,r){return Object(i.a)(this,void 0,void 0,function*(){throw new c("sign")})}verify(e,t,r,n){return Object(i.a)(this,arguments,void 0,function*(){return this.checkVerify.apply(this,arguments),this.onVerify.apply(this,arguments)})}checkVerify(e,t,r,i){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"verify")}onVerify(e,t,r,n){return Object(i.a)(this,void 0,void 0,function*(){throw new c("verify")})}encrypt(e,t,r,n){return Object(i.a)(this,arguments,void 0,function*(){return this.checkEncrypt.apply(this,arguments),this.onEncrypt.apply(this,arguments)})}checkEncrypt(e,t,r,i={}){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,i.keyUsage?"encrypt":void 0)}onEncrypt(e,t,r){return Object(i.a)(this,void 0,void 0,function*(){throw new c("encrypt")})}decrypt(e,t,r,n){return Object(i.a)(this,arguments,void 0,function*(){return this.checkDecrypt.apply(this,arguments),this.onDecrypt.apply(this,arguments)})}checkDecrypt(e,t,r,i={}){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,i.keyUsage?"decrypt":void 0)}onDecrypt(e,t,r){return Object(i.a)(this,void 0,void 0,function*(){throw new c("decrypt")})}deriveBits(e,t,r,n){return Object(i.a)(this,arguments,void 0,function*(){return this.checkDeriveBits.apply(this,arguments),this.onDeriveBits.apply(this,arguments)})}checkDeriveBits(e,t,r,i={}){if(this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,i.keyUsage?"deriveBits":void 0),r%8!==0)throw new a("length: Is not multiple of 8")}onDeriveBits(e,t,r){return Object(i.a)(this,void 0,void 0,function*(){throw new c("deriveBits")})}exportKey(e,t){return Object(i.a)(this,arguments,void 0,function*(){return this.checkExportKey.apply(this,arguments),this.onExportKey.apply(this,arguments)})}checkExportKey(e,t){if(this.checkKeyFormat(e),this.checkCryptoKey(t),!t.extractable)throw new o("key: Is not extractable")}onExportKey(e,t){return Object(i.a)(this,void 0,void 0,function*(){throw new c("exportKey")})}importKey(e,t,r,n,o){return Object(i.a)(this,arguments,void 0,function*(){return this.checkImportKey.apply(this,arguments),this.onImportKey.apply(this,arguments)})}checkImportKey(e,t,r,i,n){this.checkKeyFormat(e),this.checkKeyData(e,t),this.checkAlgorithmName(r),this.checkImportParams(r),Array.isArray(this.usages)&&this.checkKeyUsages(n,this.usages)}onImportKey(e,t,r,n,o){return Object(i.a)(this,void 0,void 0,function*(){throw new c("importKey")})}checkAlgorithmName(e){if(e.name.toLowerCase()!==this.name.toLowerCase())throw new s("Unrecognized name")}checkAlgorithmParams(e){}checkDerivedKeyParams(e){}checkKeyUsages(e,t){for(const r of e)if(-1===t.indexOf(r))throw new TypeError("Cannot create a key using the specified key usages")}checkCryptoKey(e,t){if(this.checkAlgorithmName(e.algorithm),t&&-1===e.usages.indexOf(t))throw new o("key does not match that of operation")}checkRequiredProperty(e,t){if(!(t in e))throw new y(t)}checkHashAlgorithm(e,t){for(const r of t)if(r.toLowerCase()===e.name.toLowerCase())return;throw new a(`hash: Must be one of ${t.join(", ")}`)}checkImportParams(e){}checkKeyFormat(e){switch(e){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(e,t){if(!t)throw new TypeError("keyData: Cannot be empty on empty on key importing");if("jwk"===e){if(!p(t))throw new TypeError("keyData: Is not JsonWebToken")}else if(!u.isBufferSource(t))throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer")}prepareData(e){return u.toArrayBuffer(e)}}class b extends h{checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!==typeof e.length)throw new TypeError("length: Is not of type Number");switch(e.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class l extends b{constructor(){super(...arguments),this.name="AES-CBC",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.iv.byteLength)throw new TypeError("iv: Must have length 16 bytes")}}class g extends b{constructor(){super(...arguments),this.name="AES-CMAC",this.usages=["sign","verify"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"length"),"number"!==typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new a("length: Must be more than 0")}}class f extends b{constructor(){super(...arguments),this.name="AES-CTR",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"counter"),!(e.counter instanceof ArrayBuffer||ArrayBuffer.isView(e.counter)))throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.counter.byteLength)throw new TypeError("iv: Must have length 16 bytes");if(this.checkRequiredProperty(e,"length"),"number"!==typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new a("length: Must be more than 0")}}class m extends b{constructor(){super(...arguments),this.name="AES-ECB",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}}class w extends b{constructor(){super(...arguments),this.name="AES-GCM",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength<1)throw new a("iv: Must have length more than 0 and less than 2^64 - 1");switch("tagLength"in e||(e.tagLength=128),e.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new a("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}}class v extends b{constructor(){super(...arguments),this.name="AES-KW",this.usages=["wrapKey","unwrapKey"]}}class O extends h{constructor(){super(...arguments),this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.ivSize){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength!==this.ivSize)throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!==typeof e.length)throw new TypeError("length: Is not of type Number");if(e.length!==this.keySizeBits)throw new a(`algorith.length: Must be ${this.keySizeBits}`)}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class E extends h{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=n.Convert.ToBase64(e.publicExponent);if("Aw=="!==t&&"AQAB"!==t)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}class j extends E{constructor(){super(...arguments),this.name="RSASSA-PKCS1-v1_5",this.usages={privateKey:["sign"],publicKey:["verify"]}}}class I extends E{constructor(){super(...arguments),this.name="RSA-PSS",this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"saltLength"),"number"!==typeof e.saltLength)throw new TypeError("saltLength: Is not a Number");if(e.saltLength<1)throw new RangeError("saltLength: Must be more than 0")}}class A extends E{constructor(){super(...arguments),this.name="RSA-OAEP",this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(e){if(e.label&&!(e.label instanceof ArrayBuffer||ArrayBuffer.isView(e.label)))throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}}class K extends h{checkGenerateKeyParams(e){this.checkRequiredProperty(e,"namedCurve"),this.checkNamedCurve(e.namedCurve)}checkNamedCurve(e){for(const t of this.namedCurves)if(t.toLowerCase()===e.toLowerCase())return;throw new a(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`)}}class C extends K{constructor(){super(...arguments),this.name="ECDSA",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}const S=["secret","private","public"];class N{static create(e,t,r,i){const n=new this;return n.algorithm=e,n.type=t,n.extractable=r,n.usages=i,n}static isKeyType(e){return-1!==S.indexOf(e)}}class D extends K{constructor(){super(...arguments),this.name="ECDH",this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]},this.namedCurves=["P-256","P-384","P-521"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"public"),!(e.public instanceof N))throw new TypeError("public: Is not a CryptoKey");if("public"!==e.public.type)throw new a("public: Is not a public key");if(e.public.algorithm.name!==this.name)throw new a(`public: Is not ${this.name} key`)}}class k extends h{constructor(){super(...arguments),this.name="HMAC",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["sign","verify"]}getDefaultLength(e){switch(e.toUpperCase()){case"SHA-1":return 160;case"SHA-256":return 256;case"SHA-384":return 384;case"SHA-512":return 512;default:throw new Error(`Unknown algorithm name '${e}'`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),"length"in e){if("number"!==typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new RangeError("length: Number is out of range")}}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}class P extends h{constructor(){super(...arguments),this.name="PBKDF2",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!(e.salt instanceof ArrayBuffer||ArrayBuffer.isView(e.salt)))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"iterations"),"number"!==typeof e.iterations)throw new TypeError("iterations: Is not a Number");if(e.iterations<1)throw new TypeError("iterations: Is less than 1")}checkImportKey(e,t,r,i,n){if(super.checkImportKey(e,t,r,i,n),i)throw new SyntaxError("extractable: Must be False")}}class x extends h{constructor(){super(...arguments),this.name="HKDF",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveKey","deriveBits"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!u.isBufferSource(e.salt))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"info"),!u.isBufferSource(e.info))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'")}checkImportKey(e,t,r,i,n){if(super.checkImportKey(e,t,r,i,n),i)throw new SyntaxError("extractable: Must be False")}}class T{}class B{constructor(){this.items={}}get(e){return this.items[e.toLowerCase()]||null}set(e){this.items[e.name.toLowerCase()]=e}removeAt(e){const t=this.get(e.toLowerCase());return t&&delete this.items[e],t}has(e){return!!this.get(e)}get length(){return Object.keys(this.items).length}get algorithms(){const e=[];for(const t in this.items){const r=this.items[t];e.push(r.name)}return e.sort()}}class X{constructor(){this.providers=new B}static isHashedAlgorithm(e){return e instanceof Object&&"name"in e&&"hash"in e}digest(e,t){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,2,"digest");const r=this.prepareAlgorithm(e),i=u.toArrayBuffer(t),n=this.getProvider(r.name);return yield n.digest(r,i)})}generateKey(e,t,r){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"generateKey");const i=this.prepareAlgorithm(e),n=this.getProvider(i.name);return yield n.generateKey(Object.assign({},i,{name:n.name}),t,r)})}sign(e,t,r){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"sign"),this.checkCryptoKey(t);const i=this.prepareAlgorithm(e),n=u.toArrayBuffer(r),o=this.getProvider(i.name);return yield o.sign(Object.assign({},i,{name:o.name}),t,n)})}verify(e,t,r,n){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,4,"verify"),this.checkCryptoKey(t);const i=this.prepareAlgorithm(e),o=u.toArrayBuffer(n),s=u.toArrayBuffer(r),c=this.getProvider(i.name);return yield c.verify(Object.assign({},i,{name:c.name}),t,s,o)})}encrypt(e,t,r){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"encrypt"),this.checkCryptoKey(t);const i=this.prepareAlgorithm(e),n=u.toArrayBuffer(r),o=this.getProvider(i.name);return yield o.encrypt(Object.assign({},i,{name:o.name}),t,n,{keyUsage:!0})})}decrypt(e,t,r){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"decrypt"),this.checkCryptoKey(t);const i=this.prepareAlgorithm(e),n=u.toArrayBuffer(r),o=this.getProvider(i.name);return yield o.decrypt(Object.assign({},i,{name:o.name}),t,n,{keyUsage:!0})})}deriveBits(e,t,r){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"deriveBits"),this.checkCryptoKey(t);const i=this.prepareAlgorithm(e),n=this.getProvider(i.name);return yield n.deriveBits(Object.assign({},i,{name:n.name}),t,r,{keyUsage:!0})})}deriveKey(e,t,r,n,o){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,5,"deriveKey");const i=this.prepareAlgorithm(r);this.getProvider(i.name).checkDerivedKeyParams(i);const s=this.prepareAlgorithm(e),c=this.getProvider(s.name);c.checkCryptoKey(t,"deriveKey");const a=yield c.deriveBits(Object.assign({},s,{name:c.name}),t,r.length,{keyUsage:!1});return this.importKey("raw",a,r,n,o)})}exportKey(e,t){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,2,"exportKey"),this.checkCryptoKey(t);const r=this.getProvider(t.algorithm.name);return yield r.exportKey(e,t)})}importKey(e,t,r,n,o){return Object(i.a)(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,5,"importKey");const i=this.prepareAlgorithm(r),s=this.getProvider(i.name);if(-1!==["pkcs8","spki","raw"].indexOf(e)){const r=u.toArrayBuffer(t);return s.importKey(e,r,Object.assign({},i,{name:s.name}),n,o)}if(!t.kty)throw new TypeError("keyData: Is not JSON");return s.importKey(e,t,Object.assign({},i,{name:s.name}),n,o)})}wrapKey(e,t,r,o){return Object(i.a)(this,void 0,void 0,function*(){let i=yield this.exportKey(e,t);if("jwk"===e){const e=JSON.stringify(i);i=n.Convert.FromUtf8String(e)}const s=this.prepareAlgorithm(o),c=u.toArrayBuffer(i),a=this.getProvider(s.name);return a.encrypt(Object.assign({},s,{name:a.name}),r,c,{keyUsage:!1})})}unwrapKey(e,t,r,o,s,c,a){return Object(i.a)(this,void 0,void 0,function*(){const i=this.prepareAlgorithm(o),y=u.toArrayBuffer(t),d=this.getProvider(i.name);let p=yield d.decrypt(Object.assign({},i,{name:d.name}),r,y,{keyUsage:!1});if("jwk"===e)try{p=JSON.parse(n.Convert.ToUtf8String(p))}catch(h){const e=new TypeError("wrappedKey: Is not a JSON");throw e.internal=h,e}return this.importKey(e,p,s,c,a)})}checkRequiredArguments(e,t,r){if(e.length!==t)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${t} arguments required, but only ${e.length} present`)}prepareAlgorithm(e){if("string"===typeof e)return{name:e};if(X.isHashedAlgorithm(e)){const t=Object.assign({},e);return t.hash=this.prepareAlgorithm(e.hash),t}return Object.assign({},e)}getProvider(e){const t=this.providers.get(e);if(!t)throw new s("Unrecognized name");return t}checkCryptoKey(e){if(!(e instanceof N))throw new TypeError("Key is not of type 'CryptoKey'")}}}.call(this,r("tjlA").Buffer)},ItbJ:function(e,t,r){"use strict";r.r(t);var i=r("TD7n"),n=r("mrSG"),o=r("s+3h");r("+qE3");const s="AES-CBC",c="SHA-256",a="HMAC";i.a.FromBinary("InfoText"),i.a.FromBinary("InfoRatchet"),i.a.FromBinary("InfoMessageKeys");let y=null;function d(){if(!y)throw new Error("WebCrypto engine is empty. Use setEngine to resolve it.");return y}"undefined"!==typeof self&&(y={crypto:self.crypto,name:"WebCrypto"});class u{static async generateKeyPair(e){const t=e,r="ECDSA"===e?["sign","verify"]:["deriveKey","deriveBits"],i=await d().crypto.subtle.generateKey({name:t,namedCurve:this.NAMED_CURVE},!1,r),n=await b.create(i.publicKey);return{privateKey:i.privateKey,publicKey:n}}static deriveBytes(e,t){return d().crypto.subtle.deriveBits({name:"ECDH",public:t.key},e,256)}static verify(e,t,r){return d().crypto.subtle.verify({name:"ECDSA",hash:this.DIGEST_ALGORITHM},e.key,r,t)}static async sign(e,t){return d().crypto.subtle.sign({name:"ECDSA",hash:this.DIGEST_ALGORITHM},e,t)}static async ecKeyPairToJson(e){return{privateKey:e.privateKey,publicKey:e.publicKey.key,thumbprint:await e.publicKey.thumbprint()}}static async ecKeyPairFromJson(e){return{privateKey:e.privateKey,publicKey:await b.create(e.publicKey)}}}u.NAMED_CURVE="P-256",u.DIGEST_ALGORITHM="SHA-512";const p={name:"AES-CBC",length:256};class h{static randomBytes(e){const t=new Uint8Array(e);return d().crypto.getRandomValues(t),t.buffer}static digest(e,t){return d().crypto.subtle.digest(e,t)}static encrypt(e,t,r){return d().crypto.subtle.encrypt({name:s,iv:new Uint8Array(r)},e,t)}static decrypt(e,t,r){return d().crypto.subtle.decrypt({name:s,iv:new Uint8Array(r)},e,t)}static importHMAC(e){return d().crypto.subtle.importKey("raw",e,{name:a,hash:{name:c}},!1,["sign","verify"])}static importAES(e){return d().crypto.subtle.importKey("raw",e,p,!1,["encrypt","decrypt"])}static async sign(e,t){return await d().crypto.subtle.sign({name:a,hash:c},e,t)}static async HKDF(e,t=1,r,n=new ArrayBuffer(0)){r||(r=await this.importHMAC(new Uint8Array(32).buffer));const o=await this.sign(r,e),s=(new ArrayBuffer(32+n.byteLength+1),await this.importHMAC(o)),c=[new ArrayBuffer(0)];for(let a=0;a<t;a++)c[a+1]=await this.sign(s,Object(i.b)(c[a],n,new Uint8Array([a+1]).buffer));return c.slice(1)}}class b{static async create(e){const t=new this,r=e.algorithm.name.toUpperCase();if("ECDH"!==r&&"ECDSA"!==r)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==e.type)throw new Error("Error: Expected key type to be public but it was not.");t.key=e;const n=await d().crypto.subtle.exportKey("jwk",e);if(!n.x||!n.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const o=i.a.FromBase64Url(n.x),s=i.a.FromBase64Url(n.y),c=i.a.ToBinary(o)+i.a.ToBinary(s);return t.serialized=i.a.FromBinary(c),t.id=await t.thumbprint(),t}static async importKey(e,t){const r=i.a.ToBase64Url(e.slice(0,32)),n=i.a.ToBase64Url(e.slice(32)),o={crv:u.NAMED_CURVE,kty:"EC",x:r,y:n},s="ECDSA"===t?["verify"]:[],c=await d().crypto.subtle.importKey("jwk",o,{name:t,namedCurve:u.NAMED_CURVE},!0,s);return await b.create(c)}serialize(){return this.serialized}async thumbprint(){const e=await this.serialize(),t=await h.digest("SHA-256",e);return i.a.ToHex(t)}async isEqual(e){return!!(e&&e instanceof b)&&Object(i.c)(this.serialized,e.serialized)}}let l=class extends o.b{};Object(n.b)([Object(o.d)({id:0,type:"uint32",defaultValue:1})],l.prototype,"version",void 0),l=Object(n.b)([Object(o.c)({name:"Base"})],l);class g{static async set(e){return new Uint8Array(e.serialize())}static async get(e){return b.importKey(e.buffer,"ECDSA")}}class f{static async set(e){return new Uint8Array(e.serialize())}static async get(e){return b.importKey(e.buffer,"ECDH")}}var m;let w=m=class extends l{static async fill(e){const t=new m;return await t.fill(e),t}async sign(e){this.signature=await u.sign(e,this.exchangeKey.serialize())}async verify(){return await u.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async fill(e){this.signingKey=e.signingKey.publicKey,this.exchangeKey=e.exchangeKey.publicKey,this.createdAt=e.createdAt,await this.sign(e.signingKey.privateKey)}};Object(n.b)([Object(o.d)({id:1,converter:g})],w.prototype,"signingKey",void 0),Object(n.b)([Object(o.d)({id:2,converter:f})],w.prototype,"exchangeKey",void 0),Object(n.b)([Object(o.d)({id:3})],w.prototype,"signature",void 0),Object(n.b)([Object(o.d)({id:4,converter:class{static async set(e){return new Uint8Array(i.a.FromString(e.toISOString()))}static async get(e){return new Date(i.a.ToString(e))}}})],w.prototype,"createdAt",void 0),w=m=Object(n.b)([Object(o.c)({name:"Identity"})],w);let v=class extends l{};Object(n.b)([Object(o.d)({id:1,converter:f,required:!0})],v.prototype,"senderRatchetKey",void 0),Object(n.b)([Object(o.d)({id:2,type:"uint32",required:!0})],v.prototype,"counter",void 0),Object(n.b)([Object(o.d)({id:3,type:"uint32",required:!0})],v.prototype,"previousCounter",void 0),Object(n.b)([Object(o.d)({id:4,converter:o.a,required:!0})],v.prototype,"cipherText",void 0),v=Object(n.b)([Object(o.c)({name:"Message"})],v);let O=class extends l{async sign(e){this.signature=await this.signHMAC(e)}async verify(e){const t=await this.signHMAC(e);return Object(i.c)(t,this.signature)}async getSignedRaw(){const e=this.receiverKey.serialize(),t=this.senderKey.serialize(),r=await this.message.exportProto();return Object(i.b)(e,t,r)}async signHMAC(e){const t=await this.getSignedRaw();return await h.sign(e,t)}};Object(n.b)([Object(o.d)({id:1,converter:g,required:!0})],O.prototype,"senderKey",void 0),Object(n.b)([Object(o.d)({id:2,parser:v,required:!0})],O.prototype,"message",void 0),Object(n.b)([Object(o.d)({id:3,required:!0})],O.prototype,"signature",void 0),O=Object(n.b)([Object(o.c)({name:"MessageSigned"})],O);let E=class extends l{};Object(n.b)([Object(o.d)({id:1,type:"uint32",required:!0})],E.prototype,"registrationId",void 0),Object(n.b)([Object(o.d)({id:2,type:"uint32"})],E.prototype,"preKeyId",void 0),Object(n.b)([Object(o.d)({id:3,type:"uint32",required:!0})],E.prototype,"preKeySignedId",void 0),Object(n.b)([Object(o.d)({id:4,converter:f,required:!0})],E.prototype,"baseKey",void 0),Object(n.b)([Object(o.d)({id:5,parser:w,required:!0})],E.prototype,"identity",void 0),Object(n.b)([Object(o.d)({id:6,parser:O,required:!0})],E.prototype,"signedMessage",void 0),E=Object(n.b)([Object(o.c)({name:"PreKeyMessage"})],E);let j=class extends l{};Object(n.b)([Object(o.d)({id:1,type:"uint32",required:!0})],j.prototype,"id",void 0),Object(n.b)([Object(o.d)({id:2,converter:f,required:!0})],j.prototype,"key",void 0),j=Object(n.b)([Object(o.c)({name:"PreKey"})],j);let I=class extends j{async sign(e){this.signature=await u.sign(e,this.key.serialize())}verify(e){return u.verify(e,this.key.serialize(),this.signature)}};Object(n.b)([Object(o.d)({id:3,converter:o.a,required:!0})],I.prototype,"signature",void 0),I=Object(n.b)([Object(o.c)({name:"PreKeySigned"})],I);let A=class extends l{};Object(n.b)([Object(o.d)({id:1,type:"uint32",required:!0})],A.prototype,"registrationId",void 0),Object(n.b)([Object(o.d)({id:2,parser:w,required:!0})],A.prototype,"identity",void 0),Object(n.b)([Object(o.d)({id:3,parser:j})],A.prototype,"preKey",void 0),Object(n.b)([Object(o.d)({id:4,parser:I,required:!0})],A.prototype,"preKeySigned",void 0),A=Object(n.b)([Object(o.c)({name:"PreKeyBundle"})],A);new Uint8Array([1]).buffer,new Uint8Array([2]).buffer;async function K(e,t){const r=await e.thumbprint(),n=await t.thumbprint(),o=i.a.FromHex(r+n),s=await d().crypto.subtle.digest("SHA-256",o);return parseInt(i.a.ToHex(s),16).toString().substr(2,6)}r.d(t,"Event",function(){return S}),r.d(t,"SERVER_WELL_KNOWN",function(){return C}),r.d(t,"challenge",function(){return K});const C="/.well-known/webcrypto-socket";class S{constructor(e,t){this.target=e,this.event=t}}},LwB7:function(e,t,r){"use strict";var i=function(){if("undefined"!==typeof self)return self;if("undefined"!==typeof window)return window;if("undefined"!==typeof i)return i;throw new Error("unable to locate global object")}();e.exports=t=i.fetch,t.default=i.fetch.bind(i),t.Headers=i.Headers,t.Request=i.Request,t.Response=i.Response},TD7n:function(e,t,r){"use strict";(function(e){function i(t){return"undefined"!==typeof e?new Uint8Array(t):new Uint8Array(t instanceof ArrayBuffer?t:t.buffer)}r.d(t,"a",function(){return n}),r.d(t,"b",function(){return o}),r.d(t,"c",function(){return s});class n{static ToString(e,t="utf8"){const r=i(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(t){const r=i(t);if("undefined"!==typeof btoa){const e=this.ToString(r,"binary");return btoa(e)}return e.from(r).toString("base64")}static FromBase64(t){return t=t.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!==typeof atob?this.FromBinary(atob(t)):new Uint8Array(e.from(t,"base64")).buffer}static FromBase64Url(e){return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return r.buffer}static ToUtf8String(e){const t=i(e),r=String.fromCharCode.apply(null,t);return decodeURIComponent(escape(r))}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.charCodeAt(i);return r.buffer}static ToBinary(e){const t=i(e);let r="";const n=t.length;for(let i=0;i<n;i++)r+=String.fromCharCode(t[i]);return r}static ToHex(e){const t=i(e),r=[],n=t.length;for(let i=0;i<n;i++){const e=t[i].toString(16);r.push(1===e.length?"0"+e:e)}return r.join("")}static FromHex(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2){const i=e.slice(r,r+2);t[r/2]=parseInt(i,16)}return t.buffer}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}}function o(...e){const t=e.map(e=>e.byteLength).reduce((e,t)=>e+t),r=new Uint8Array(t);let i=0;return e.map(e=>new Uint8Array(e)).forEach(e=>{for(let t=0;t<e.length;t++)r[i++]=e[t]}),r.buffer}function s(e,t){if(!e||!t)return!1;if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),i=new Uint8Array(t);for(let n=0;n<e.byteLength;n++)if(r[n]!==i[n])return!1;return!0}}).call(this,r("tjlA").Buffer)},b1Ic:function(e,t,r){"use strict";function i(e){return e&&"object"===typeof e&&"default"in e?e.default:e}Object.defineProperty(t,"__esModule",{value:!0});var n,o=r("cgU2"),s=r("eGXv"),c=r("+qE3"),a=r("oJvU"),y=r("ItbJ"),d=i(r("LwB7")),u=i(r("kEOu")),p=r("CVFz"),h=r("nbvr");class b extends c.EventEmitter{constructor(e){super(),this.client=e,this.onEvent=this.onEvent.bind(this),this.client.on("listening",()=>{this.client.on("event",this.onEvent)}).on("close",()=>{this.client.removeListener("event",this.onEvent)})}async readers(){const e=await this.client.send(new s.CardReaderGetReadersActionProto);return JSON.parse(a.Convert.ToString(e))}on(e,t){return super.on(e,t)}emit(e,...t){return super.emit(e,...t)}onEvent(e){(async()=>{switch(e.action){case s.CardReaderInsertEventProto.ACTION:this.onInsert(await s.CardReaderInsertEventProto.importProto(e));break;case s.CardReaderRemoveEventProto.ACTION:this.onRemove(await s.CardReaderRemoveEventProto.importProto(e))}})().catch(e=>this.emit("error",e))}onInsert(e){this.emit("insert",e)}onRemove(e){this.emit("remove",e)}}class l extends Error{constructor(e){super(e.message),this.name="CryptoServerError",this.code=e.code,this.type=e.type}}class g extends y.Event{}class f extends g{constructor(e,t,r,i){super(e,"close"),this.remoteAddress=t,this.reasonCode=r,this.description=i}}class m extends g{constructor(e,t){super(e,"error"),this.error=t}}class w extends g{constructor(e,t){super(e,"listening"),this.address=t}}!function(e){e[e.connecting=0]="connecting",e[e.open=1]="open",e[e.closing=2]="closing",e[e.closed=3]="closed"}(n||(n={}));class v extends c.EventEmitter{constructor(e){super(),this.stack={},this.messageCounter=0,this.storage=e}get state(){return this.socket?this.socket.readyState:n.closed}connect(e,t){return this.getServerInfo(e).then(r=>{this.serviceInfo=r;const i=`wss://${e}`;this.socket=t?new u(i,void 0,t):new u(i),this.socket.binaryType="arraybuffer",this.socket.onerror=(e=>{this.emit("error",new m(this,e.error))}),this.socket.onopen=(()=>{(async()=>{let t=await this.storage.loadIdentity();t||(t=await o.Identity.create(1),await this.storage.saveIdentity(t));const i=await o.PreKeyBundleProtocol.importProto(a.Convert.FromBase64(r.preKey));this.cipher=await o.AsymmetricRatchet.create(t,i),await this.storage.saveRemoteIdentity("0",this.cipher.remoteIdentity),this.emit("listening",new w(this,e))})().catch(e=>this.emit("error",new m(this,e)))}),this.socket.onclose=(t=>{for(const e in this.stack){this.stack[e].reject(new Error("Cannot finish operation. Session was closed"))}this.emit("close",new f(this,e,t.code,t.reason))}),this.socket.onmessage=(e=>{e.data instanceof ArrayBuffer&&o.MessageSignedProtocol.importProto(e.data).then(e=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.decrypt(e)}).then(e=>{this.onMessage(e)}).catch(e=>{this.emit("error",new m(this,e))})})}).catch(e=>{this.emit("error",new m(this,e))}),this}close(){this.socket&&this.socket.close()}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async challenge(){if(!this.cipher)throw new Error("Client cipher is not initialized");return y.challenge(this.cipher.remoteIdentity.signingKey,this.cipher.identity.signingKey.publicKey)}async isLoggedIn(){const e=new s.ServerIsLoggedInActionProto,t=await this.send(e);return!!t&&!!new Uint8Array(t)[0]}async login(){const e=new s.ServerLoginActionProto;await this.send(e)}send(e){return new Promise((t,r)=>{this.checkSocketState(),e||(e=new s.ActionProto),e.action=e.action,e.actionId=(this.messageCounter++).toString(),e.exportProto().then(e=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.encrypt(e).then(e=>e.exportProto())}).then(i=>{if(!this.socket)throw new Error("Client socket is not initialized");this.stack[e.actionId]={resolve:t,reject:r},this.socket.send(i)}).catch(r)})}async getServerInfo(e){const t=`https://${e}${y.SERVER_WELL_KNOWN}`,r=await d(t);if(200!==r.status)throw new Error("Cannot get wellknown link");return await r.json()}checkSocketState(){if(this.state!==n.open)throw new Error("Socket connection is not open")}async onMessage(e){const t=await s.ActionProto.importProto(e),r=this.stack[t.actionId];if(r){delete this.stack[t.actionId];const e=await s.ResultProto.importProto(await t.exportProto());if(e.error&&e.error.message){const t=e.error,i=new l(t);r.reject(i)}else r.resolve(e.data)}else this.emit("event",t)}}function O(e){return e}function E(e){if(e instanceof s.AlgorithmProto)return e;const t=new s.AlgorithmProto;if("string"===typeof e)t.fromAlgorithm({name:e});else if((r=e)instanceof Object&&"name"in r&&"hash"in r){const r={...e};r.hash=E(e.hash),t.fromAlgorithm(r)}else t.fromAlgorithm({...e});var r;return t}function j(e,t){if(!e||"object"!==typeof e&&"string"!==typeof e)throw new TypeError(`${t}: Is wrong type. Must be Object or String`);if("object"===typeof e&&!("name"in e))throw new TypeError(`${t}: Required property 'name' is missed`)}function I(e,t){if(!function(e){return e instanceof s.CryptoKeyProto}(e))throw new TypeError(`${t}: Is not type CryptoKey`)}function A(e,t){if(!function(e){return e instanceof s.CryptoCertificateProto}(e))throw new TypeError(`${t}: Is not type CryptoCertificate`)}function K(e,t){if(!p.BufferSourceConverter.isBufferSource(e))throw new TypeError(`${t}: Is wrong type. Must be ArrayBuffer or ArrayBuffer view`)}function C(e,t){if(!Array.isArray(e))throw new TypeError(`${t}: Is not type Array`)}function S(e,t,r){if(typeof e!==t)throw new TypeError(`${r}: Is not type '${t}'`)}const N=["raw","pem","x509","request"];class D{constructor(e){this.provider=e}async indexOf(e){A(e,"item");const t=new s.CertificateStorageIndexOfActionProto;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return r?a.Convert.ToUtf8String(r):null}async hasItem(e){return!!await this.indexOf(e)}async exportCert(e,t){S(e,"string","format"),A(t,"item");const r=new s.CertificateStorageExportActionProto;r.providerID=this.provider.id,r.format="raw",r.item=t;const i=await this.provider.client.send(r);if("raw"===e)return i;{let e="";switch(t.type){case"x509":e="CERTIFICATE";break;case"request":e="CERTIFICATE REQUEST";break;default:throw new Error("Cannot create PEM for unknown type of certificate item")}return p.PemConverter.fromBufferSource(i,e)}}async importCert(e,t,r,i){if(S(e,"string","format"),!~N.indexOf(e))throw new TypeError(`format: Is invalid value. Must be ${N.join(", ")}`);"pem"===e?S(t,"string","data"):K(t,"data"),j(r,"algorithm"),C(i,"keyUsages");const n=E(r);let o;if(p.BufferSourceConverter.isBufferSource(t))o=p.BufferSourceConverter.toArrayBuffer(t);else{if("string"!==typeof t)throw new TypeError("data: Is not type String, ArrayBuffer or ArrayBufferView");o=p.PemConverter.toArrayBuffer(t)}const c=new s.CertificateStorageImportActionProto;c.providerID=this.provider.id,c.format="raw",c.data=o,c.algorithm=n,c.keyUsages=i;const a=await this.provider.client.send(c),y=await s.CryptoCertificateProto.importProto(a);if(("request"===e||"x509"===e)&&y.type!==e)throw new TypeError(`Imported item is not ${e}`);return this.prepareCertItem(y)}async keys(){const e=new s.CertificateStorageKeysActionProto;e.providerID=this.provider.id;const t=await this.provider.client.send(e);if(t){return a.Convert.ToUtf8String(t).split(",")}return[]}async getItem(e,t,r){S(e,"string","key"),t&&(j(t,"algorithm"),C(r,"keyUsages"));const i=new s.CertificateStorageGetItemActionProto;i.providerID=this.provider.id,i.key=e,t&&(i.algorithm=E(t),i.keyUsages=r);const n=await this.provider.client.send(i);if(n&&n.byteLength){const e=await s.CryptoCertificateProto.importProto(n);return this.prepareCertItem(e)}throw new Error("Cannot get CryptoCertificate from storage by index")}async setItem(e){A(e,"value");const t=new s.CertificateStorageSetItemActionProto;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return a.Convert.ToUtf8String(r)}async removeItem(e){S(e,"string","key");const t=new s.CertificateStorageRemoveItemActionProto;t.providerID=this.provider.id,t.key=e,await this.provider.client.send(t)}async clear(){const e=new s.CertificateStorageClearActionProto;e.providerID=this.provider.id,await this.provider.client.send(e)}async getChain(e){A(e,"value");const t=new s.CertificateStorageGetChainActionProto;t.providerID=this.provider.id,t.item=e;const r=await this.provider.client.send(t);return(await s.CertificateStorageGetChainResultProto.importProto(r)).items}async getCRL(e){S(e,"string","url");const t=new s.CertificateStorageGetCRLActionProto;return t.providerID=this.provider.id,t.url=e,await this.provider.client.send(t)}async getOCSP(e,t,r){S(e,"string","url"),K(t,"request");const i=new s.CertificateStorageGetOCSPActionProto;if(i.providerID=this.provider.id,i.url=e,i.request=p.BufferSourceConverter.toArrayBuffer(t),r)for(const n in r)i.options[n]=r[n];return await this.provider.client.send(i)}async prepareCertItem(e){const t=await e.exportProto();let r;switch(e.type){case"x509":r=await s.CryptoX509CertificateProto.importProto(t);break;case"request":r=await s.CryptoX509CertificateRequestProto.importProto(t);break;default:throw new Error(`Unsupported CertificateItem type '${e.type}'`)}return r.provider=this.provider,r}}class k{constructor(e){this.service=e}async keys(){const e=new s.KeyStorageKeysActionProto;e.providerID=this.service.id;const t=await this.service.client.send(e);if(t){return a.Convert.ToUtf8String(t).split(",")}return[]}async indexOf(e){I(e,"item");const t=new s.KeyStorageIndexOfActionProto;t.providerID=this.service.id,t.item=e;const r=await this.service.client.send(t);return r?a.Convert.ToUtf8String(r):null}async hasItem(e){return!!await this.indexOf(e)}async getItem(e,t,r,i){S(e,"string","key"),t&&(j(t,"algorithm"),S(r,"boolean","extractable"),C(i,"usages"));const n=new s.KeyStorageGetItemActionProto;n.providerID=this.service.id,n.key=e,t&&(n.algorithm=E(t),n.extractable=r,n.keyUsages=i);const o=await this.service.client.send(n);let c;if(!o||!o.byteLength)throw new Error("Cannot get CryptoKey from key storage by index");return c=await s.CryptoKeyProto.importProto(o)}async setItem(e){I(e,"value");const t=new s.KeyStorageSetItemActionProto;t.providerID=this.service.id,t.item=e;const r=await this.service.client.send(t);return a.Convert.ToUtf8String(r)}async removeItem(e){S(e,"string","key");const t=new s.KeyStorageRemoveItemActionProto;t.providerID=this.service.id,t.key=e,await this.service.client.send(t)}async clear(){const e=new s.KeyStorageClearActionProto;e.providerID=this.service.id,await this.service.client.send(e)}}class P{constructor(e){this.service=e}async encrypt(e,t,r){return this.encryptData(e,t,r,"encrypt")}async decrypt(e,t,r){return this.encryptData(e,t,r,"decrypt")}async deriveBits(e,t,r){j(e,"algorithm"),I(t,"baseKey"),S(r,"number","length");const i=E(e);I(i.public,"algorithm.public"),i.public=await O(i.public).exportProto();const n=new s.DeriveBitsActionProto;return n.providerID=this.service.id,n.algorithm=i,n.key=t,n.length=r,await this.service.client.send(n)}async deriveKey(e,t,r,i,n){j(e,"algorithm"),I(t,"baseKey"),j(r,"algorithm"),S(i,"boolean","extractable"),C(n,"keyUsages");const o=E(e);I(o.public,"algorithm.public"),o.public=await O(o.public).exportProto();const c=E(r),a=new s.DeriveKeyActionProto;a.providerID=this.service.id,a.algorithm=o,a.derivedKeyType.fromAlgorithm(c),a.key=t,a.extractable=i,a.usage=n;const y=await this.service.client.send(a);return await s.CryptoKeyProto.importProto(y)}async digest(e,t){j(e,"algorithm"),K(t,"data");E(e);const r=p.BufferSourceConverter.toArrayBuffer(t);return o.getEngine().crypto.subtle.digest(e,r)}async generateKey(e,t,r){j(e,"algorithm"),S(t,"boolean","extractable"),C(r,"keyUsages");const i=E(e),n=new s.GenerateKeyActionProto;n.providerID=this.service.id,n.algorithm=i,n.extractable=t,n.usage=r;const o=await this.service.client.send(n);try{return await s.CryptoKeyPairProto.importProto(o)}catch(c){return await s.CryptoKeyProto.importProto(o)}}async exportKey(e,t){S(e,"string","format"),I(t,"key");const r=new s.ExportKeyActionProto;r.providerID=this.service.id,r.format=e,r.key=t;const i=await this.service.client.send(r);return"jwk"===e?JSON.parse(a.Convert.ToBinary(i)):i}async importKey(e,t,r,i,n){S(e,"string","format"),j(r,"algorithm"),S(i,"boolean","extractable"),C(n,"keyUsages");const o=E(r);let c;"jwk"===e?c=a.Convert.FromUtf8String(JSON.stringify(t)):(K(t,"keyData"),c=p.BufferSourceConverter.toArrayBuffer(t));const y=new s.ImportKeyActionProto;y.providerID=this.service.id,y.algorithm=o,y.keyData=c,y.format=e,y.extractable=i,y.keyUsages=n;const d=await this.service.client.send(y);return await s.CryptoKeyProto.importProto(d)}async sign(e,t,r){j(e,"algorithm"),I(t,"key"),K(r,"data");const i=E(e),n=p.BufferSourceConverter.toArrayBuffer(r),o=new s.SignActionProto;return o.providerID=this.service.id,o.algorithm=i,o.key=t,o.data=n,await this.service.client.send(o)}async verify(e,t,r,i){j(e,"algorithm"),I(t,"key"),K(r,"signature"),K(i,"data");const n=E(e),o=p.BufferSourceConverter.toArrayBuffer(r),c=p.BufferSourceConverter.toArrayBuffer(i),a=new s.VerifyActionProto;a.providerID=this.service.id,a.algorithm=n,a.key=t,a.data=c,a.signature=o;const y=await this.service.client.send(a);return!!new Uint8Array(y)[0]}async wrapKey(e,t,r,i){S(e,"string","format"),I(t,"key"),I(r,"wrappingKey"),j(i,"wrapAlgorithm");const n=E(i),o=new s.WrapKeyActionProto;return o.providerID=this.service.id,o.wrapAlgorithm=n,o.key=t,o.wrappingKey=r,o.format=e,await this.service.client.send(o)}async unwrapKey(e,t,r,i,n,o,c){S(e,"string","format"),K(t,"wrappedKey"),I(r,"unwrappingKey"),j(i,"unwrapAlgorithm"),j(n,"unwrappedKeyAlgorithm"),S(o,"boolean","extractable"),C(c,"keyUsages");const a=E(i),y=E(n),d=p.BufferSourceConverter.toArrayBuffer(t),u=new s.UnwrapKeyActionProto;u.providerID=this.service.id,u.format=e,u.unwrapAlgorithm=a,u.unwrappedKeyAlgorithm=y,u.unwrappingKey=r,u.wrappedKey=d,u.extractable=o,u.keyUsage=c;const h=await this.service.client.send(u);return await s.CryptoKeyProto.importProto(h)}async encryptData(e,t,r,i){j(e,"algorithm"),I(t,"key"),K(r,"data");const n=E(e),o=p.BufferSourceConverter.toArrayBuffer(r);let c;const a=new(c="encrypt"===i?s.EncryptActionProto:s.DecryptActionProto);return a.providerID=this.service.id,a.algorithm=n,a.key=t,a.data=o,await this.service.client.send(a)}}class x{constructor(e,t){this.client=e,this.id=t,this.subtle=new P(this),this.keyStorage=new k(this),this.certStorage=new D(this)}getRandomValues(e){return o.getEngine().crypto.getRandomValues(e)}async login(){const e=new s.LoginActionProto;return e.providerID=this.id,this.client.send(e)}async logout(){const e=new s.LogoutActionProto;return e.providerID=this.id,this.client.send(e)}async reset(){const e=new s.ResetActionProto;return e.providerID=this.id,this.client.send(e)}async isLoggedIn(){const e=new s.IsLoggedInActionProto;e.providerID=this.id;const t=await this.client.send(e);return!!new Uint8Array(t)[0]}}class T{}function B(){return/firefox/i.test(self.navigator.userAgent)}function X(){return/edge\/([\d\.]+)/i.test(self.navigator.userAgent)}const R={name:"ECDH",namedCurve:"P-256"},U={name:"ECDSA",namedCurve:"P-256"},q={name:"AES-CBC",iv:new ArrayBuffer(16)};async function H(e,t){const r=await async function(e){const t=e.algorithm.name.toUpperCase();if("ECDH"!==t&&"ECDSA"!==t)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==e.type)throw new Error("Error: Expected key type to be public but it was not.");const r=await o.getEngine().crypto.subtle.exportKey("jwk",e);if(!r.x||!r.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const i=a.Convert.FromBase64Url(r.x),n=a.Convert.FromBase64Url(r.y),s=a.Convert.ToBinary(i)+a.Convert.ToBinary(n),c=e,y=a.Convert.FromBinary(s);return{id:a.Convert.ToHex(await o.getEngine().crypto.subtle.digest("SHA-256",y)),key:c,serialized:y}}(t);e.id=r.id,e.key=r.key,e.serialized=r.serialized}class M extends T{constructor(e){super(),this.db=e}static async create(){const e=await h.openDb(this.STORAGE_NAME,1,e=>{e.createObjectStore(this.SESSION_STORAGE),e.createObjectStore(this.IDENTITY_STORAGE),e.createObjectStore(this.REMOTE_STORAGE)});return new M(e)}async loadWrapKey(){const e=await this.db.transaction(M.IDENTITY_STORAGE).objectStore(M.IDENTITY_STORAGE).get("wkey");if(e){if(X()){if(!(e.key instanceof ArrayBuffer))return null;e.key=await o.getEngine().crypto.subtle.importKey("raw",e.key,{name:q.name,length:256},!1,["encrypt","decrypt","wrapKey","unwrapKey"])}q.iv=e.iv}return e||null}async saveWrapKey(e){X()&&(e={key:await o.getEngine().crypto.subtle.exportKey("raw",e.key),iv:e.iv});const t=this.db.transaction(M.IDENTITY_STORAGE,"readwrite");return t.objectStore(M.IDENTITY_STORAGE).put(e,"wkey"),t.complete}async loadIdentity(){const e=await this.db.transaction(M.IDENTITY_STORAGE).objectStore(M.IDENTITY_STORAGE).get("identity");let t=null;if(e){if(B()||X()){const t=await this.loadWrapKey();if(!(t&&t.key.usages.some(e=>"encrypt"===e)&&e.exchangeKey.privateKey instanceof ArrayBuffer))return null;e.exchangeKey.privateKey=await o.getEngine().crypto.subtle.decrypt(q,t.key,e.exchangeKey.privateKey).then(e=>o.getEngine().crypto.subtle.importKey("jwk",JSON.parse(a.Convert.ToUtf8String(e)),R,!1,["deriveKey","deriveBits"])),e.signingKey.privateKey=await o.getEngine().crypto.subtle.decrypt(q,t.key,e.signingKey.privateKey).then(e=>o.getEngine().crypto.subtle.importKey("jwk",JSON.parse(a.Convert.ToUtf8String(e)),U,!1,["sign"])),X()&&(e.exchangeKey.publicKey=await o.getEngine().crypto.subtle.unwrapKey("jwk",e.exchangeKey.publicKey,t.key,q,R,!0,[]),e.signingKey.publicKey=await o.getEngine().crypto.subtle.unwrapKey("jwk",e.signingKey.publicKey,t.key,q,U,!0,["verify"]))}t=await o.Identity.fromJSON(e)}return t}async saveIdentity(e){let t;if(B()||X()){t={key:await o.getEngine().crypto.subtle.generateKey({name:q.name,length:256},X(),["wrapKey","unwrapKey","encrypt","decrypt"]),iv:o.getEngine().crypto.getRandomValues(new Uint8Array(q.iv)).buffer},await this.saveWrapKey(t);const r=await o.getEngine().crypto.subtle.generateKey(e.exchangeKey.privateKey.algorithm,!0,["deriveKey","deriveBits"]);e.exchangeKey.privateKey=r.privateKey,await H(e.exchangeKey.publicKey,r.publicKey);const i=await o.getEngine().crypto.subtle.generateKey(e.signingKey.privateKey.algorithm,!0,["sign","verify"]);e.signingKey.privateKey=i.privateKey,await H(e.signingKey.publicKey,i.publicKey)}const r=await e.toJSON();if(B()||X()){if(!t)throw new Error("WrapKey is empty");r.exchangeKey.privateKey=await o.getEngine().crypto.subtle.wrapKey("jwk",e.exchangeKey.privateKey,t.key,q),r.signingKey.privateKey=await o.getEngine().crypto.subtle.wrapKey("jwk",e.signingKey.privateKey,t.key,q),X()&&(r.exchangeKey.publicKey=await o.getEngine().crypto.subtle.wrapKey("jwk",e.exchangeKey.publicKey.key,t.key,q),r.signingKey.publicKey=await o.getEngine().crypto.subtle.wrapKey("jwk",e.signingKey.publicKey.key,t.key,q))}const i=this.db.transaction(M.IDENTITY_STORAGE,"readwrite");return i.objectStore(M.IDENTITY_STORAGE).put(r,"identity"),i.complete}async loadRemoteIdentity(e){const t=await this.db.transaction(M.REMOTE_STORAGE).objectStore(M.REMOTE_STORAGE).get(e);let r=null;return t&&(r=await o.RemoteIdentity.fromJSON(t)),r}async saveRemoteIdentity(e,t){const r=await t.toJSON(),i=this.db.transaction(M.REMOTE_STORAGE,"readwrite");return i.objectStore(M.REMOTE_STORAGE).put(r,e),i.complete}async loadSession(e){const t=await this.db.transaction(M.SESSION_STORAGE).objectStore(M.SESSION_STORAGE).get(e);let r=null;if(t){const i=await this.loadIdentity();if(!i)throw new Error("Identity is empty");const n=await this.loadRemoteIdentity(e);if(!n)throw new Error("Remote identity is not found");r=await o.AsymmetricRatchet.fromJSON(i,n,t)}return r}async saveSession(e,t){const r=await t.toJSON(),i=this.db.transaction(M.SESSION_STORAGE,"readwrite");return i.objectStore(M.SESSION_STORAGE).put(r,e),i.complete}}M.STORAGE_NAME="webcrypto-remote",M.IDENTITY_STORAGE="identity",M.SESSION_STORAGE="sessions",M.REMOTE_STORAGE="remoteIdentity";t.getEngine=o.getEngine,t.setEngine=o.setEngine,t.BrowserStorage=M,t.CryptoServerError=l,t.MemoryStorage=class extends T{constructor(){super(...arguments),this.remoteIdentities={},this.sessions={}}async loadIdentity(){return this.identity||null}async saveIdentity(e){this.identity=e}async loadRemoteIdentity(e){return this.remoteIdentities[e]||null}async saveRemoteIdentity(e,t){this.remoteIdentities[e]=t}async loadSession(e){return this.sessions[e]||null}async saveSession(e,t){this.sessions[e]=t}},t.RatchetStorage=T,t.SocketCrypto=x,t.SocketProvider=class extends c.EventEmitter{get state(){return this.client.state}constructor(e){super(),this.client=new v(e.storage),this.cardReader=new b(this.client)}connect(e,t){return this.removeAllListeners(),this.client.connect(e,t).on("error",e=>{this.emit("error",e.error)}).on("event",e=>{(async()=>{switch(e.action){case s.ProviderTokenEventProto.ACTION:{const t=await s.ProviderTokenEventProto.importProto(await e.exportProto());this.emit("token",t)}case s.ProviderAuthorizedEventProto.ACTION:{const t=await s.ProviderAuthorizedEventProto.importProto(await e.exportProto());this.emit("auth",t)}}})()}).on("listening",t=>{this.emit("listening",e)}).on("close",e=>{this.emit("close",e.remoteAddress)}),this}close(){this.client.close()}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async info(){const e=new s.ProviderInfoActionProto,t=await this.client.send(e);return await s.ProviderInfoProto.importProto(t)}async challenge(){return this.client.challenge()}async isLoggedIn(){return this.client.isLoggedIn()}async login(){return this.client.login()}async getCrypto(e){const t=new s.ProviderGetCryptoActionProto;return t.cryptoID=e,await this.client.send(t),new x(this.client,e)}}},cgU2:function(e,t,r){"use strict";r.r(t),r.d(t,"AsymmetricRatchet",function(){return F}),r.d(t,"Identity",function(){return j}),r.d(t,"RemoteIdentity",function(){return I}),r.d(t,"setEngine",function(){return f}),r.d(t,"getEngine",function(){return m}),r.d(t,"IdentityProtocol",function(){return N}),r.d(t,"MessageSignedProtocol",function(){return k}),r.d(t,"PreKeyMessageProtocol",function(){return P}),r.d(t,"PreKeyBundleProtocol",function(){return B});var i=r("oJvU"),n=r("mrSG"),o=r("s+3h"),s=r("+qE3");const c="ECDSA",a="ECDH",y="AES-CBC",d="SHA-256",u="HMAC",p=20,h=i.Convert.FromBinary("InfoText"),b=i.Convert.FromBinary("InfoRatchet"),l=i.Convert.FromBinary("InfoMessageKeys");let g=null;function f(e,t){g={crypto:t,name:e}}function m(){if(!g)throw new Error("WebCrypto engine is empty. Use setEngine to resolve it.");return g}"undefined"!==typeof self&&(g={crypto:self.crypto,name:"WebCrypto"});class w{static async generateKeyPair(e){const t=e,r="ECDSA"===e?["sign","verify"]:["deriveKey","deriveBits"],i=await m().crypto.subtle.generateKey({name:t,namedCurve:this.NAMED_CURVE},!1,r),n=await E.create(i.publicKey);return{privateKey:i.privateKey,publicKey:n}}static deriveBytes(e,t){return m().crypto.subtle.deriveBits({name:"ECDH",public:t.key},e,256)}static verify(e,t,r){return m().crypto.subtle.verify({name:"ECDSA",hash:this.DIGEST_ALGORITHM},e.key,r,t)}static async sign(e,t){return m().crypto.subtle.sign({name:"ECDSA",hash:this.DIGEST_ALGORITHM},e,t)}static async ecKeyPairToJson(e){return{privateKey:e.privateKey,publicKey:e.publicKey.key,thumbprint:await e.publicKey.thumbprint()}}static async ecKeyPairFromJson(e){return{privateKey:e.privateKey,publicKey:await E.create(e.publicKey)}}}w.NAMED_CURVE="P-256",w.DIGEST_ALGORITHM="SHA-512";const v={name:"AES-CBC",length:256};class O{static randomBytes(e){const t=new Uint8Array(e);return m().crypto.getRandomValues(t),t.buffer}static digest(e,t){return m().crypto.subtle.digest(e,t)}static encrypt(e,t,r){return m().crypto.subtle.encrypt({name:y,iv:new Uint8Array(r)},e,t)}static decrypt(e,t,r){return m().crypto.subtle.decrypt({name:y,iv:new Uint8Array(r)},e,t)}static importHMAC(e){return m().crypto.subtle.importKey("raw",e,{name:u,hash:{name:d}},!1,["sign","verify"])}static importAES(e){return m().crypto.subtle.importKey("raw",e,v,!1,["encrypt","decrypt"])}static async sign(e,t){return await m().crypto.subtle.sign({name:u,hash:d},e,t)}static async HKDF(e,t=1,r,n=new ArrayBuffer(0)){r||(r=await this.importHMAC(new Uint8Array(32).buffer));const o=await this.sign(r,e),s=(new ArrayBuffer(32+n.byteLength+1),await this.importHMAC(o)),c=[new ArrayBuffer(0)];for(let a=0;a<t;a++)c[a+1]=await this.sign(s,Object(i.combine)(c[a],n,new Uint8Array([a+1]).buffer));return c.slice(1)}}class E{static async create(e){const t=new this,r=e.algorithm.name.toUpperCase();if("ECDH"!==r&&"ECDSA"!==r)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==e.type)throw new Error("Error: Expected key type to be public but it was not.");t.key=e;const n=await m().crypto.subtle.exportKey("jwk",e);if(!n.x||!n.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const o=i.Convert.FromBase64Url(n.x),s=i.Convert.FromBase64Url(n.y),c=i.Convert.ToBinary(o)+i.Convert.ToBinary(s);return t.serialized=i.Convert.FromBinary(c),t.id=await t.thumbprint(),t}static async importKey(e,t){const r=i.Convert.ToBase64Url(e.slice(0,32)),n=i.Convert.ToBase64Url(e.slice(32)),o={crv:w.NAMED_CURVE,kty:"EC",x:r,y:n},s="ECDSA"===t?["verify"]:[],c=await m().crypto.subtle.importKey("jwk",o,{name:t,namedCurve:w.NAMED_CURVE},!0,s);return await E.create(c)}serialize(){return this.serialized}async thumbprint(){const e=await this.serialize(),t=await O.digest("SHA-256",e);return i.Convert.ToHex(t)}async isEqual(e){return!!(e&&e instanceof E)&&Object(i.isEqual)(this.serialized,e.serialized)}}class j{static async fromJSON(e){const t=await w.ecKeyPairFromJson(e.signingKey),r=await w.ecKeyPairFromJson(e.exchangeKey),i=new this(e.id,t,r);return i.createdAt=new Date(e.createdAt),await i.fromJSON(e),i}static async create(e,t=0,r=0){const i=await w.generateKeyPair(c),n=await w.generateKeyPair(a),o=new j(e,i,n);o.createdAt=new Date;for(let s=0;s<r;s++)o.preKeys.push(await w.generateKeyPair("ECDH"));for(let s=0;s<t;s++)o.signedPreKeys.push(await w.generateKeyPair("ECDH"));return o}constructor(e,t,r){this.id=e,this.signingKey=t,this.exchangeKey=r,this.preKeys=[],this.signedPreKeys=[]}async toJSON(){const e=[],t=[];for(const r of this.preKeys)e.push(await w.ecKeyPairToJson(r));for(const r of this.signedPreKeys)t.push(await w.ecKeyPairToJson(r));return{createdAt:this.createdAt.toISOString(),exchangeKey:await w.ecKeyPairToJson(this.exchangeKey),id:this.id,preKeys:e,signedPreKeys:t,signingKey:await w.ecKeyPairToJson(this.signingKey)}}async fromJSON(e){this.id=e.id,this.signingKey=await w.ecKeyPairFromJson(e.signingKey),this.exchangeKey=await w.ecKeyPairFromJson(e.exchangeKey),this.preKeys=[];for(const t of e.preKeys)this.preKeys.push(await w.ecKeyPairFromJson(t));this.signedPreKeys=[];for(const t of e.signedPreKeys)this.signedPreKeys.push(await w.ecKeyPairFromJson(t))}}class I{static fill(e){const t=new I;return t.fill(e),t}static async fromJSON(e){const t=new this;return await t.fromJSON(e),t}fill(e){this.signingKey=e.signingKey,this.exchangeKey=e.exchangeKey,this.signature=e.signature,this.createdAt=e.createdAt}verify(){return w.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async toJSON(){return{createdAt:this.createdAt.toISOString(),exchangeKey:await this.exchangeKey.key,id:this.id,signature:this.signature,signingKey:await this.signingKey.key,thumbprint:await this.signingKey.thumbprint()}}async fromJSON(e){if(this.id=e.id,this.signature=e.signature,this.signingKey=await E.create(e.signingKey),this.exchangeKey=await E.create(e.exchangeKey),this.createdAt=new Date(e.createdAt),!await this.verify())throw new Error("Error: Wrong signature for RemoteIdentity")}}let A=class extends o.b{};Object(n.b)([Object(o.d)({id:0,type:"uint32",defaultValue:1})],A.prototype,"version",void 0),A=Object(n.b)([Object(o.c)({name:"Base"})],A);class K{static async set(e){return new Uint8Array(e.serialize())}static async get(e){return E.importKey(e.buffer,"ECDSA")}}class C{static async set(e){return new Uint8Array(e.serialize())}static async get(e){return E.importKey(e.buffer,"ECDH")}}var S;let N=S=class extends A{static async fill(e){const t=new S;return await t.fill(e),t}async sign(e){this.signature=await w.sign(e,this.exchangeKey.serialize())}async verify(){return await w.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async fill(e){this.signingKey=e.signingKey.publicKey,this.exchangeKey=e.exchangeKey.publicKey,this.createdAt=e.createdAt,await this.sign(e.signingKey.privateKey)}};Object(n.b)([Object(o.d)({id:1,converter:K})],N.prototype,"signingKey",void 0),Object(n.b)([Object(o.d)({id:2,converter:C})],N.prototype,"exchangeKey",void 0),Object(n.b)([Object(o.d)({id:3})],N.prototype,"signature",void 0),Object(n.b)([Object(o.d)({id:4,converter:class{static async set(e){return new Uint8Array(i.Convert.FromString(e.toISOString()))}static async get(e){return new Date(i.Convert.ToString(e))}}})],N.prototype,"createdAt",void 0),N=S=Object(n.b)([Object(o.c)({name:"Identity"})],N);let D=class extends A{};Object(n.b)([Object(o.d)({id:1,converter:C,required:!0})],D.prototype,"senderRatchetKey",void 0),Object(n.b)([Object(o.d)({id:2,type:"uint32",required:!0})],D.prototype,"counter",void 0),Object(n.b)([Object(o.d)({id:3,type:"uint32",required:!0})],D.prototype,"previousCounter",void 0),Object(n.b)([Object(o.d)({id:4,converter:o.a,required:!0})],D.prototype,"cipherText",void 0),D=Object(n.b)([Object(o.c)({name:"Message"})],D);let k=class extends A{async sign(e){this.signature=await this.signHMAC(e)}async verify(e){const t=await this.signHMAC(e);return Object(i.isEqual)(t,this.signature)}async getSignedRaw(){const e=this.receiverKey.serialize(),t=this.senderKey.serialize(),r=await this.message.exportProto();return Object(i.combine)(e,t,r)}async signHMAC(e){const t=await this.getSignedRaw();return await O.sign(e,t)}};Object(n.b)([Object(o.d)({id:1,converter:K,required:!0})],k.prototype,"senderKey",void 0),Object(n.b)([Object(o.d)({id:2,parser:D,required:!0})],k.prototype,"message",void 0),Object(n.b)([Object(o.d)({id:3,required:!0})],k.prototype,"signature",void 0),k=Object(n.b)([Object(o.c)({name:"MessageSigned"})],k);let P=class extends A{};Object(n.b)([Object(o.d)({id:1,type:"uint32",required:!0})],P.prototype,"registrationId",void 0),Object(n.b)([Object(o.d)({id:2,type:"uint32"})],P.prototype,"preKeyId",void 0),Object(n.b)([Object(o.d)({id:3,type:"uint32",required:!0})],P.prototype,"preKeySignedId",void 0),Object(n.b)([Object(o.d)({id:4,converter:C,required:!0})],P.prototype,"baseKey",void 0),Object(n.b)([Object(o.d)({id:5,parser:N,required:!0})],P.prototype,"identity",void 0),Object(n.b)([Object(o.d)({id:6,parser:k,required:!0})],P.prototype,"signedMessage",void 0),P=Object(n.b)([Object(o.c)({name:"PreKeyMessage"})],P);let x=class extends A{};Object(n.b)([Object(o.d)({id:1,type:"uint32",required:!0})],x.prototype,"id",void 0),Object(n.b)([Object(o.d)({id:2,converter:C,required:!0})],x.prototype,"key",void 0),x=Object(n.b)([Object(o.c)({name:"PreKey"})],x);let T=class extends x{async sign(e){this.signature=await w.sign(e,this.key.serialize())}verify(e){return w.verify(e,this.key.serialize(),this.signature)}};Object(n.b)([Object(o.d)({id:3,converter:o.a,required:!0})],T.prototype,"signature",void 0),T=Object(n.b)([Object(o.c)({name:"PreKeySigned"})],T);let B=class extends A{};Object(n.b)([Object(o.d)({id:1,type:"uint32",required:!0})],B.prototype,"registrationId",void 0),Object(n.b)([Object(o.d)({id:2,parser:N,required:!0})],B.prototype,"identity",void 0),Object(n.b)([Object(o.d)({id:3,parser:x})],B.prototype,"preKey",void 0),Object(n.b)([Object(o.d)({id:4,parser:T,required:!0})],B.prototype,"preKeySigned",void 0),B=Object(n.b)([Object(o.c)({name:"PreKeyBundle"})],B);class X{constructor(e=20){this.items=[],this.maxSize=e}get length(){return this.items.length}get latest(){return this.items[this.length-1]}push(e){this.length===this.maxSize&&(this.items=this.items.slice(1)),this.items.push(e)}async toJSON(){const e=[];for(const t of this.items)e.push(await t.toJSON());return e}async fromJSON(e){this.items=e}}const R=new Uint8Array([1]).buffer,U=new Uint8Array([2]).buffer;class q{constructor(e){this.counter=0,this.rootKey=e}static async fromJSON(e){const t=new this(e.rootKey);return t.fromJSON(e),t}async toJSON(){return{counter:this.counter,rootKey:this.rootKey}}async fromJSON(e){this.counter=e.counter,this.rootKey=e.rootKey}async calculateKey(e){const t=await O.sign(e,R),r=await O.sign(e,U);return{cipher:t,rootKey:await O.importHMAC(r)}}async click(){const e=this.rootKey,t=await this.calculateKey(e);return this.rootKey=t.rootKey,this.counter++,t.cipher}}class H extends q{async encrypt(e){const t=await this.click(),r=await O.HKDF(t,3,void 0,l),i=await O.importAES(r[0]),n=await O.importHMAC(r[1]),o=r[2].slice(0,16);return{cipherText:await O.encrypt(i,e,o),hmacKey:n}}}class M extends q{constructor(){super(...arguments),this.keys=[]}async toJSON(){const e=await super.toJSON();return e.keys=this.keys,e}async fromJSON(e){await super.fromJSON(e),this.keys=e.keys}async decrypt(e,t){const r=await this.getKey(t),i=await O.HKDF(r,3,void 0,l),n=await O.importAES(i[0]),o=await O.importHMAC(i[1]),s=i[2].slice(0,16);return{cipherText:await O.decrypt(n,e,s),hmacKey:o}}async getKey(e){for(;this.counter<=e;){const e=await this.click();this.keys.push(e)}return this.keys[e]}}class F extends s.EventEmitter{constructor(){super(),this.counter=0,this.currentStep=new L,this.steps=new G(p),this.promises={}}static async create(e,t){let r;const n=new F;if(t instanceof B){if(!await t.identity.verify())throw new Error("Error: Remote client's identity key is invalid.");if(!await t.preKeySigned.verify(t.identity.signingKey))throw new Error("Error: Remote client's signed prekey is invalid.");n.currentRatchetKey=await n.generateRatchetKey(),n.currentStep.remoteRatchetKey=t.preKeySigned.key,n.remoteIdentity=I.fill(t.identity),n.remoteIdentity.id=t.registrationId,n.remotePreKeyId=t.preKey.id,n.remotePreKeySignedId=t.preKeySigned.id,r=await async function(e,t,r,n,o){const s=await w.deriveBytes(e.exchangeKey.privateKey,n),c=await w.deriveBytes(t.privateKey,r),a=await w.deriveBytes(t.privateKey,n);let y=new ArrayBuffer(0);o&&(y=await w.deriveBytes(t.privateKey,o));const d=new Uint8Array(32);for(let i=0;i<d.length;i++)d[i]=255;const u=d.buffer,p=Object(i.combine)(u,s,c,a,y),b=await O.HKDF(p,1,void 0,h);return await O.importHMAC(b[0])}(e,n.currentRatchetKey,t.identity.exchangeKey,t.preKeySigned.key,t.preKey.key)}else{if(!await t.identity.verify())throw new Error("Error: Remote client's identity key is invalid.");const o=e.signedPreKeys[t.preKeySignedId];if(!o)throw new Error(`Error: PreKey with id ${t.preKeySignedId} not found`);let s;void 0!==t.preKeyId&&(s=e.preKeys[t.preKeyId]),n.remoteIdentity=I.fill(t.identity),n.currentRatchetKey=o,r=await async function(e,t,r,n,o){const s=await w.deriveBytes(t.privateKey,r),c=await w.deriveBytes(e.exchangeKey.privateKey,n),a=await w.deriveBytes(t.privateKey,n);let y=new ArrayBuffer(0);o&&(y=await w.deriveBytes(o,n));const d=new Uint8Array(32);for(let i=0;i<d.length;i++)d[i]=255;const u=d.buffer,p=Object(i.combine)(u,s,c,a,y),b=await O.HKDF(p,1,void 0,h);return await O.importHMAC(b[0])}(e,n.currentRatchetKey,t.identity.exchangeKey,t.signedMessage.message.senderRatchetKey,s&&s.privateKey)}return n.identity=e,n.id=e.id,n.rootKey=r,n}static async fromJSON(e,t,r){const i=new F;return i.identity=e,i.remoteIdentity=t,await i.fromJSON(r),i}on(e,t){return super.on(e,t)}once(e,t){return super.once(e,t)}async decrypt(e){return this.queuePromise("encrypt",async()=>{const t=e.message.senderRatchetKey,r=e.message;if(e.message.previousCounter<this.counter-p)throw new Error("Error: Too old message");let i=this.steps.getStep(t);if(!i){const e=new L;e.remoteRatchetKey=t,this.steps.push(e),this.currentStep=e,i=e}i.receivingChain||(i.receivingChain=await this.createChain(this.currentRatchetKey.privateKey,t,M));const n=await i.receivingChain.decrypt(r.cipherText,r.counter);if(this.update(),e.senderKey=this.remoteIdentity.signingKey,e.receiverKey=this.identity.signingKey.publicKey,!await e.verify(n.hmacKey))throw new Error("Error: The Message did not successfully verify!");return n.cipherText})}async encrypt(e){return this.queuePromise("encrypt",async()=>{if(this.currentStep.receivingChain&&!this.currentStep.sendingChain&&(this.counter++,this.currentRatchetKey=await this.generateRatchetKey()),!this.currentStep.sendingChain){if(!this.currentStep.remoteRatchetKey)throw new Error("currentStep has empty remoteRatchetKey");this.currentStep.sendingChain=await this.createChain(this.currentRatchetKey.privateKey,this.currentStep.remoteRatchetKey,H)}const t=await this.currentStep.sendingChain.encrypt(e);let r;this.update(),0!==this.steps.length||this.currentStep.receivingChain||1!==this.currentStep.sendingChain.counter||((r=new P).registrationId=this.identity.id,r.preKeyId=this.remotePreKeyId,r.preKeySignedId=this.remotePreKeySignedId,r.baseKey=this.currentRatchetKey.publicKey,await r.identity.fill(this.identity));const i=new k;return i.receiverKey=this.remoteIdentity.signingKey,i.senderKey=this.identity.signingKey.publicKey,i.message.cipherText=t.cipherText,i.message.counter=this.currentStep.sendingChain.counter-1,i.message.previousCounter=this.counter,i.message.senderRatchetKey=this.currentRatchetKey.publicKey,await i.sign(t.hmacKey),r?(r.signedMessage=i,r):i})}async hasRatchetKey(e){let t;t=e instanceof E?e:await E.create(e);for(const r of this.steps.items)if(await r.remoteRatchetKey.isEqual(t))return!0;return!1}async toJSON(){return{counter:this.counter,ratchetKey:await w.ecKeyPairToJson(this.currentRatchetKey),remoteIdentity:await this.remoteIdentity.signingKey.thumbprint(),rootKey:this.rootKey,steps:await this.steps.toJSON()}}async fromJSON(e){this.currentRatchetKey=await w.ecKeyPairFromJson(e.ratchetKey),this.counter=e.counter,this.rootKey=e.rootKey;for(const t of e.steps)this.currentStep=await L.fromJSON(t),this.steps.push(this.currentStep)}update(){this.emit("update")}generateRatchetKey(){return w.generateKeyPair("ECDH")}async createChain(e,t,r){const i=await w.deriveBytes(e,t),n=await O.HKDF(i,2,this.rootKey,b),o=await O.importHMAC(n[0]),s=new r(await O.importHMAC(n[1]));return this.rootKey=o,s}queuePromise(e,t){const r=this.promises[e]||Promise.resolve(),i=this.promises[e]=r.then(t,t);return i.then(()=>{this.promises[e]===i&&delete this.promises[e]}),i}}class L{static async fromJSON(e){const t=new this;return await t.fromJSON(e),t}async toJSON(){const e={};return this.remoteRatchetKey&&(e.remoteRatchetKey=this.remoteRatchetKey.key),this.sendingChain&&(e.sendingChain=await this.sendingChain.toJSON()),this.receivingChain&&(e.receivingChain=await this.receivingChain.toJSON()),e}async fromJSON(e){e.remoteRatchetKey&&(this.remoteRatchetKey=await E.create(e.remoteRatchetKey)),e.sendingChain&&(this.sendingChain=await H.fromJSON(e.sendingChain)),e.receivingChain&&(this.receivingChain=await M.fromJSON(e.receivingChain))}}class G extends X{getStep(e){let t;return this.items.some(r=>(r.remoteRatchetKey.id===e.id&&(t=r),!!t)),t}}},eGXv:function(e,t,r){"use strict";r.r(t),r.d(t,"ActionProto",function(){return w}),r.d(t,"AlgorithmProto",function(){return O}),r.d(t,"ArrayStringConverter",function(){return l}),r.d(t,"AuthRequestProto",function(){return C}),r.d(t,"BaseAlgorithmProto",function(){return v}),r.d(t,"BaseProto",function(){return m}),r.d(t,"CardReaderActionProto",function(){return k}),r.d(t,"CardReaderGetReadersActionProto",function(){return P}),r.d(t,"CardReaderInsertEventProto",function(){return T}),r.d(t,"CardReaderRemoveEventProto",function(){return B}),r.d(t,"CertificateStorageClearActionProto",function(){return ue}),r.d(t,"CertificateStorageExportActionProto",function(){return he}),r.d(t,"CertificateStorageGetCRLActionProto",function(){return ge}),r.d(t,"CertificateStorageGetChainActionProto",function(){return le}),r.d(t,"CertificateStorageGetChainResultProto",function(){return se}),r.d(t,"CertificateStorageGetItemActionProto",function(){return ae}),r.d(t,"CertificateStorageGetOCSPActionProto",function(){return me}),r.d(t,"CertificateStorageImportActionProto",function(){return pe}),r.d(t,"CertificateStorageIndexOfActionProto",function(){return be}),r.d(t,"CertificateStorageKeysActionProto",function(){return ye}),r.d(t,"CertificateStorageRemoveItemActionProto",function(){return de}),r.d(t,"CertificateStorageSetItemActionProto",function(){return ce}),r.d(t,"ChainItemProto",function(){return oe}),r.d(t,"CryptoActionProto",function(){return R}),r.d(t,"CryptoCertificateProto",function(){return re}),r.d(t,"CryptoItemProto",function(){return E}),r.d(t,"CryptoKeyPairProto",function(){return I}),r.d(t,"CryptoKeyProto",function(){return j}),r.d(t,"CryptoX509CertificateProto",function(){return ie}),r.d(t,"CryptoX509CertificateRequestProto",function(){return ne}),r.d(t,"DateConverter",function(){return g}),r.d(t,"DecryptActionProto",function(){return et}),r.d(t,"DeriveBitsActionProto",function(){return tt}),r.d(t,"DeriveKeyActionProto",function(){return rt}),r.d(t,"DigestActionProto",function(){return $e}),r.d(t,"EncryptActionProto",function(){return Ze}),r.d(t,"ErrorProto",function(){return A}),r.d(t,"ExportKeyActionProto",function(){return ot}),r.d(t,"GenerateKeyActionProto",function(){return We}),r.d(t,"HexStringConverter",function(){return f}),r.d(t,"ImportKeyActionProto",function(){return st}),r.d(t,"IsLoggedInActionProto",function(){return H}),r.d(t,"KeyStorageClearActionProto",function(){return Ce}),r.d(t,"KeyStorageGetItemActionProto",function(){return Ie}),r.d(t,"KeyStorageIndexOfActionProto",function(){return Se}),r.d(t,"KeyStorageKeysActionProto",function(){return Ae}),r.d(t,"KeyStorageRemoveItemActionProto",function(){return Ke}),r.d(t,"KeyStorageSetItemActionProto",function(){return je}),r.d(t,"LoginActionProto",function(){return U}),r.d(t,"LogoutActionProto",function(){return q}),r.d(t,"OCSPRequestOptionsProto",function(){return fe}),r.d(t,"ProviderAuthorizedEventProto",function(){return Re}),r.d(t,"ProviderCryptoProto",function(){return xe}),r.d(t,"ProviderGetCryptoActionProto",function(){return Xe}),r.d(t,"ProviderInfoActionProto",function(){return Be}),r.d(t,"ProviderInfoProto",function(){return Te}),r.d(t,"ProviderTokenEventProto",function(){return Ue}),r.d(t,"ResetActionProto",function(){return M}),r.d(t,"ResultProto",function(){return K}),r.d(t,"ServerIsLoggedInActionProto",function(){return N}),r.d(t,"ServerLoginActionProto",function(){return S}),r.d(t,"SignActionProto",function(){return Ye}),r.d(t,"UnwrapKeyActionProto",function(){return it}),r.d(t,"VerifyActionProto",function(){return Qe}),r.d(t,"WrapKeyActionProto",function(){return nt});var i,n,o,s,c,a,y,d,u,p=r("78Ih"),h=r("mrSG"),b=r("s+3h");class l{static async set(e){return new Uint8Array(p.a.FromUtf8String(e.join(",")))}static async get(e){return p.a.ToUtf8String(e).split(",")}}class g{static async set(e){return new Uint8Array(p.a.FromUtf8String(e.toISOString()))}static async get(e){return new Date(p.a.ToUtf8String(e))}}class f{static async set(e){return new Uint8Array(p.a.FromHex(e))}static async get(e){return p.a.ToHex(e)}}let m=i=class extends b.b{};m.INDEX=1,Object(h.b)([Object(b.d)({id:i.INDEX++,type:"uint32",required:!0,defaultValue:1})],m.prototype,"version",void 0),m=i=Object(h.b)([Object(b.c)({name:"BaseMessage"})],m);let w=n=class extends m{constructor(){super(),this.action=this.constructor.ACTION}};w.INDEX=m.INDEX,w.ACTION="action",Object(h.b)([Object(b.d)({id:n.INDEX++,type:"string",required:!0})],w.prototype,"action",void 0),Object(h.b)([Object(b.d)({id:n.INDEX++,type:"string",required:!1})],w.prototype,"actionId",void 0),w=n=Object(h.b)([Object(b.c)({name:"Action"})],w);let v=o=class extends m{toAlgorithm(){return{name:this.name}}fromAlgorithm(e){this.name=e.name}};v.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:o.INDEX++,type:"string",required:!0})],v.prototype,"name",void 0),v=o=Object(h.b)([Object(b.c)({name:"BaseAlgorithm"})],v);let O=s=class extends v{toAlgorithm(){const e={},t=this.constructor;for(const r in t.items){if("version"===r)continue;const t=this[r];void 0!==t&&(t instanceof v?t.isEmpty()||(e[r]=t.toAlgorithm()):e[r]=t)}return e}fromAlgorithm(e){e instanceof s&&(e=e.toAlgorithm());const t=this.constructor;for(const r in e)if(t.items&&r in t.items){const i=t.items[r];if(i.parser)switch(i.parser){case v:this[r].fromAlgorithm(e[r]);break;default:throw new Error(`Unsupported parser '${i.parser.name}'`)}else this[r]=e[r]}}};O.INDEX=v.INDEX,Object(h.b)([Object(b.d)({id:s.INDEX++,type:"bytes",parser:v})],O.prototype,"hash",void 0),Object(h.b)([Object(b.d)({id:s.INDEX++,type:"bytes"})],O.prototype,"publicExponent",void 0),Object(h.b)([Object(b.d)({id:s.INDEX++,type:"uint32"})],O.prototype,"modulusLength",void 0),Object(h.b)([Object(b.d)({id:s.INDEX++,type:"uint32"})],O.prototype,"saltLength",void 0),Object(h.b)([Object(b.d)({id:s.INDEX++,type:"bytes"})],O.prototype,"label",void 0),Object(h.b)([Object(b.d)({id:s.INDEX++,type:"string"})],O.prototype,"namedCurve",void 0),Object(h.b)([Object(b.d)({id:s.INDEX++,converter:b.a})],O.prototype,"public",void 0),Object(h.b)([Object(b.d)({id:s.INDEX++,type:"uint32"})],O.prototype,"length",void 0),Object(h.b)([Object(b.d)({id:s.INDEX++})],O.prototype,"iv",void 0),O=s=Object(h.b)([Object(b.c)({name:"Algorithm"})],O);let E=c=class extends m{};E.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:c.INDEX++,type:"string",required:!0})],E.prototype,"providerID",void 0),Object(h.b)([Object(b.d)({id:c.INDEX++,type:"bytes",required:!0,converter:f})],E.prototype,"id",void 0),Object(h.b)([Object(b.d)({id:c.INDEX++,type:"string",required:!0})],E.prototype,"type",void 0),E=c=Object(h.b)([Object(b.c)({name:"CryptoItem"})],E);let j=a=class extends E{};j.INDEX=E.INDEX,Object(h.b)([Object(b.d)({id:a.INDEX++,type:"bytes",required:!0,parser:O})],j.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:a.INDEX++,type:"bool"})],j.prototype,"extractable",void 0),Object(h.b)([Object(b.d)({id:a.INDEX++,type:"string",repeated:!0})],j.prototype,"usages",void 0),j=a=Object(h.b)([Object(b.c)({name:"CryptoKey"})],j);let I=y=class extends m{};I.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:y.INDEX++,name:"privateKey",type:"bytes",parser:j})],I.prototype,"privateKey",void 0),Object(h.b)([Object(b.d)({id:y.INDEX++,name:"publicKey",type:"bytes",parser:j})],I.prototype,"publicKey",void 0),I=y=Object(h.b)([Object(b.c)({name:"CryptoKeyPair"})],I);let A=d=class extends m{constructor(e,t=0,r="error"){super(),e&&(this.message=e,this.code=t,this.type=r)}};A.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:d.INDEX++,type:"uint32",defaultValue:0})],A.prototype,"code",void 0),Object(h.b)([Object(b.d)({id:d.INDEX++,type:"string",defaultValue:"error"})],A.prototype,"type",void 0),Object(h.b)([Object(b.d)({id:d.INDEX++,type:"string",defaultValue:""})],A.prototype,"message",void 0),Object(h.b)([Object(b.d)({id:d.INDEX++,type:"string",defaultValue:"Error"})],A.prototype,"name",void 0),Object(h.b)([Object(b.d)({id:d.INDEX++,type:"string",defaultValue:""})],A.prototype,"stack",void 0),A=d=Object(h.b)([Object(b.c)({name:"Error"})],A);let K=u=class extends w{constructor(e){super(),e&&(this.actionId=e.actionId,this.action=e.action)}};K.INDEX=w.INDEX,Object(h.b)([Object(b.d)({id:u.INDEX++,type:"bool",defaultValue:!1})],K.prototype,"status",void 0),Object(h.b)([Object(b.d)({id:u.INDEX++,type:"bytes",parser:A})],K.prototype,"error",void 0),Object(h.b)([Object(b.d)({id:u.INDEX++,type:"bytes",converter:b.a})],K.prototype,"data",void 0),K=u=Object(h.b)([Object(b.c)({name:"Result"})],K);let C=class extends w{};C.INDEX=w.INDEX,C.ACTION="auth",C=Object(h.b)([Object(b.c)({name:"AuthRequest"})],C);let S=class extends w{};S.INDEX=w.INDEX,S.ACTION="server/login",S=Object(h.b)([Object(b.c)({})],S);let N=class extends w{};var D;N.INDEX=w.INDEX,N.ACTION="server/isLoggedIn",N=Object(h.b)([Object(b.c)({})],N);let k=class extends w{};k.INDEX=w.INDEX,k.ACTION="cardReader",k=Object(h.b)([Object(b.c)({})],k);let P=class extends w{};P.INDEX=w.INDEX,P.ACTION="cardReader/readers",P=Object(h.b)([Object(b.c)({})],P);let x=D=class extends k{constructor(e,t){super(),e&&t&&(this.reader=e,this.atr=t)}};x.INDEX=k.INDEX,Object(h.b)([Object(b.d)({id:D.INDEX++,required:!0,type:"string",defaultValue:""})],x.prototype,"reader",void 0),Object(h.b)([Object(b.d)({id:D.INDEX++,required:!0,converter:f})],x.prototype,"atr",void 0),x=D=Object(h.b)([Object(b.c)({})],x);let T=class extends x{};T.INDEX=x.INDEX,T.ACTION=x.ACTION+"/insert",T=Object(h.b)([Object(b.c)({})],T);let B=class extends x{};var X;B.INDEX=x.INDEX,B.ACTION=x.ACTION+"/remove",B=Object(h.b)([Object(b.c)({})],B);let R=X=class extends w{};R.INDEX=w.INDEX,R.ACTION="crypto",Object(h.b)([Object(b.d)({id:X.INDEX++,required:!0,type:"string"})],R.prototype,"providerID",void 0),R=X=Object(h.b)([Object(b.c)({})],R);let U=class extends R{};U.INDEX=R.INDEX,U.ACTION="crypto/login",U=Object(h.b)([Object(b.c)({})],U);let q=class extends R{};q.INDEX=R.INDEX,q.ACTION="crypto/logout",q=Object(h.b)([Object(b.c)({})],q);let H=class extends R{};H.INDEX=R.INDEX,H.ACTION="crypto/isLoggedIn",H=Object(h.b)([Object(b.c)({})],H);let M=class extends R{};var F,L,G,J,V,z,_,$,W,Y,Q,Z,ee,te;M.INDEX=R.INDEX,M.ACTION="crypto/reset",M=Object(h.b)([Object(b.c)({})],M);let re=F=class extends E{};re.INDEX=E.INDEX,Object(h.b)([Object(b.d)({id:F.INDEX++,required:!0,converter:f})],re.prototype,"id",void 0),Object(h.b)([Object(b.d)({id:F.INDEX++,required:!0,parser:j})],re.prototype,"publicKey",void 0),Object(h.b)([Object(b.d)({id:F.INDEX++,required:!0,type:"string"})],re.prototype,"type",void 0),re=F=Object(h.b)([Object(b.c)({})],re);let ie=L=class extends re{constructor(){super(...arguments),this.type="x509"}};ie.INDEX=re.INDEX,Object(h.b)([Object(b.d)({id:L.INDEX++,required:!0,converter:f})],ie.prototype,"serialNumber",void 0),Object(h.b)([Object(b.d)({id:L.INDEX++,required:!0,type:"string"})],ie.prototype,"issuerName",void 0),Object(h.b)([Object(b.d)({id:L.INDEX++,required:!0,type:"string"})],ie.prototype,"subjectName",void 0),Object(h.b)([Object(b.d)({id:L.INDEX++,required:!0,converter:g})],ie.prototype,"notBefore",void 0),Object(h.b)([Object(b.d)({id:L.INDEX++,required:!0,converter:g})],ie.prototype,"notAfter",void 0),ie=L=Object(h.b)([Object(b.c)({})],ie);let ne=G=class extends re{constructor(){super(...arguments),this.type="request"}};ne.INDEX=re.INDEX,Object(h.b)([Object(b.d)({id:G.INDEX++,required:!0,type:"string"})],ne.prototype,"subjectName",void 0),ne=G=Object(h.b)([Object(b.c)({})],ne);let oe=J=class extends m{};oe.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:J.INDEX++,required:!0,type:"string"})],oe.prototype,"type",void 0),Object(h.b)([Object(b.d)({id:J.INDEX++,required:!0,converter:b.a})],oe.prototype,"value",void 0),oe=J=Object(h.b)([Object(b.c)({})],oe);let se=V=class extends m{constructor(){super(...arguments),this.items=[]}};se.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:V.INDEX++,required:!0,repeated:!0,parser:oe})],se.prototype,"items",void 0),se=V=Object(h.b)([Object(b.c)({})],se);let ce=z=class extends R{};ce.INDEX=R.INDEX,ce.ACTION="crypto/certificateStorage/setItem",Object(h.b)([Object(b.d)({id:z.INDEX++,required:!0,parser:re})],ce.prototype,"item",void 0),ce=z=Object(h.b)([Object(b.c)({})],ce);let ae=_=class extends R{};ae.INDEX=R.INDEX,ae.ACTION="crypto/certificateStorage/getItem",Object(h.b)([Object(b.d)({id:_.INDEX++,required:!0,type:"string"})],ae.prototype,"key",void 0),Object(h.b)([Object(b.d)({id:_.INDEX++,parser:O})],ae.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:_.INDEX++,repeated:!0,type:"string"})],ae.prototype,"keyUsages",void 0),ae=_=Object(h.b)([Object(b.c)({})],ae);let ye=class extends R{};ye.INDEX=R.INDEX,ye.ACTION="crypto/certificateStorage/keys",ye=Object(h.b)([Object(b.c)({})],ye);let de=$=class extends R{};de.INDEX=R.INDEX,de.ACTION="crypto/certificateStorage/removeItem",Object(h.b)([Object(b.d)({id:$.INDEX++,required:!0,type:"string"})],de.prototype,"key",void 0),de=$=Object(h.b)([Object(b.c)({})],de);let ue=class extends R{};ue.INDEX=R.INDEX,ue.ACTION="crypto/certificateStorage/clear",ue=Object(h.b)([Object(b.c)({})],ue);let pe=W=class extends R{};pe.INDEX=R.INDEX,pe.ACTION="crypto/certificateStorage/import",Object(h.b)([Object(b.d)({id:W.INDEX++,required:!0,type:"string"})],pe.prototype,"format",void 0),Object(h.b)([Object(b.d)({id:W.INDEX++,required:!0,converter:b.a})],pe.prototype,"data",void 0),Object(h.b)([Object(b.d)({id:W.INDEX++,required:!0,parser:O})],pe.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:W.INDEX++,repeated:!0,type:"string"})],pe.prototype,"keyUsages",void 0),pe=W=Object(h.b)([Object(b.c)({})],pe);let he=Y=class extends R{};he.INDEX=R.INDEX,he.ACTION="crypto/certificateStorage/export",Object(h.b)([Object(b.d)({id:Y.INDEX++,required:!0,type:"string"})],he.prototype,"format",void 0),Object(h.b)([Object(b.d)({id:Y.INDEX++,required:!0,parser:re})],he.prototype,"item",void 0),he=Y=Object(h.b)([Object(b.c)({})],he);let be=Q=class extends R{};be.INDEX=R.INDEX,be.ACTION="crypto/certificateStorage/indexOf",Object(h.b)([Object(b.d)({id:Q.INDEX++,required:!0,parser:re})],be.prototype,"item",void 0),be=Q=Object(h.b)([Object(b.c)({})],be);let le=class extends R{};le.INDEX=R.INDEX,le.ACTION="crypto/certificateStorage/getChain",Object(h.b)([Object(b.d)({id:ce.INDEX++,required:!0,parser:re})],le.prototype,"item",void 0),le=Object(h.b)([Object(b.c)({})],le);let ge=Z=class extends R{};ge.INDEX=R.INDEX,ge.ACTION="crypto/certificateStorage/getCRL",Object(h.b)([Object(b.d)({id:Z.INDEX++,required:!0,type:"string"})],ge.prototype,"url",void 0),ge=Z=Object(h.b)([Object(b.c)({})],ge);let fe=ee=class extends m{};fe.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:ee.INDEX++,required:!1,type:"string",defaultValue:"get"})],fe.prototype,"method",void 0),fe=ee=Object(h.b)([Object(b.c)({})],fe);let me=te=class extends R{};var we,ve,Oe,Ee;me.INDEX=R.INDEX,me.ACTION="crypto/certificateStorage/getOCSP",Object(h.b)([Object(b.d)({id:te.INDEX++,required:!0,type:"string"})],me.prototype,"url",void 0),Object(h.b)([Object(b.d)({id:te.INDEX++,required:!0,converter:b.a})],me.prototype,"request",void 0),Object(h.b)([Object(b.d)({id:te.INDEX++,required:!1,parser:fe})],me.prototype,"options",void 0),me=te=Object(h.b)([Object(b.c)({})],me);let je=we=class extends R{};je.INDEX=R.INDEX,je.ACTION="crypto/keyStorage/setItem",Object(h.b)([Object(b.d)({id:we.INDEX++,required:!0,parser:j})],je.prototype,"item",void 0),je=we=Object(h.b)([Object(b.c)({})],je);let Ie=ve=class extends R{};Ie.INDEX=R.INDEX,Ie.ACTION="crypto/keyStorage/getItem",Object(h.b)([Object(b.d)({id:ve.INDEX++,required:!0,type:"string"})],Ie.prototype,"key",void 0),Object(h.b)([Object(b.d)({id:ve.INDEX++,parser:O})],Ie.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:ve.INDEX++,type:"bool"})],Ie.prototype,"extractable",void 0),Object(h.b)([Object(b.d)({id:ve.INDEX++,repeated:!0,type:"string"})],Ie.prototype,"keyUsages",void 0),Ie=ve=Object(h.b)([Object(b.c)({})],Ie);let Ae=class extends R{};Ae.INDEX=R.INDEX,Ae.ACTION="crypto/keyStorage/keys",Ae=Object(h.b)([Object(b.c)({})],Ae);let Ke=Oe=class extends R{};Ke.INDEX=R.INDEX,Ke.ACTION="crypto/keyStorage/removeItem",Object(h.b)([Object(b.d)({id:Oe.INDEX++,required:!0,type:"string"})],Ke.prototype,"key",void 0),Ke=Oe=Object(h.b)([Object(b.c)({})],Ke);let Ce=class extends R{};Ce.INDEX=R.INDEX,Ce.ACTION="crypto/keyStorage/clear",Ce=Object(h.b)([Object(b.c)({})],Ce);let Se=Ee=class extends R{};var Ne,De,ke,Pe;Se.INDEX=R.INDEX,Se.ACTION="crypto/keyStorage/indexOf",Object(h.b)([Object(b.d)({id:Ee.INDEX++,required:!0,parser:j})],Se.prototype,"item",void 0),Se=Ee=Object(h.b)([Object(b.c)({})],Se);let xe=Ne=class extends m{constructor(e){super(),e&&Object(p.b)(this,e)}};xe.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:Ne.INDEX++,required:!0,type:"string"})],xe.prototype,"id",void 0),Object(h.b)([Object(b.d)({id:Ne.INDEX++,required:!0,type:"string"})],xe.prototype,"name",void 0),Object(h.b)([Object(b.d)({id:Ne.INDEX++,type:"bool",defaultValue:!1})],xe.prototype,"readOnly",void 0),Object(h.b)([Object(b.d)({id:Ne.INDEX++,repeated:!0,type:"string"})],xe.prototype,"algorithms",void 0),Object(h.b)([Object(b.d)({id:Ne.INDEX++,type:"bool",defaultValue:!1})],xe.prototype,"isRemovable",void 0),Object(h.b)([Object(b.d)({id:Ne.INDEX++,type:"string"})],xe.prototype,"atr",void 0),Object(h.b)([Object(b.d)({id:Ne.INDEX++,type:"bool",defaultValue:!1})],xe.prototype,"isHardware",void 0),xe=Ne=Object(h.b)([Object(b.c)({})],xe);let Te=De=class extends m{};Te.INDEX=m.INDEX,Object(h.b)([Object(b.d)({id:De.INDEX++,type:"string",required:!0})],Te.prototype,"name",void 0),Object(h.b)([Object(b.d)({id:De.INDEX++,repeated:!0,parser:xe})],Te.prototype,"providers",void 0),Te=De=Object(h.b)([Object(b.c)({})],Te);let Be=class extends w{};Be.INDEX=w.INDEX,Be.ACTION="provider/action/info",Be=Object(h.b)([Object(b.c)({})],Be);let Xe=ke=class extends w{};Xe.INDEX=w.INDEX,Xe.ACTION="provider/action/getCrypto",Object(h.b)([Object(b.d)({id:ke.INDEX++,required:!0,type:"string"})],Xe.prototype,"cryptoID",void 0),Xe=ke=Object(h.b)([Object(b.c)({})],Xe);let Re=class extends w{};Re.INDEX=w.INDEX,Re.ACTION="provider/event/authorized",Re=Object(h.b)([Object(b.c)({})],Re);let Ue=Pe=class extends w{constructor(e){super(),e&&Object(p.b)(this,e)}};var qe,He,Me,Fe,Le,Ge,Je,Ve,ze,_e;Ue.INDEX=w.INDEX,Ue.ACTION="provider/event/token",Object(h.b)([Object(b.d)({id:Pe.INDEX++,repeated:!0,parser:xe})],Ue.prototype,"added",void 0),Object(h.b)([Object(b.d)({id:Pe.INDEX++,repeated:!0,parser:xe})],Ue.prototype,"removed",void 0),Object(h.b)([Object(b.d)({id:Pe.INDEX++,type:"bytes",parser:A})],Ue.prototype,"error",void 0),Ue=Pe=Object(h.b)([Object(b.c)({name:"ProviderTokenEvent"})],Ue);let $e=qe=class extends R{};$e.INDEX=R.INDEX,$e.ACTION="crypto/subtle/digest",Object(h.b)([Object(b.d)({id:qe.INDEX++,required:!0,parser:O})],$e.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:qe.INDEX++,required:!0,converter:b.a})],$e.prototype,"data",void 0),$e=qe=Object(h.b)([Object(b.c)({})],$e);let We=He=class extends R{};We.INDEX=R.INDEX,We.ACTION="crypto/subtle/generateKey",Object(h.b)([Object(b.d)({id:He.INDEX++,type:"bytes",required:!0,parser:O})],We.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:He.INDEX++,type:"bool",required:!0})],We.prototype,"extractable",void 0),Object(h.b)([Object(b.d)({id:He.INDEX++,type:"string",repeated:!0})],We.prototype,"usage",void 0),We=He=Object(h.b)([Object(b.c)({})],We);let Ye=Me=class extends R{};Ye.INDEX=R.INDEX,Ye.ACTION="crypto/subtle/sign",Object(h.b)([Object(b.d)({id:Me.INDEX++,required:!0,parser:O})],Ye.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:Me.INDEX++,required:!0,parser:j})],Ye.prototype,"key",void 0),Object(h.b)([Object(b.d)({id:Me.INDEX++,required:!0,converter:b.a})],Ye.prototype,"data",void 0),Ye=Me=Object(h.b)([Object(b.c)({})],Ye);let Qe=Fe=class extends Ye{};Qe.INDEX=Ye.INDEX,Qe.ACTION="crypto/subtle/verify",Object(h.b)([Object(b.d)({id:Fe.INDEX++,required:!0,converter:b.a})],Qe.prototype,"signature",void 0),Qe=Fe=Object(h.b)([Object(b.c)({})],Qe);let Ze=class extends Ye{};Ze.INDEX=Ye.INDEX,Ze.ACTION="crypto/subtle/encrypt",Ze=Object(h.b)([Object(b.c)({})],Ze);let et=class extends Ye{};et.INDEX=Ye.INDEX,et.ACTION="crypto/subtle/decrypt",et=Object(h.b)([Object(b.c)({})],et);let tt=Le=class extends R{};tt.INDEX=R.INDEX,tt.ACTION="crypto/subtle/deriveBits",Object(h.b)([Object(b.d)({id:Le.INDEX++,required:!0,parser:O})],tt.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:Le.INDEX++,required:!0,parser:j})],tt.prototype,"key",void 0),Object(h.b)([Object(b.d)({id:Le.INDEX++,required:!0,type:"uint32"})],tt.prototype,"length",void 0),tt=Le=Object(h.b)([Object(b.c)({})],tt);let rt=Ge=class extends R{};rt.INDEX=R.INDEX,rt.ACTION="crypto/subtle/deriveKey",Object(h.b)([Object(b.d)({id:Ge.INDEX++,required:!0,parser:O})],rt.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:Ge.INDEX++,required:!0,parser:j})],rt.prototype,"key",void 0),Object(h.b)([Object(b.d)({id:Ge.INDEX++,required:!0,parser:O})],rt.prototype,"derivedKeyType",void 0),Object(h.b)([Object(b.d)({id:Ge.INDEX++,type:"bool"})],rt.prototype,"extractable",void 0),Object(h.b)([Object(b.d)({id:Ge.INDEX++,type:"string",repeated:!0})],rt.prototype,"usage",void 0),rt=Ge=Object(h.b)([Object(b.c)({})],rt);let it=Je=class extends R{};it.INDEX=R.INDEX,it.ACTION="crypto/subtle/unwrapKey",Object(h.b)([Object(b.d)({id:Je.INDEX++,required:!0,type:"string"})],it.prototype,"format",void 0),Object(h.b)([Object(b.d)({id:Je.INDEX++,required:!0,converter:b.a})],it.prototype,"wrappedKey",void 0),Object(h.b)([Object(b.d)({id:Je.INDEX++,required:!0,parser:j})],it.prototype,"unwrappingKey",void 0),Object(h.b)([Object(b.d)({id:Je.INDEX++,required:!0,parser:O})],it.prototype,"unwrapAlgorithm",void 0),Object(h.b)([Object(b.d)({id:Je.INDEX++,required:!0,parser:O})],it.prototype,"unwrappedKeyAlgorithm",void 0),Object(h.b)([Object(b.d)({id:Je.INDEX++,type:"bool"})],it.prototype,"extractable",void 0),Object(h.b)([Object(b.d)({id:Je.INDEX++,type:"string",repeated:!0})],it.prototype,"keyUsage",void 0),it=Je=Object(h.b)([Object(b.c)({})],it);let nt=Ve=class extends R{};nt.INDEX=R.INDEX,nt.ACTION="crypto/subtle/wrapKey",Object(h.b)([Object(b.d)({id:Ve.INDEX++,required:!0,type:"string"})],nt.prototype,"format",void 0),Object(h.b)([Object(b.d)({id:Ve.INDEX++,required:!0,parser:j})],nt.prototype,"key",void 0),Object(h.b)([Object(b.d)({id:Ve.INDEX++,required:!0,parser:j})],nt.prototype,"wrappingKey",void 0),Object(h.b)([Object(b.d)({id:Ve.INDEX++,required:!0,parser:O})],nt.prototype,"wrapAlgorithm",void 0),nt=Ve=Object(h.b)([Object(b.c)({})],nt);let ot=ze=class extends R{};ot.INDEX=R.INDEX,ot.ACTION="crypto/subtle/exportKey",Object(h.b)([Object(b.d)({id:ze.INDEX++,type:"string",required:!0})],ot.prototype,"format",void 0),Object(h.b)([Object(b.d)({id:ze.INDEX++,required:!0,parser:j})],ot.prototype,"key",void 0),ot=ze=Object(h.b)([Object(b.c)({})],ot);let st=_e=class extends R{};st.INDEX=R.INDEX,st.ACTION="crypto/subtle/importKey",Object(h.b)([Object(b.d)({id:_e.INDEX++,type:"string",required:!0})],st.prototype,"format",void 0),Object(h.b)([Object(b.d)({id:_e.INDEX++,required:!0,converter:b.a})],st.prototype,"keyData",void 0),Object(h.b)([Object(b.d)({id:_e.INDEX++,required:!0,parser:O})],st.prototype,"algorithm",void 0),Object(h.b)([Object(b.d)({id:_e.INDEX++,required:!0,type:"bool"})],st.prototype,"extractable",void 0),Object(h.b)([Object(b.d)({id:_e.INDEX++,type:"string",repeated:!0})],st.prototype,"keyUsages",void 0),st=_e=Object(h.b)([Object(b.c)({})],st)},oJvU:function(e,t,r){"use strict";r.r(t),function(e){function i(t){return"undefined"!==typeof e?new Uint8Array(t):new Uint8Array(t instanceof ArrayBuffer?t:t.buffer)}r.d(t,"Convert",function(){return n}),r.d(t,"assign",function(){return o}),r.d(t,"combine",function(){return s}),r.d(t,"isEqual",function(){return c});class n{static ToString(e,t="utf8"){const r=i(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(t){const r=i(t);if("undefined"!==typeof btoa){const e=this.ToString(r,"binary");return btoa(e)}return e.from(r).toString("base64")}static FromBase64(t){return t=t.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!==typeof atob?this.FromBinary(atob(t)):new Uint8Array(e.from(t,"base64")).buffer}static FromBase64Url(e){return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return r.buffer}static ToUtf8String(e){const t=i(e),r=String.fromCharCode.apply(null,t);return decodeURIComponent(escape(r))}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.charCodeAt(i);return r.buffer}static ToBinary(e){const t=i(e);let r="";const n=t.length;for(let i=0;i<n;i++)r+=String.fromCharCode(t[i]);return r}static ToHex(e){const t=i(e),r=[],n=t.length;for(let i=0;i<n;i++){const e=t[i].toString(16);r.push(1===e.length?"0"+e:e)}return r.join("")}static FromHex(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2){const i=e.slice(r,r+2);t[r/2]=parseInt(i,16)}return t.buffer}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}}function o(e,...t){const r=arguments[0];for(let i=1;i<arguments.length;i++){const e=arguments[i];for(const t in e)r[t]=e[t]}return r}function s(...e){const t=e.map(e=>e.byteLength).reduce((e,t)=>e+t),r=new Uint8Array(t);let i=0;return e.map(e=>new Uint8Array(e)).forEach(e=>{for(let t=0;t<e.length;t++)r[i++]=e[t]}),r.buffer}function c(e,t){if(!e||!t)return!1;if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),i=new Uint8Array(t);for(let n=0;n<e.byteLength;n++)if(r[n]!==i[n])return!1;return!0}}.call(this,r("tjlA").Buffer)}}]);