{"version":3,"sources":["webpack:///./node_modules/asn1js/build/asn1.js"],"names":["Object","defineProperty","exports","value","RawData","Repeated","Any","Choice","TIME","Duration","DateTime","TimeOfDay","DATE","GeneralizedTime","UTCTime","CharacterString","GeneralString","VisibleString","GraphicString","IA5String","VideotexString","TeletexString","PrintableString","NumericString","UniversalString","BmpString","Utf8String","ObjectIdentifier","Enumerated","Integer","BitString","OctetString","Null","Set","Sequence","Boolean","EndOfContent","Constructed","Primitive","BaseBlock","undefined","fromBER","compareSchema","verifySchema","inputBuffer","inputSchema","verified","result","error","asn1","offset","fromJSON","json","_pvutils","powers2","Uint8Array","LocalBaseBlock","parameters","this","blockLength","getParametersValue","warnings","valueBeforeDecode","slice","ArrayBuffer","blockName","constructor","bufferToHexCodes","byteLength","LocalHexBlock","BaseClass","super","isHexOnly","valueHex","inputOffset","inputLength","checkBufferParams","length","push","sizeOnly","object","toJSON","ex","LocalIdentificationBlock","idBlock","tagClass","tagNumber","isConstructed","retBuf","retView","firstOctet","number","encodedBuf","utilToBase","encodedView","size","i","curView","intBuffer","tagNumberMask","count","tagNumberBufferMaxLength","intTagNumberBuffer","tempBuffer","tempBufferView","set","utilFromBase","LocalLengthBlock","isIndefiniteForm","lenBlock","longFormUsed","lengthBufferView","LocalValueBlock","TypeError","valueBlockType","name","optional","primitiveSchema","valueBlock","resultOffset","idBlockBuf","toBER","valueBlockSizeBuf","lenBlockBuf","valueBlockBuf","utilConcatBuf","indefBuf","indefView","LocalPrimitiveValueBlock","valueHexView","LocalConstructedValueBlock","initialOffset","initialLength","currentOffset","indefiniteLength","returnObject","LocalFromBER","concat","pop","valueBuf","LocalEndOfContentValueBlock","paramaters","LocalBooleanValueBlock","view","utilDecodeTC","call","LocalOctetStringValueBlock","prototype","currentBlockName","octetString","JSON","stringify","LocalBitStringValueBlock","unusedBits","bitString","LocalIntegerValueBlock","valueDec","_value","_valueHex","_valueDec","utilEncodeTC","expectedLength","updatedValueHex","updatedView","viewAdd","first","second","c","firstView","secondView","firstViewCopy","firstViewCopyLength","secondViewCopy","secondViewCopyLength","counter","utilConcatView","power2","n","p","digits","newValue","viewSub","b","firstBit","currentByte","bitNumber","asn1View","flag","byteNumber","charAt","otherValue","isEqualBuffer","integer","toDER","fromDER","LocalSidValueBlock","isFirstSid","tempValueHex","tempView","sidValue","toString","LocalObjectIdentifierValueBlock","fromString","sidBlock","string","pos1","pos2","sid","indexOf","substr","plus","parsedSID","parseInt","isNaN","sidStr","sidArray","LocalUtf8StringValueBlock","fromBuffer","String","fromCharCode","apply","decodeURIComponent","escape","inputString","str","unescape","encodeURIComponent","strLen","charCodeAt","LocalBmpStringValueBlock","copyBuffer","valueView","temp","Uint16Array","strLength","codeBuf","codeView","dif","j","LocalUniversalStringValueBlock","Uint32Array","LocalSimpleStringValueBlock","LocalSimpleStringBlock","year","month","day","hour","minute","fromDate","valueDate","toBuffer","buffer","inputDate","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","Date","UTC","parserArray","exec","outputArray","Array","padNumber","join","millisecond","getUTCMilliseconds","parser","isUTC","timeString","dateTimeString","fractionPart","hourDifference","minuteDifference","Number","valueOf","Error","multiplier","differencePosition","differenceString","fractionPointPosition","fractionPartCheck","fractionResult","Math","floor","tempDate","getUTCDay","local","incomingOffset","newASN1Type","newObject","inputObject","newType","localChangeType","root","inputData","choiceResult","_result","hasOwnProperty","encodedId","schemaView","replace","admission","maxLength","_optional","arrayRoot","data"],"mappings":"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","file":"assets/js/npm.asn1js.1d2964e5.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.RawData = exports.Repeated = exports.Any = exports.Choice = exports.TIME = exports.Duration = exports.DateTime = exports.TimeOfDay = exports.DATE = exports.GeneralizedTime = exports.UTCTime = exports.CharacterString = exports.GeneralString = exports.VisibleString = exports.GraphicString = exports.IA5String = exports.VideotexString = exports.TeletexString = exports.PrintableString = exports.NumericString = exports.UniversalString = exports.BmpString = exports.Utf8String = exports.ObjectIdentifier = exports.Enumerated = exports.Integer = exports.BitString = exports.OctetString = exports.Null = exports.Set = exports.Sequence = exports.Boolean = exports.EndOfContent = exports.Constructed = exports.Primitive = exports.BaseBlock = undefined;\nexports.fromBER = fromBER;\nexports.compareSchema = compareSchema;\nexports.verifySchema = verifySchema;\nexports.fromJSON = fromJSON;\n\nvar _pvutils = require(\"pvutils\");\n\n//**************************************************************************************\n//region Declaration of global variables\n//**************************************************************************************\nconst powers2 = [new Uint8Array([1])]; /* eslint-disable indent */\n/*\r\n * Copyright (c) 2016-2018, Peculiar Ventures\r\n * All rights reserved.\r\n *\r\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of the copyright holder nor the names of its contributors\r\n *    may be used to endorse or promote products derived from this software without\r\n *    specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\r\n * OF SUCH DAMAGE.\r\n *\r\n */\n//**************************************************************************************\n\nconst digitsString = \"0123456789\";\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration for \"LocalBaseBlock\" class\n//**************************************************************************************\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @typedef LocalBaseBlock\r\n * @interface\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n */\nclass LocalBaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalBaseBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueBeforeDecode]\r\n  */\n\tconstructor(parameters = {}) {\n\t\t/**\r\n   * @type {number} blockLength\r\n   */\n\t\tthis.blockLength = (0, _pvutils.getParametersValue)(parameters, \"blockLength\", 0);\n\t\t/**\r\n   * @type {string} error\r\n   */\n\t\tthis.error = (0, _pvutils.getParametersValue)(parameters, \"error\", \"\");\n\t\t/**\r\n   * @type {Array.<string>} warnings\r\n   */\n\t\tthis.warnings = (0, _pvutils.getParametersValue)(parameters, \"warnings\", []);\n\t\t//noinspection JSCheckFunctionSignatures\n\t\t/**\r\n   * @type {ArrayBuffer} valueBeforeDecode\r\n   */\n\t\tif (\"valueBeforeDecode\" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"baseBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n  */\n\ttoJSON() {\n\t\treturn {\n\t\t\tblockName: this.constructor.blockName(),\n\t\t\tblockLength: this.blockLength,\n\t\t\terror: this.error,\n\t\t\twarnings: this.warnings,\n\t\t\tvalueBeforeDecode: (0, _pvutils.bufferToHexCodes)(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n\t\t};\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Description for \"LocalHexBlock\" class\n//**************************************************************************************\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @extends LocalBaseBlock\r\n * @typedef LocalHexBlock\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n * @property {boolean} isHexOnly\r\n * @property {ArrayBuffer} valueHex\r\n */\n//noinspection JSUnusedLocalSymbols\nconst LocalHexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass {\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Constructor for \"LocalHexBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueHex]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\t/**\r\n   * @type {boolean}\r\n   */\n\t\tthis.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", false);\n\t\t/**\r\n   * @type {ArrayBuffer}\r\n   */\n\t\tif (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"hexBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif (intBuffer.length === 0) {\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Copy input buffer to internal buffer\n\t\tthis.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);\n\t\t//endregion\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn inputOffset + inputLength;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\tif (this.isHexOnly !== true) {\n\t\t\tthis.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n\t\t\treturn new ArrayBuffer(0);\n\t\t}\n\n\t\tif (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n\n\t\t//noinspection JSCheckFunctionSignatures\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n};\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of identification block class\n//**************************************************************************************\nclass LocalIdentificationBlock extends LocalHexBlock(LocalBaseBlock) {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalBaseBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {Object} [idBlock]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper();\n\n\t\tif (\"idBlock\" in parameters) {\n\t\t\t//region Properties from hexBlock class\n\t\t\tthis.isHexOnly = (0, _pvutils.getParametersValue)(parameters.idBlock, \"isHexOnly\", false);\n\t\t\tthis.valueHex = (0, _pvutils.getParametersValue)(parameters.idBlock, \"valueHex\", new ArrayBuffer(0));\n\t\t\t//endregion\n\n\t\t\tthis.tagClass = (0, _pvutils.getParametersValue)(parameters.idBlock, \"tagClass\", -1);\n\t\t\tthis.tagNumber = (0, _pvutils.getParametersValue)(parameters.idBlock, \"tagNumber\", -1);\n\t\t\tthis.isConstructed = (0, _pvutils.getParametersValue)(parameters.idBlock, \"isConstructed\", false);\n\t\t} else {\n\t\t\tthis.tagClass = -1;\n\t\t\tthis.tagNumber = -1;\n\t\t\tthis.isConstructed = false;\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"identificationBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\t//region Initial variables\n\t\tlet firstOctet = 0;\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tswitch (this.tagClass) {\n\t\t\tcase 1:\n\t\t\t\tfirstOctet |= 0x00; // UNIVERSAL\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfirstOctet |= 0x40; // APPLICATION\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfirstOctet |= 0x80; // CONTEXT-SPECIFIC\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tfirstOctet |= 0xC0; // PRIVATE\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.error = \"Unknown tag class\";\n\t\t\t\treturn new ArrayBuffer(0);\n\t\t}\n\n\t\tif (this.isConstructed) firstOctet |= 0x20;\n\n\t\tif (this.tagNumber < 31 && !this.isHexOnly) {\n\t\t\tretBuf = new ArrayBuffer(1);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tif (!sizeOnly) {\n\t\t\t\tlet number = this.tagNumber;\n\t\t\t\tnumber &= 0x1F;\n\t\t\t\tfirstOctet |= number;\n\n\t\t\t\tretView[0] = firstOctet;\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tif (this.isHexOnly === false) {\n\t\t\tconst encodedBuf = (0, _pvutils.utilToBase)(this.tagNumber, 7);\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tconst size = encodedBuf.byteLength;\n\n\t\t\tretBuf = new ArrayBuffer(size + 1);\n\t\t\tretView = new Uint8Array(retBuf);\n\t\t\tretView[0] = firstOctet | 0x1F;\n\n\t\t\tif (!sizeOnly) {\n\t\t\t\tfor (let i = 0; i < size - 1; i++) retView[i + 1] = encodedView[i] | 0x80;\n\n\t\t\t\tretView[size] = encodedView[size - 1];\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n\t\tretView = new Uint8Array(retBuf);\n\n\t\tretView[0] = firstOctet | 0x1F;\n\n\t\tif (sizeOnly === false) {\n\t\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\t\tfor (let i = 0; i < curView.length - 1; i++) retView[i + 1] = curView[i] | 0x80;\n\n\t\t\tretView[this.valueHex.byteLength] = curView[curView.length - 1];\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number}\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif (intBuffer.length === 0) {\n\t\t\tthis.error = \"Zero buffer length\";\n\t\t\treturn -1;\n\t\t}\n\t\t//endregion\n\n\t\t//region Find tag class\n\t\tconst tagClassMask = intBuffer[0] & 0xC0;\n\n\t\tswitch (tagClassMask) {\n\t\t\tcase 0x00:\n\t\t\t\tthis.tagClass = 1; // UNIVERSAL\n\t\t\t\tbreak;\n\t\t\tcase 0x40:\n\t\t\t\tthis.tagClass = 2; // APPLICATION\n\t\t\t\tbreak;\n\t\t\tcase 0x80:\n\t\t\t\tthis.tagClass = 3; // CONTEXT-SPECIFIC\n\t\t\t\tbreak;\n\t\t\tcase 0xC0:\n\t\t\t\tthis.tagClass = 4; // PRIVATE\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.error = \"Unknown tag class\";\n\t\t\t\treturn -1;\n\t\t}\n\t\t//endregion\n\n\t\t//region Find it's constructed or not\n\t\tthis.isConstructed = (intBuffer[0] & 0x20) === 0x20;\n\t\t//endregion\n\n\t\t//region Find tag number\n\t\tthis.isHexOnly = false;\n\n\t\tconst tagNumberMask = intBuffer[0] & 0x1F;\n\n\t\t//region Simple case (tag number < 31)\n\t\tif (tagNumberMask !== 0x1F) {\n\t\t\tthis.tagNumber = tagNumberMask;\n\t\t\tthis.blockLength = 1;\n\t\t}\n\t\t//endregion\n\t\t//region Tag number bigger or equal to 31\n\t\telse {\n\t\t\t\tlet count = 1;\n\n\t\t\t\tthis.valueHex = new ArrayBuffer(255);\n\t\t\t\tlet tagNumberBufferMaxLength = 255;\n\t\t\t\tlet intTagNumberBuffer = new Uint8Array(this.valueHex);\n\n\t\t\t\t//noinspection JSBitwiseOperatorUsage\n\t\t\t\twhile (intBuffer[count] & 0x80) {\n\t\t\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n\t\t\t\t\tcount++;\n\n\t\t\t\t\tif (count >= intBuffer.length) {\n\t\t\t\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\t//region In case if tag number length is greater than 255 bytes (rare but possible case)\n\t\t\t\t\tif (count === tagNumberBufferMaxLength) {\n\t\t\t\t\t\ttagNumberBufferMaxLength += 255;\n\n\t\t\t\t\t\tconst tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n\t\t\t\t\t\tconst tempBufferView = new Uint8Array(tempBuffer);\n\n\t\t\t\t\t\tfor (let i = 0; i < intTagNumberBuffer.length; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n\t\t\t\t\t\tthis.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n\t\t\t\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\t\t\t\t}\n\n\t\t\t\tthis.blockLength = count + 1;\n\t\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n\n\t\t\t\t//region Cut buffer\n\t\t\t\tconst tempBuffer = new ArrayBuffer(count);\n\t\t\t\tconst tempBufferView = new Uint8Array(tempBuffer);\n\n\t\t\t\tfor (let i = 0; i < count; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n\t\t\t\tthis.valueHex = new ArrayBuffer(count);\n\t\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\n\t\t\t\tintTagNumberBuffer.set(tempBufferView);\n\t\t\t\t//endregion\n\n\t\t\t\t//region Try to convert long tag number to short form\n\t\t\t\tif (this.blockLength <= 9) this.tagNumber = (0, _pvutils.utilFromBase)(intTagNumberBuffer, 7);else {\n\t\t\t\t\tthis.isHexOnly = true;\n\t\t\t\t\tthis.warnings.push(\"Tag too long, represented as hex-coded\");\n\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t}\n\t\t//endregion\n\t\t//endregion\n\n\t\t//region Check if constructed encoding was using for primitive type\n\t\tif (this.tagClass === 1 && this.isConstructed) {\n\t\t\tswitch (this.tagNumber) {\n\t\t\t\tcase 1: // Boolean\n\t\t\t\tcase 2: // REAL\n\t\t\t\tcase 5: // Null\n\t\t\t\tcase 6: // OBJECT IDENTIFIER\n\t\t\t\tcase 9: // REAL\n\t\t\t\tcase 14: // Time\n\t\t\t\tcase 23:\n\t\t\t\tcase 24:\n\t\t\t\tcase 31:\n\t\t\t\tcase 32:\n\t\t\t\tcase 33:\n\t\t\t\tcase 34:\n\t\t\t\t\tthis.error = \"Constructed encoding used for primitive type\";\n\t\t\t\t\treturn -1;\n\t\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\treturn inputOffset + this.blockLength; // Return current offset in input buffer\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {{blockName: string,\r\n  *  tagClass: number,\r\n  *  tagNumber: number,\r\n  *  isConstructed: boolean,\r\n  *  isHexOnly: boolean,\r\n  *  valueHex: ArrayBuffer,\r\n  *  blockLength: number,\r\n  *  error: string, warnings: Array.<string>,\r\n  *  valueBeforeDecode: string}}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.tagClass = this.tagClass;\n\t\tobject.tagNumber = this.tagNumber;\n\t\tobject.isConstructed = this.isConstructed;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of length block class\n//**************************************************************************************\nclass LocalLengthBlock extends LocalBaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalLengthBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {Object} [lenBlock]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper();\n\n\t\tif (\"lenBlock\" in parameters) {\n\t\t\tthis.isIndefiniteForm = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"isIndefiniteForm\", false);\n\t\t\tthis.longFormUsed = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"longFormUsed\", false);\n\t\t\tthis.length = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"length\", 0);\n\t\t} else {\n\t\t\tthis.isIndefiniteForm = false;\n\t\t\tthis.longFormUsed = false;\n\t\t\tthis.length = 0;\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"lengthBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number}\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif (intBuffer.length === 0) {\n\t\t\tthis.error = \"Zero buffer length\";\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (intBuffer[0] === 0xFF) {\n\t\t\tthis.error = \"Length block 0xFF is reserved by standard\";\n\t\t\treturn -1;\n\t\t}\n\t\t//endregion\n\n\t\t//region Check for length form type\n\t\tthis.isIndefiniteForm = intBuffer[0] === 0x80;\n\t\t//endregion\n\n\t\t//region Stop working in case of indefinite length form\n\t\tif (this.isIndefiniteForm === true) {\n\t\t\tthis.blockLength = 1;\n\t\t\treturn inputOffset + this.blockLength;\n\t\t}\n\t\t//endregion\n\n\t\t//region Check is long form of length encoding using\n\t\tthis.longFormUsed = !!(intBuffer[0] & 0x80);\n\t\t//endregion\n\n\t\t//region Stop working in case of short form of length value\n\t\tif (this.longFormUsed === false) {\n\t\t\tthis.length = intBuffer[0];\n\t\t\tthis.blockLength = 1;\n\t\t\treturn inputOffset + this.blockLength;\n\t\t}\n\t\t//endregion\n\n\t\t//region Calculate length value in case of long form\n\t\tconst count = intBuffer[0] & 0x7F;\n\n\t\tif (count > 8) // Too big length value\n\t\t\t{\n\t\t\t\tthis.error = \"Too big integer\";\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\tif (count + 1 > intBuffer.length) {\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\treturn -1;\n\t\t}\n\n\t\tconst lengthBufferView = new Uint8Array(count);\n\n\t\tfor (let i = 0; i < count; i++) lengthBufferView[i] = intBuffer[i + 1];\n\n\t\tif (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n\n\t\tthis.length = (0, _pvutils.utilFromBase)(lengthBufferView, 8);\n\n\t\tif (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unneccesary usage of long length form\");\n\n\t\tthis.blockLength = count + 1;\n\t\t//endregion\n\n\t\treturn inputOffset + this.blockLength; // Return current offset in input buffer\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\t//region Initial variables\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tif (this.length > 127) this.longFormUsed = true;\n\n\t\tif (this.isIndefiniteForm) {\n\t\t\tretBuf = new ArrayBuffer(1);\n\n\t\t\tif (sizeOnly === false) {\n\t\t\t\tretView = new Uint8Array(retBuf);\n\t\t\t\tretView[0] = 0x80;\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tif (this.longFormUsed === true) {\n\t\t\tconst encodedBuf = (0, _pvutils.utilToBase)(this.length, 8);\n\n\t\t\tif (encodedBuf.byteLength > 127) {\n\t\t\t\tthis.error = \"Too big length\";\n\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t}\n\n\t\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n\n\t\t\tif (sizeOnly === true) return retBuf;\n\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tretView[0] = encodedBuf.byteLength | 0x80;\n\n\t\t\tfor (let i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(1);\n\n\t\tif (sizeOnly === false) {\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tretView[0] = this.length;\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\n\t\tobject.longFormUsed = this.longFormUsed;\n\t\tobject.length = this.length;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of value block class\n//**************************************************************************************\nclass LocalValueBlock extends LocalBaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"valueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number}\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Throw an exception for a function which needs to be specified in extended classes\n\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"LocalValueBlock\\\"\");\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\t//region Throw an exception for a function which needs to be specified in extended classes\n\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"LocalValueBlock\\\"\");\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic ASN.1 block class\n//**************************************************************************************\nclass BaseBlock extends LocalBaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"BaseBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {Object} [primitiveSchema]\r\n  * @property {string} [name]\r\n  * @property {boolean} [optional]\r\n  * @param valueBlockType Type of value block\r\n  */\n\tconstructor(parameters = {}, valueBlockType = LocalValueBlock) {\n\t\tsuper(parameters);\n\n\t\tif (\"name\" in parameters) this.name = parameters.name;\n\t\tif (\"optional\" in parameters) this.optional = parameters.optional;\n\t\tif (\"primitiveSchema\" in parameters) this.primitiveSchema = parameters.primitiveSchema;\n\n\t\tthis.idBlock = new LocalIdentificationBlock(parameters);\n\t\tthis.lenBlock = new LocalLengthBlock(parameters);\n\t\tthis.valueBlock = new valueBlockType(parameters);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"BaseBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number}\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\tif (resultOffset === -1) {\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\tlet retBuf;\n\n\t\tconst idBlockBuf = this.idBlock.toBER(sizeOnly);\n\t\tconst valueBlockSizeBuf = this.valueBlock.toBER(true);\n\n\t\tthis.lenBlock.length = valueBlockSizeBuf.byteLength;\n\t\tconst lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n\n\t\tretBuf = (0, _pvutils.utilConcatBuf)(idBlockBuf, lenBlockBuf);\n\n\t\tlet valueBlockBuf;\n\n\t\tif (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n\n\t\tretBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBlockBuf);\n\n\t\tif (this.lenBlock.isIndefiniteForm === true) {\n\t\t\tconst indefBuf = new ArrayBuffer(2);\n\n\t\t\tif (sizeOnly === false) {\n\t\t\t\tconst indefView = new Uint8Array(indefBuf);\n\n\t\t\t\tindefView[0] = 0x00;\n\t\t\t\tindefView[1] = 0x00;\n\t\t\t}\n\n\t\t\tretBuf = (0, _pvutils.utilConcatBuf)(retBuf, indefBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.idBlock = this.idBlock.toJSON();\n\t\tobject.lenBlock = this.lenBlock.toJSON();\n\t\tobject.valueBlock = this.valueBlock.toJSON();\n\n\t\tif (\"name\" in this) object.name = this.name;\n\t\tif (\"optional\" in this) object.optional = this.optional;\n\t\tif (\"primitiveSchema\" in this) object.primitiveSchema = this.primitiveSchema.toJSON();\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\nexports.BaseBlock = BaseBlock; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all PRIMITIVE types\n//**************************************************************************************\n\nclass LocalPrimitiveValueBlock extends LocalValueBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalPrimitiveValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueBeforeDecode]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\t//region Variables from \"hexBlock\" class\n\t\tif (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n\n\t\tthis.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", true);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number}\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif (intBuffer.length === 0) {\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Copy input buffer into internal buffer\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\n\t\tconst valueHexView = new Uint8Array(this.valueHex);\n\n\t\tfor (let i = 0; i < intBuffer.length; i++) valueHexView[i] = intBuffer[i];\n\t\t//endregion\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn inputOffset + inputLength;\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"PrimitiveValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n\t\tobject.isHexOnly = this.isHexOnly;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass Primitive extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Primitive\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueHex]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalPrimitiveValueBlock);\n\n\t\tthis.idBlock.isConstructed = false;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"PRIMITIVE\";\n\t}\n\t//**********************************************************************************\n}\nexports.Primitive = Primitive; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all CONSTRUCTED types\n//**************************************************************************************\n\nclass LocalConstructedValueBlock extends LocalValueBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalConstructedValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.value = (0, _pvutils.getParametersValue)(parameters, \"value\", []);\n\t\tthis.isIndefiniteForm = (0, _pvutils.getParametersValue)(parameters, \"isIndefiniteForm\", false);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number}\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Store initial offset and length\n\t\tconst initialOffset = inputOffset;\n\t\tconst initialLength = inputLength;\n\t\t//endregion\n\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif (intBuffer.length === 0) {\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Aux function\n\t\tfunction checkLen(indefiniteLength, length) {\n\t\t\tif (indefiniteLength === true) return 1;\n\n\t\t\treturn length;\n\t\t}\n\t\t//endregion\n\n\t\tlet currentOffset = inputOffset;\n\n\t\twhile (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n\t\t\tconst returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\t\t\tif (returnObject.offset === -1) {\n\t\t\t\tthis.error = returnObject.result.error;\n\t\t\t\tthis.warnings.concat(returnObject.result.warnings);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcurrentOffset = returnObject.offset;\n\n\t\t\tthis.blockLength += returnObject.result.blockLength;\n\t\t\tinputLength -= returnObject.result.blockLength;\n\n\t\t\tthis.value.push(returnObject.result);\n\n\t\t\tif (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;\n\t\t}\n\n\t\tif (this.isIndefiniteForm === true) {\n\t\t\tif (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push(\"No EndOfContent block encoded\");\n\t\t}\n\n\t\t//region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\t\tthis.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);\n\t\t//endregion\n\n\t\treturn currentOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\tlet retBuf = new ArrayBuffer(0);\n\n\t\tfor (let i = 0; i < this.value.length; i++) {\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\tretBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"ConstructedValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\n\t\tobject.value = [];\n\t\tfor (let i = 0; i < this.value.length; i++) object.value.push(this.value[i].toJSON());\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass Constructed extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Constructed\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalConstructedValueBlock);\n\n\t\tthis.idBlock.isConstructed = true;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"CONSTRUCTED\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number}\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\tif (resultOffset === -1) {\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n}\nexports.Constructed = Constructed; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 EndOfContent type class\n//**************************************************************************************\n\nclass LocalEndOfContentValueBlock extends LocalValueBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalEndOfContentValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number}\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region There is no \"value block\" for EndOfContent type and we need to return the same offset\n\t\treturn inputOffset;\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\treturn new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"EndOfContentValueBlock\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass EndOfContent extends BaseBlock {\n\t//**********************************************************************************\n\tconstructor(paramaters = {}) {\n\t\tsuper(paramaters, LocalEndOfContentValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 0; // EndOfContent\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"EndOfContent\";\n\t}\n\t//**********************************************************************************\n}\nexports.EndOfContent = EndOfContent; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Boolean type class\n//**************************************************************************************\n\nclass LocalBooleanValueBlock extends LocalValueBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalBooleanValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.value = (0, _pvutils.getParametersValue)(parameters, \"value\", false);\n\t\tthis.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", false);\n\n\t\tif (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else {\n\t\t\tthis.valueHex = new ArrayBuffer(1);\n\t\t\tif (this.value === true) {\n\t\t\t\tconst view = new Uint8Array(this.valueHex);\n\t\t\t\tview[0] = 0xFF;\n\t\t\t}\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\tif (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n\n\t\tthis.isHexOnly = true;\n\n\t\t//region Copy input buffer to internal array\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\n\t\tconst view = new Uint8Array(this.valueHex);\n\n\t\tfor (let i = 0; i < intBuffer.length; i++) view[i] = intBuffer[i];\n\t\t//endregion\n\n\t\tif (_pvutils.utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn inputOffset + inputLength;\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\treturn this.valueHex;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"BooleanValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass Boolean extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Boolean\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalBooleanValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 1; // Boolean\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Boolean\";\n\t}\n\t//**********************************************************************************\n}\nexports.Boolean = Boolean; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Sequence and Set type classes\n//**************************************************************************************\n\nclass Sequence extends Constructed {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Sequence\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 16; // Sequence\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Sequence\";\n\t}\n\t//**********************************************************************************\n}\nexports.Sequence = Sequence; //**************************************************************************************\n\nclass Set extends Constructed {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Set\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 17; // Set\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Set\";\n\t}\n\t//**********************************************************************************\n}\nexports.Set = Set; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Null type class\n//**************************************************************************************\n\nclass Null extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Null\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 5; // Null\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Null\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tif (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tthis.blockLength += inputLength;\n\n\t\tif (inputOffset + inputLength > inputBuffer.byteLength) {\n\t\t\tthis.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn inputOffset + inputLength;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\tconst retBuf = new ArrayBuffer(2);\n\n\t\tif (sizeOnly === true) return retBuf;\n\n\t\tconst retView = new Uint8Array(retBuf);\n\t\tretView[0] = 0x05;\n\t\tretView[1] = 0x00;\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n}\nexports.Null = Null; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 OctetString type class\n//**************************************************************************************\n\nclass LocalOctetStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock) {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalOctetStringValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueHex]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.isConstructed = (0, _pvutils.getParametersValue)(parameters, \"isConstructed\", false);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tlet resultOffset = 0;\n\n\t\tif (this.isConstructed === true) {\n\t\t\tthis.isHexOnly = false;\n\n\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n\t\t\tif (resultOffset === -1) return resultOffset;\n\n\t\t\tfor (let i = 0; i < this.value.length; i++) {\n\t\t\t\tconst currentBlockName = this.value[i].constructor.blockName();\n\n\t\t\t\tif (currentBlockName === EndOfContent.blockName()) {\n\t\t\t\t\tif (this.isIndefiniteForm === true) break;else {\n\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (currentBlockName !== OctetString.blockName()) {\n\t\t\t\t\tthis.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.isHexOnly = true;\n\n\t\t\tresultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t\tthis.blockLength = inputLength;\n\t\t}\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\tif (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n\n\t\tlet retBuf = new ArrayBuffer(this.valueHex.byteLength);\n\n\t\tif (sizeOnly === true) return retBuf;\n\n\t\tif (this.valueHex.byteLength === 0) return retBuf;\n\n\t\tretBuf = this.valueHex.slice(0);\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"OctetStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.isConstructed = this.isConstructed;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass OctetString extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"OctetString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalOctetStringValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 4; // OctetString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\t//region Ability to encode empty OCTET STRING\n\t\tif (inputLength === 0) {\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"OctetString\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Checking that two OCTETSTRINGs are equal\r\n  * @param {OctetString} octetString\r\n  */\n\tisEqual(octetString) {\n\t\t//region Check input type\n\t\tif (octetString instanceof OctetString === false) return false;\n\t\t//endregion\n\n\t\t//region Compare two JSON strings\n\t\tif (JSON.stringify(this) !== JSON.stringify(octetString)) return false;\n\t\t//endregion\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n}\nexports.OctetString = OctetString; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 BitString type class\n//**************************************************************************************\n\nclass LocalBitStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock) {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalBitStringValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueHex]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.unusedBits = (0, _pvutils.getParametersValue)(parameters, \"unusedBits\", 0);\n\t\tthis.isConstructed = (0, _pvutils.getParametersValue)(parameters, \"isConstructed\", false);\n\t\tthis.blockLength = this.valueHex.byteLength;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Ability to decode zero-length BitString value\n\t\tif (inputLength === 0) return inputOffset;\n\t\t//endregion\n\n\t\tlet resultOffset = -1;\n\n\t\t//region If the BISTRING supposed to be a constructed value\n\t\tif (this.isConstructed === true) {\n\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n\t\t\tif (resultOffset === -1) return resultOffset;\n\n\t\t\tfor (let i = 0; i < this.value.length; i++) {\n\t\t\t\tconst currentBlockName = this.value[i].constructor.blockName();\n\n\t\t\t\tif (currentBlockName === EndOfContent.blockName()) {\n\t\t\t\t\tif (this.isIndefiniteForm === true) break;else {\n\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (currentBlockName !== BitString.blockName()) {\n\t\t\t\t\tthis.error = \"BIT STRING may consists of BIT STRINGs only\";\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {\n\t\t\t\t\tthis.error = \"Usign of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tthis.unusedBits = this.value[i].valueBlock.unusedBits;\n\t\t\t\tif (this.unusedBits > 7) {\n\t\t\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//endregion\n\t\t//region If the BitString supposed to be a primitive value\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t//endregion\n\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\tthis.unusedBits = intBuffer[0];\n\n\t\tif (this.unusedBits > 7) {\n\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\n\t\t\treturn -1;\n\t\t}\n\n\t\t//region Copy input buffer to internal buffer\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length - 1);\n\t\tconst view = new Uint8Array(this.valueHex);\n\t\tfor (let i = 0; i < inputLength - 1; i++) view[i] = intBuffer[i + 1];\n\t\t//endregion\n\n\t\tthis.blockLength = intBuffer.length;\n\n\t\treturn inputOffset + inputLength;\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\tif (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n\n\t\tif (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);\n\n\t\tif (this.valueHex.byteLength === 0) return new ArrayBuffer(0);\n\n\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\tconst retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n\t\tconst retView = new Uint8Array(retBuf);\n\n\t\tretView[0] = this.unusedBits;\n\n\t\tfor (let i = 0; i < this.valueHex.byteLength; i++) retView[i + 1] = curView[i];\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"BitStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.unusedBits = this.unusedBits;\n\t\tobject.isConstructed = this.isConstructed;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass BitString extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"BitString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalBitStringValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 3; // BitString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"BitString\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t//region Ability to encode empty BitString\n\t\tif (inputLength === 0) return inputOffset;\n\t\t//endregion\n\n\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Checking that two BITSTRINGs are equal\r\n  * @param {BitString} bitString\r\n  */\n\tisEqual(bitString) {\n\t\t//region Check input type\n\t\tif (bitString instanceof BitString === false) return false;\n\t\t//endregion\n\n\t\t//region Compare two JSON strings\n\t\tif (JSON.stringify(this) !== JSON.stringify(bitString)) return false;\n\t\t//endregion\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n}\nexports.BitString = BitString; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Integer type class\n//**************************************************************************************\n/**\r\n * @extends LocalValueBlock\r\n */\n\nclass LocalIntegerValueBlock extends LocalHexBlock(LocalValueBlock) {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalIntegerValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueHex]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tif (\"value\" in parameters) this.valueDec = parameters.value;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Setter for \"valueHex\"\r\n  * @param {ArrayBuffer} _value\r\n  */\n\tset valueHex(_value) {\n\t\tthis._valueHex = _value.slice(0);\n\n\t\tif (_value.byteLength >= 4) {\n\t\t\tthis.warnings.push(\"Too big Integer for decoding, hex only\");\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis._valueDec = 0;\n\t\t} else {\n\t\t\tthis.isHexOnly = false;\n\n\t\t\tif (_value.byteLength > 0) this._valueDec = _pvutils.utilDecodeTC.call(this);\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Getter for \"valueHex\"\r\n  * @returns {ArrayBuffer}\r\n  */\n\tget valueHex() {\n\t\treturn this._valueHex;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Getter for \"valueDec\"\r\n  * @param {number} _value\r\n  */\n\tset valueDec(_value) {\n\t\tthis._valueDec = _value;\n\n\t\tthis.isHexOnly = false;\n\t\tthis._valueHex = (0, _pvutils.utilEncodeTC)(_value);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Getter for \"valueDec\"\r\n  * @returns {number}\r\n  */\n\tget valueDec() {\n\t\treturn this._valueDec;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from DER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n\t\tconst offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n\t\tif (offset === -1) return offset;\n\n\t\tconst view = new Uint8Array(this._valueHex);\n\n\t\tif (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t} else {\n\t\t\tif (expectedLength !== 0) {\n\t\t\t\tif (this._valueHex.byteLength < expectedLength) {\n\t\t\t\t\tif (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;\n\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(expectedLength);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView.set(view, expectedLength - this._valueHex.byteLength);\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn offset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoDER(sizeOnly = false) {\n\t\tconst view = new Uint8Array(this._valueHex);\n\n\t\tswitch (true) {\n\t\t\tcase (view[0] & 0x80) !== 0:\n\t\t\t\t{\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView[0] = 0x00;\n\t\t\t\t\tupdatedView.set(view, 1);\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase view[0] === 0x00 && (view[1] & 0x80) === 0:\n\t\t\t\t{\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\n\t\treturn this.toBER(sizeOnly);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tconst resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\tif (resultOffset === -1) return resultOffset;\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn inputOffset + inputLength;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\t//noinspection JSCheckFunctionSignatures\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"IntegerValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.valueDec = this.valueDec;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convert current value to decimal string representation\r\n  */\n\ttoString() {\n\t\t//region Aux functions\n\t\tfunction viewAdd(first, second) {\n\t\t\t//region Initial variables\n\t\t\tconst c = new Uint8Array([0]);\n\n\t\t\tlet firstView = new Uint8Array(first);\n\t\t\tlet secondView = new Uint8Array(second);\n\n\t\t\tlet firstViewCopy = firstView.slice(0);\n\t\t\tconst firstViewCopyLength = firstViewCopy.length - 1;\n\t\t\tlet secondViewCopy = secondView.slice(0);\n\t\t\tconst secondViewCopyLength = secondViewCopy.length - 1;\n\n\t\t\tlet value = 0;\n\n\t\t\tconst max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n\n\t\t\tlet counter = 0;\n\t\t\t//endregion\n\n\t\t\tfor (let i = max; i >= 0; i--, counter++) {\n\t\t\t\tswitch (true) {\n\t\t\t\t\tcase counter < secondViewCopy.length:\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + c[0];\n\t\t\t\t}\n\n\t\t\t\tc[0] = value / 10;\n\n\t\t\t\tswitch (true) {\n\t\t\t\t\tcase counter >= firstViewCopy.length:\n\t\t\t\t\t\tfirstViewCopy = (0, _pvutils.utilConcatView)(new Uint8Array([value % 10]), firstViewCopy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value % 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (c[0] > 0) firstViewCopy = (0, _pvutils.utilConcatView)(c, firstViewCopy);\n\n\t\t\treturn firstViewCopy.slice(0);\n\t\t}\n\n\t\tfunction power2(n) {\n\t\t\tif (n >= powers2.length) {\n\t\t\t\tfor (let p = powers2.length; p <= n; p++) {\n\t\t\t\t\tconst c = new Uint8Array([0]);\n\t\t\t\t\tlet digits = powers2[p - 1].slice(0);\n\n\t\t\t\t\tfor (let i = digits.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n\t\t\t\t\t\tc[0] = newValue[0] / 10;\n\t\t\t\t\t\tdigits[i] = newValue[0] % 10;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c[0] > 0) digits = (0, _pvutils.utilConcatView)(c, digits);\n\n\t\t\t\t\tpowers2.push(digits);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn powers2[n];\n\t\t}\n\n\t\tfunction viewSub(first, second) {\n\t\t\t//region Initial variables\n\t\t\tlet b = 0;\n\n\t\t\tlet firstView = new Uint8Array(first);\n\t\t\tlet secondView = new Uint8Array(second);\n\n\t\t\tlet firstViewCopy = firstView.slice(0);\n\t\t\tconst firstViewCopyLength = firstViewCopy.length - 1;\n\t\t\tlet secondViewCopy = secondView.slice(0);\n\t\t\tconst secondViewCopyLength = secondViewCopy.length - 1;\n\n\t\t\tlet value;\n\n\t\t\tlet counter = 0;\n\t\t\t//endregion\n\n\t\t\tfor (let i = secondViewCopyLength; i >= 0; i--, counter++) {\n\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\n\t\t\t\tswitch (true) {\n\t\t\t\t\tcase value < 0:\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b > 0) {\n\t\t\t\tfor (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {\n\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - b;\n\n\t\t\t\t\tif (value < 0) {\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn firstViewCopy.slice();\n\t\t}\n\t\t//endregion\n\n\t\t//region Initial variables\n\t\tconst firstBit = this._valueHex.byteLength * 8 - 1;\n\n\t\tlet digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);\n\t\tlet bitNumber = 0;\n\t\tlet currentByte;\n\n\t\tconst asn1View = new Uint8Array(this._valueHex);\n\n\t\tlet result = \"\";\n\n\t\tlet flag = false;\n\t\t//endregion\n\n\t\t//region Calculate number\n\t\tfor (let byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {\n\t\t\tcurrentByte = asn1View[byteNumber];\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tif ((currentByte & 1) === 1) {\n\t\t\t\t\tswitch (bitNumber) {\n\t\t\t\t\t\tcase firstBit:\n\t\t\t\t\t\t\tdigits = viewSub(power2(bitNumber), digits);\n\t\t\t\t\t\t\tresult = \"-\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tdigits = viewAdd(digits, power2(bitNumber));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbitNumber++;\n\t\t\t\tcurrentByte >>= 1;\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\t//region Print number\n\t\tfor (let i = 0; i < digits.length; i++) {\n\t\t\tif (digits[i]) flag = true;\n\n\t\t\tif (flag) result += digitsString.charAt(digits[i]);\n\t\t}\n\n\t\tif (flag === false) result += digitsString.charAt(0);\n\t\t//endregion\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass Integer extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Integer\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalIntegerValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 2; // Integer\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Integer\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Compare two Integer object, or Integer and ArrayBuffer objects\r\n  * @param {!Integer|ArrayBuffer} otherValue\r\n  * @returns {boolean}\r\n  */\n\tisEqual(otherValue) {\n\t\tif (otherValue instanceof Integer) {\n\t\t\tif (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n\t\t\t\treturn (0, _pvutils.isEqualBuffer)(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n\n\t\t\tif (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (otherValue instanceof ArrayBuffer) return (0, _pvutils.isEqualBuffer)(this.valueBlock.valueHex, otherValue);\n\n\t\treturn false;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convert current Integer value from BER into DER format\r\n  * @returns {Integer}\r\n  */\n\tconvertToDER() {\n\t\tconst integer = new Integer({ valueHex: this.valueBlock.valueHex });\n\t\tinteger.valueBlock.toDER();\n\n\t\treturn integer;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convert current Integer value from DER to BER format\r\n  * @returns {Integer}\r\n  */\n\tconvertFromDER() {\n\t\tconst expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;\n\t\tconst integer = new Integer({ valueHex: this.valueBlock.valueHex });\n\t\tinteger.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n\n\t\treturn integer;\n\t}\n\t//**********************************************************************************\n}\nexports.Integer = Integer; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Enumerated type class\n//**************************************************************************************\n\nclass Enumerated extends Integer {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Enumerated\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 10; // Enumerated\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Enumerated\";\n\t}\n\t//**********************************************************************************\n}\nexports.Enumerated = Enumerated; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 ObjectIdentifier type class\n//**************************************************************************************\n\nclass LocalSidValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalSidValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {number} [valueDec]\r\n  * @property {boolean} [isFirstSid]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.valueDec = (0, _pvutils.getParametersValue)(parameters, \"valueDec\", -1);\n\t\tthis.isFirstSid = (0, _pvutils.getParametersValue)(parameters, \"isFirstSid\", false);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"sidBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tif (inputLength === 0) return inputOffset;\n\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t//endregion\n\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\tthis.valueHex = new ArrayBuffer(inputLength);\n\t\tlet view = new Uint8Array(this.valueHex);\n\n\t\tfor (let i = 0; i < inputLength; i++) {\n\t\t\tview[i] = intBuffer[i] & 0x7F;\n\n\t\t\tthis.blockLength++;\n\n\t\t\tif ((intBuffer[i] & 0x80) === 0x00) break;\n\t\t}\n\n\t\t//region Ajust size of valueHex buffer\n\t\tconst tempValueHex = new ArrayBuffer(this.blockLength);\n\t\tconst tempView = new Uint8Array(tempValueHex);\n\n\t\tfor (let i = 0; i < this.blockLength; i++) tempView[i] = view[i];\n\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tthis.valueHex = tempValueHex.slice(0);\n\t\tview = new Uint8Array(this.valueHex);\n\t\t//endregion\n\n\t\tif ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n\n\t\tif (this.blockLength <= 8) this.valueDec = (0, _pvutils.utilFromBase)(view, 7);else {\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis.warnings.push(\"Too big SID for decoding, hex only\");\n\t\t}\n\n\t\treturn inputOffset + this.blockLength;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\t//region Initial variables\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tif (this.isHexOnly) {\n\t\t\tif (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n\n\t\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\t\tretBuf = new ArrayBuffer(this.blockLength);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n\t\t\tretView[this.blockLength - 1] = curView[this.blockLength - 1];\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tconst encodedBuf = (0, _pvutils.utilToBase)(this.valueDec, 7);\n\t\tif (encodedBuf.byteLength === 0) {\n\t\t\tthis.error = \"Error during encoding SID value\";\n\t\t\treturn new ArrayBuffer(0);\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n\t\tif (sizeOnly === false) {\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n\t\t\tretView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Create string representation of current SID block\r\n  * @returns {string}\r\n  */\n\ttoString() {\n\t\tlet result = \"\";\n\n\t\tif (this.isHexOnly === true) result = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);else {\n\t\t\tif (this.isFirstSid) {\n\t\t\t\tlet sidValue = this.valueDec;\n\n\t\t\t\tif (this.valueDec <= 39) result = \"0.\";else {\n\t\t\t\t\tif (this.valueDec <= 79) {\n\t\t\t\t\t\tresult = \"1.\";\n\t\t\t\t\t\tsidValue -= 40;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = \"2.\";\n\t\t\t\t\t\tsidValue -= 80;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult += sidValue.toString();\n\t\t\t} else result = this.valueDec.toString();\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.valueDec = this.valueDec;\n\t\tobject.isFirstSid = this.isFirstSid;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalObjectIdentifierValueBlock extends LocalValueBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalObjectIdentifierValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueHex]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.fromString((0, _pvutils.getParametersValue)(parameters, \"value\", \"\"));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tlet resultOffset = inputOffset;\n\n\t\twhile (inputLength > 0) {\n\t\t\tconst sidBlock = new LocalSidValueBlock();\n\t\t\tresultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.blockLength = 0;\n\t\t\t\tthis.error = sidBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tif (this.value.length === 0) sidBlock.isFirstSid = true;\n\n\t\t\tthis.blockLength += sidBlock.blockLength;\n\t\t\tinputLength -= sidBlock.blockLength;\n\n\t\t\tthis.value.push(sidBlock);\n\t\t}\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\tlet retBuf = new ArrayBuffer(0);\n\n\t\tfor (let i = 0; i < this.value.length; i++) {\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\tif (valueBuf.byteLength === 0) {\n\t\t\t\tthis.error = this.value[i].error;\n\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t}\n\n\t\t\tretBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Create \"LocalObjectIdentifierValueBlock\" class from string\r\n  * @param {string} string Input string to convert from\r\n  * @returns {boolean}\r\n  */\n\tfromString(string) {\n\t\tthis.value = []; // Clear existing SID values\n\n\t\tlet pos1 = 0;\n\t\tlet pos2 = 0;\n\n\t\tlet sid = \"\";\n\n\t\tlet flag = false;\n\n\t\tdo {\n\t\t\tpos2 = string.indexOf(\".\", pos1);\n\t\t\tif (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n\n\t\t\tpos1 = pos2 + 1;\n\n\t\t\tif (flag) {\n\t\t\t\tconst sidBlock = this.value[0];\n\n\t\t\t\tlet plus = 0;\n\n\t\t\t\tswitch (sidBlock.valueDec) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tplus = 40;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tplus = 80;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.value = []; // clear SID array\n\t\t\t\t\t\treturn false; // ???\n\t\t\t\t}\n\n\t\t\t\tconst parsedSID = parseInt(sid, 10);\n\t\t\t\tif (isNaN(parsedSID)) return true;\n\n\t\t\t\tsidBlock.valueDec = parsedSID + plus;\n\n\t\t\t\tflag = false;\n\t\t\t} else {\n\t\t\t\tconst sidBlock = new LocalSidValueBlock();\n\t\t\t\tsidBlock.valueDec = parseInt(sid, 10);\n\t\t\t\tif (isNaN(sidBlock.valueDec)) return true;\n\n\t\t\t\tif (this.value.length === 0) {\n\t\t\t\t\tsidBlock.isFirstSid = true;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\n\t\t\t\tthis.value.push(sidBlock);\n\t\t\t}\n\t\t} while (pos2 !== -1);\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Converts \"LocalObjectIdentifierValueBlock\" class to string\r\n  * @returns {string}\r\n  */\n\ttoString() {\n\t\tlet result = \"\";\n\t\tlet isHexOnly = false;\n\n\t\tfor (let i = 0; i < this.value.length; i++) {\n\t\t\tisHexOnly = this.value[i].isHexOnly;\n\n\t\t\tlet sidStr = this.value[i].toString();\n\n\t\t\tif (i !== 0) result = `${result}.`;\n\n\t\t\tif (isHexOnly) {\n\t\t\t\tsidStr = `{${sidStr}}`;\n\n\t\t\t\tif (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;\n\t\t\t} else result += sidStr;\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"ObjectIdentifierValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.value = this.toString();\n\t\tobject.sidArray = [];\n\t\tfor (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\r\n * @extends BaseBlock\r\n */\nclass ObjectIdentifier extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"ObjectIdentifier\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueHex]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalObjectIdentifierValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"ObjectIdentifier\";\n\t}\n\t//**********************************************************************************\n}\nexports.ObjectIdentifier = ObjectIdentifier; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all string's classes\n//**************************************************************************************\n\nclass LocalUtf8StringValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Constructor for \"LocalUtf8StringValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\"; // String representation of decoded ArrayBuffer\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Utf8StringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\r\n * @extends BaseBlock\r\n */\nclass Utf8String extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Utf8String\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {ArrayBuffer} [valueHex]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalUtf8StringValueBlock);\n\n\t\tif (\"value\" in parameters) this.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 12; // Utf8String\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Utf8String\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\tif (resultOffset === -1) {\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ArrayBuffer into ASN.1 internal string\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  */\n\tfromBuffer(inputBuffer) {\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n\t\ttry {\n\t\t\t//noinspection JSDeprecatedSymbols\n\t\t\tthis.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n\t\t} catch (ex) {\n\t\t\tthis.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting JavaScript string into ASN.1 internal class\r\n  * @param {!string} inputString ASN.1 BER encoded array\r\n  */\n\tfromString(inputString) {\n\t\t//noinspection JSDeprecatedSymbols\n\t\tconst str = unescape(encodeURIComponent(inputString));\n\t\tconst strLen = str.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\n\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor (let i = 0; i < strLen; i++) view[i] = str.charCodeAt(i);\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n}\nexports.Utf8String = Utf8String; //**************************************************************************************\n/**\r\n * @extends LocalBaseBlock\r\n * @extends LocalHexBlock\r\n */\n\nclass LocalBmpStringValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalBmpStringValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"BmpStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\r\n * @extends BaseBlock\r\n */\nclass BmpString extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"BmpString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalBmpStringValueBlock);\n\n\t\tif (\"value\" in parameters) this.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 30; // BmpString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"BmpString\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\tif (resultOffset === -1) {\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ArrayBuffer into ASN.1 internal string\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  */\n\tfromBuffer(inputBuffer) {\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tconst copyBuffer = inputBuffer.slice(0);\n\t\tconst valueView = new Uint8Array(copyBuffer);\n\n\t\tfor (let i = 0; i < valueView.length; i += 2) {\n\t\t\tconst temp = valueView[i];\n\n\t\t\tvalueView[i] = valueView[i + 1];\n\t\t\tvalueView[i + 1] = temp;\n\t\t}\n\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting JavaScript string into ASN.1 internal class\r\n  * @param {!string} inputString ASN.1 BER encoded array\r\n  */\n\tfromString(inputString) {\n\t\tconst strLength = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n\t\tconst valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor (let i = 0; i < strLength; i++) {\n\t\t\tconst codeBuf = (0, _pvutils.utilToBase)(inputString.charCodeAt(i), 8);\n\t\t\tconst codeView = new Uint8Array(codeBuf);\n\t\t\tif (codeView.length > 2) continue;\n\n\t\t\tconst dif = 2 - codeView.length;\n\n\t\t\tfor (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 2 + j + dif] = codeView[j];\n\t\t}\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n}\nexports.BmpString = BmpString; //**************************************************************************************\n\nclass LocalUniversalStringValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalUniversalStringValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"UniversalStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\r\n * @extends BaseBlock\r\n */\nclass UniversalString extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"UniversalString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalUniversalStringValueBlock);\n\n\t\tif (\"value\" in parameters) this.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 28; // UniversalString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"UniversalString\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\tif (resultOffset === -1) {\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ArrayBuffer into ASN.1 internal string\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  */\n\tfromBuffer(inputBuffer) {\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tconst copyBuffer = inputBuffer.slice(0);\n\t\tconst valueView = new Uint8Array(copyBuffer);\n\n\t\tfor (let i = 0; i < valueView.length; i += 4) {\n\t\t\tvalueView[i] = valueView[i + 3];\n\t\t\tvalueView[i + 1] = valueView[i + 2];\n\t\t\tvalueView[i + 2] = 0x00;\n\t\t\tvalueView[i + 3] = 0x00;\n\t\t}\n\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting JavaScript string into ASN.1 internal class\r\n  * @param {!string} inputString ASN.1 BER encoded array\r\n  */\n\tfromString(inputString) {\n\t\tconst strLength = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n\t\tconst valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor (let i = 0; i < strLength; i++) {\n\t\t\tconst codeBuf = (0, _pvutils.utilToBase)(inputString.charCodeAt(i), 8);\n\t\t\tconst codeView = new Uint8Array(codeBuf);\n\t\t\tif (codeView.length > 4) continue;\n\n\t\t\tconst dif = 4 - codeView.length;\n\n\t\t\tfor (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];\n\t\t}\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n}\nexports.UniversalString = UniversalString; //**************************************************************************************\n\nclass LocalSimpleStringValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalSimpleStringValueBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.value = \"\";\n\t\tthis.isHexOnly = true;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"SimpleStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\r\n * @extends BaseBlock\r\n */\nclass LocalSimpleStringBlock extends BaseBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"LocalSimpleStringBlock\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters, LocalSimpleStringValueBlock);\n\n\t\tif (\"value\" in parameters) this.fromString(parameters.value);\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"SIMPLESTRING\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\tif (resultOffset === -1) {\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ArrayBuffer into ASN.1 internal string\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  */\n\tfromBuffer(inputBuffer) {\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting JavaScript string into ASN.1 internal class\r\n  * @param {!string} inputString ASN.1 BER encoded array\r\n  */\n\tfromString(inputString) {\n\t\tconst strLen = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\n\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor (let i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\nclass NumericString extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"NumericString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 18; // NumericString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"NumericString\";\n\t}\n\t//**********************************************************************************\n}\nexports.NumericString = NumericString; //**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\nclass PrintableString extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"PrintableString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 19; // PrintableString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"PrintableString\";\n\t}\n\t//**********************************************************************************\n}\nexports.PrintableString = PrintableString; //**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\nclass TeletexString extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"TeletexString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 20; // TeletexString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"TeletexString\";\n\t}\n\t//**********************************************************************************\n}\nexports.TeletexString = TeletexString; //**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\nclass VideotexString extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"VideotexString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 21; // VideotexString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"VideotexString\";\n\t}\n\t//**********************************************************************************\n}\nexports.VideotexString = VideotexString; //**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\nclass IA5String extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"IA5String\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 22; // IA5String\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"IA5String\";\n\t}\n\t//**********************************************************************************\n}\nexports.IA5String = IA5String; //**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\nclass GraphicString extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"GraphicString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 25; // GraphicString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"GraphicString\";\n\t}\n\t//**********************************************************************************\n}\nexports.GraphicString = GraphicString; //**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\nclass VisibleString extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"VisibleString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 26; // VisibleString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"VisibleString\";\n\t}\n\t//**********************************************************************************\n}\nexports.VisibleString = VisibleString; //**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\nclass GeneralString extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"GeneralString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 27; // GeneralString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"GeneralString\";\n\t}\n\t//**********************************************************************************\n}\nexports.GeneralString = GeneralString; //**************************************************************************************\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\nclass CharacterString extends LocalSimpleStringBlock {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"CharacterString\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 29; // CharacterString\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"CharacterString\";\n\t}\n\t//**********************************************************************************\n}\nexports.CharacterString = CharacterString; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all date and time classes\n//**************************************************************************************\n/**\r\n * @extends VisibleString\r\n */\n\nclass UTCTime extends VisibleString {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"UTCTime\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {string} [value] String representatio of the date\r\n  * @property {Date} [valueDate] JavaScript \"Date\" object\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.year = 0;\n\t\tthis.month = 0;\n\t\tthis.day = 0;\n\t\tthis.hour = 0;\n\t\tthis.minute = 0;\n\t\tthis.second = 0;\n\n\t\t//region Create UTCTime from ASN.1 UTC string value\n\t\tif (\"value\" in parameters) {\n\t\t\tthis.fromString(parameters.value);\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n\t\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n\t\t}\n\t\t//endregion\n\t\t//region Create GeneralizedTime from JavaScript Date type\n\t\tif (\"valueDate\" in parameters) {\n\t\t\tthis.fromDate(parameters.valueDate);\n\t\t\tthis.valueBlock.valueHex = this.toBuffer();\n\t\t}\n\t\t//endregion\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 23; // UTCTime\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\tif (resultOffset === -1) {\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ArrayBuffer into ASN.1 internal string\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  */\n\tfromBuffer(inputBuffer) {\n\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ASN.1 internal string into ArrayBuffer\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBuffer() {\n\t\tconst str = this.toString();\n\n\t\tconst buffer = new ArrayBuffer(str.length);\n\t\tconst view = new Uint8Array(buffer);\n\n\t\tfor (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n\t\treturn buffer;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting \"Date\" object into ASN.1 internal string\r\n  * @param {!Date} inputDate JavaScript \"Date\" object\r\n  */\n\tfromDate(inputDate) {\n\t\tthis.year = inputDate.getUTCFullYear();\n\t\tthis.month = inputDate.getUTCMonth() + 1;\n\t\tthis.day = inputDate.getUTCDate();\n\t\tthis.hour = inputDate.getUTCHours();\n\t\tthis.minute = inputDate.getUTCMinutes();\n\t\tthis.second = inputDate.getUTCSeconds();\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Function converting ASN.1 internal string into \"Date\" object\r\n  * @returns {Date}\r\n  */\n\ttoDate() {\n\t\treturn new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting JavaScript string into ASN.1 internal class\r\n  * @param {!string} inputString ASN.1 BER encoded array\r\n  */\n\tfromString(inputString) {\n\t\t//region Parse input string\n\t\tconst parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n\t\tconst parserArray = parser.exec(inputString);\n\t\tif (parserArray === null) {\n\t\t\tthis.error = \"Wrong input string for convertion\";\n\t\t\treturn;\n\t\t}\n\t\t//endregion\n\n\t\t//region Store parsed values\n\t\tconst year = parseInt(parserArray[1], 10);\n\t\tif (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n\n\t\tthis.month = parseInt(parserArray[2], 10);\n\t\tthis.day = parseInt(parserArray[3], 10);\n\t\tthis.hour = parseInt(parserArray[4], 10);\n\t\tthis.minute = parseInt(parserArray[5], 10);\n\t\tthis.second = parseInt(parserArray[6], 10);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ASN.1 internal class into JavaScript string\r\n  * @returns {string}\r\n  */\n\ttoString() {\n\t\tconst outputArray = new Array(7);\n\n\t\toutputArray[0] = (0, _pvutils.padNumber)(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n\t\toutputArray[1] = (0, _pvutils.padNumber)(this.month, 2);\n\t\toutputArray[2] = (0, _pvutils.padNumber)(this.day, 2);\n\t\toutputArray[3] = (0, _pvutils.padNumber)(this.hour, 2);\n\t\toutputArray[4] = (0, _pvutils.padNumber)(this.minute, 2);\n\t\toutputArray[5] = (0, _pvutils.padNumber)(this.second, 2);\n\t\toutputArray[6] = \"Z\";\n\n\t\treturn outputArray.join(\"\");\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"UTCTime\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.year = this.year;\n\t\tobject.month = this.month;\n\t\tobject.day = this.day;\n\t\tobject.hour = this.hour;\n\t\tobject.minute = this.minute;\n\t\tobject.second = this.second;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\nexports.UTCTime = UTCTime; //**************************************************************************************\n/**\r\n * @extends VisibleString\r\n */\n\nclass GeneralizedTime extends VisibleString {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"GeneralizedTime\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {string} [value] String representatio of the date\r\n  * @property {Date} [valueDate] JavaScript \"Date\" object\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.year = 0;\n\t\tthis.month = 0;\n\t\tthis.day = 0;\n\t\tthis.hour = 0;\n\t\tthis.minute = 0;\n\t\tthis.second = 0;\n\t\tthis.millisecond = 0;\n\n\t\t//region Create UTCTime from ASN.1 UTC string value\n\t\tif (\"value\" in parameters) {\n\t\t\tthis.fromString(parameters.value);\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n\t\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n\t\t}\n\t\t//endregion\n\t\t//region Create GeneralizedTime from JavaScript Date type\n\t\tif (\"valueDate\" in parameters) {\n\t\t\tthis.fromDate(parameters.valueDate);\n\t\t\tthis.valueBlock.valueHex = this.toBuffer();\n\t\t}\n\t\t//endregion\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 24; // GeneralizedTime\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\tif (resultOffset === -1) {\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ArrayBuffer into ASN.1 internal string\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  */\n\tfromBuffer(inputBuffer) {\n\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ASN.1 internal string into ArrayBuffer\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBuffer() {\n\t\tconst str = this.toString();\n\n\t\tconst buffer = new ArrayBuffer(str.length);\n\t\tconst view = new Uint8Array(buffer);\n\n\t\tfor (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n\t\treturn buffer;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting \"Date\" object into ASN.1 internal string\r\n  * @param {!Date} inputDate JavaScript \"Date\" object\r\n  */\n\tfromDate(inputDate) {\n\t\tthis.year = inputDate.getUTCFullYear();\n\t\tthis.month = inputDate.getUTCMonth() + 1;\n\t\tthis.day = inputDate.getUTCDate();\n\t\tthis.hour = inputDate.getUTCHours();\n\t\tthis.minute = inputDate.getUTCMinutes();\n\t\tthis.second = inputDate.getUTCSeconds();\n\t\tthis.millisecond = inputDate.getUTCMilliseconds();\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\r\n  * Function converting ASN.1 internal string into \"Date\" object\r\n  * @returns {Date}\r\n  */\n\ttoDate() {\n\t\treturn new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting JavaScript string into ASN.1 internal class\r\n  * @param {!string} inputString ASN.1 BER encoded array\r\n  */\n\tfromString(inputString) {\n\t\t//region Initial variables\n\t\tlet isUTC = false;\n\n\t\tlet timeString = \"\";\n\t\tlet dateTimeString = \"\";\n\t\tlet fractionPart = 0;\n\n\t\tlet parser;\n\n\t\tlet hourDifference = 0;\n\t\tlet minuteDifference = 0;\n\t\t//endregion\n\n\t\t//region Convert as UTC time\n\t\tif (inputString[inputString.length - 1] === \"Z\") {\n\t\t\ttimeString = inputString.substr(0, inputString.length - 1);\n\n\t\t\tisUTC = true;\n\t\t}\n\t\t//endregion\n\t\t//region Convert as local time\n\t\telse {\n\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\tconst number = new Number(inputString[inputString.length - 1]);\n\n\t\t\t\tif (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\ttimeString = inputString;\n\t\t\t}\n\t\t//endregion\n\n\t\t//region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\t\tif (isUTC) {\n\t\t\tif (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\tif (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for convertion\");\n\t\t}\n\t\t//endregion\n\t\t//region Get \"UTC time difference\" in case of local time\n\t\telse {\n\t\t\t\tlet multiplier = 1;\n\t\t\t\tlet differencePosition = timeString.indexOf(\"+\");\n\t\t\t\tlet differenceString = \"\";\n\n\t\t\t\tif (differencePosition === -1) {\n\t\t\t\t\tdifferencePosition = timeString.indexOf(\"-\");\n\t\t\t\t\tmultiplier = -1;\n\t\t\t\t}\n\n\t\t\t\tif (differencePosition !== -1) {\n\t\t\t\t\tdifferenceString = timeString.substr(differencePosition + 1);\n\t\t\t\t\ttimeString = timeString.substr(0, differencePosition);\n\n\t\t\t\t\tif (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\t\tlet number = new Number(differenceString.substr(0, 2));\n\n\t\t\t\t\tif (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\thourDifference = multiplier * number;\n\n\t\t\t\t\tif (differenceString.length === 4) {\n\t\t\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\t\t\tnumber = new Number(differenceString.substr(2, 2));\n\n\t\t\t\t\t\tif (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\t\tminuteDifference = multiplier * number;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t//endregion\n\n\t\t//region Get position of fraction point\n\t\tlet fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\t\tif (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n\t\t//endregion\n\n\t\t//region Get fraction part\n\t\tif (fractionPointPosition !== -1) {\n\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\tconst fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\n\n\t\t\tif (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\tfractionPart = fractionPartCheck.valueOf();\n\n\t\t\tdateTimeString = timeString.substr(0, fractionPointPosition);\n\t\t} else dateTimeString = timeString;\n\t\t//endregion\n\n\t\t//region Parse internal date\n\t\tswitch (true) {\n\t\t\tcase dateTimeString.length === 8:\n\t\t\t\t// \"YYYYMMDD\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n\t\t\t\tif (fractionPointPosition !== -1) throw new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\t\t\t\tbreak;\n\t\t\tcase dateTimeString.length === 10:\n\t\t\t\t// \"YYYYMMDDHH\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif (fractionPointPosition !== -1) {\n\t\t\t\t\tlet fractionResult = 60 * fractionPart;\n\t\t\t\t\tthis.minute = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 60 * (fractionResult - this.minute);\n\t\t\t\t\tthis.second = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase dateTimeString.length === 12:\n\t\t\t\t// \"YYYYMMDDHHMM\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif (fractionPointPosition !== -1) {\n\t\t\t\t\tlet fractionResult = 60 * fractionPart;\n\t\t\t\t\tthis.second = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase dateTimeString.length === 14:\n\t\t\t\t// \"YYYYMMDDHHMMSS\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif (fractionPointPosition !== -1) {\n\t\t\t\t\tconst fractionResult = 1000 * fractionPart;\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t}\n\t\t//endregion\n\n\t\t//region Put parsed values at right places\n\t\tconst parserArray = parser.exec(dateTimeString);\n\t\tif (parserArray === null) throw new Error(\"Wrong input string for convertion\");\n\n\t\tfor (let j = 1; j < parserArray.length; j++) {\n\t\t\tswitch (j) {\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.year = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.month = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tthis.day = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tthis.hour = parseInt(parserArray[j], 10) + hourDifference;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tthis.minute = parseInt(parserArray[j], 10) + minuteDifference;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tthis.second = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\t//region Get final date\n\t\tif (isUTC === false) {\n\t\t\tconst tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n\n\t\t\tthis.year = tempDate.getUTCFullYear();\n\t\t\tthis.month = tempDate.getUTCMonth();\n\t\t\tthis.day = tempDate.getUTCDay();\n\t\t\tthis.hour = tempDate.getUTCHours();\n\t\t\tthis.minute = tempDate.getUTCMinutes();\n\t\t\tthis.second = tempDate.getUTCSeconds();\n\t\t\tthis.millisecond = tempDate.getUTCMilliseconds();\n\t\t}\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Function converting ASN.1 internal class into JavaScript string\r\n  * @returns {string}\r\n  */\n\ttoString() {\n\t\tconst outputArray = [];\n\n\t\toutputArray.push((0, _pvutils.padNumber)(this.year, 4));\n\t\toutputArray.push((0, _pvutils.padNumber)(this.month, 2));\n\t\toutputArray.push((0, _pvutils.padNumber)(this.day, 2));\n\t\toutputArray.push((0, _pvutils.padNumber)(this.hour, 2));\n\t\toutputArray.push((0, _pvutils.padNumber)(this.minute, 2));\n\t\toutputArray.push((0, _pvutils.padNumber)(this.second, 2));\n\t\tif (this.millisecond !== 0) {\n\t\t\toutputArray.push(\".\");\n\t\t\toutputArray.push((0, _pvutils.padNumber)(this.millisecond, 3));\n\t\t}\n\t\toutputArray.push(\"Z\");\n\n\t\treturn outputArray.join(\"\");\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"GeneralizedTime\";\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Convertion for the block to JSON object\r\n  * @returns {Object}\r\n  */\n\ttoJSON() {\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.year = this.year;\n\t\tobject.month = this.month;\n\t\tobject.day = this.day;\n\t\tobject.hour = this.hour;\n\t\tobject.minute = this.minute;\n\t\tobject.second = this.second;\n\t\tobject.millisecond = this.millisecond;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\nexports.GeneralizedTime = GeneralizedTime; //**************************************************************************************\n/**\r\n * @extends Utf8String\r\n */\n\nclass DATE extends Utf8String {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"DATE\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 31; // DATE\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"DATE\";\n\t}\n\t//**********************************************************************************\n}\nexports.DATE = DATE; //**************************************************************************************\n/**\r\n * @extends Utf8String\r\n */\n\nclass TimeOfDay extends Utf8String {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"TimeOfDay\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 32; // TimeOfDay\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"TimeOfDay\";\n\t}\n\t//**********************************************************************************\n}\nexports.TimeOfDay = TimeOfDay; //**************************************************************************************\n/**\r\n * @extends Utf8String\r\n */\n\nclass DateTime extends Utf8String {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"DateTime\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 33; // DateTime\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"DateTime\";\n\t}\n\t//**********************************************************************************\n}\nexports.DateTime = DateTime; //**************************************************************************************\n/**\r\n * @extends Utf8String\r\n */\n\nclass Duration extends Utf8String {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Duration\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 34; // Duration\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"Duration\";\n\t}\n\t//**********************************************************************************\n}\nexports.Duration = Duration; //**************************************************************************************\n/**\r\n * @extends Utf8String\r\n */\n\nclass TIME extends Utf8String {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Time\" class\r\n  * @param {Object} [parameters={}]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 14; // Time\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Aux function, need to get a block name. Need to have it here for inhiritence\r\n  * @returns {string}\r\n  */\n\tstatic blockName() {\n\t\treturn \"TIME\";\n\t}\n\t//**********************************************************************************\n}\nexports.TIME = TIME; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Choice\n//**************************************************************************************\n\nclass Choice {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Choice\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {Array} [value] Array of ASN.1 types for make a choice from\r\n  * @property {boolean} [optional]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tthis.value = (0, _pvutils.getParametersValue)(parameters, \"value\", []);\n\t\tthis.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n\t}\n\t//**********************************************************************************\n}\nexports.Choice = Choice; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Any\n//**************************************************************************************\n\nclass Any {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Any\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {string} [name]\r\n  * @property {boolean} [optional]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tthis.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\");\n\t\tthis.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n\t}\n\t//**********************************************************************************\n}\nexports.Any = Any; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Repeated\n//**************************************************************************************\n\nclass Repeated {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Repeated\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {string} [name]\r\n  * @property {boolean} [optional]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tthis.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\");\n\t\tthis.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n\t\tthis.value = (0, _pvutils.getParametersValue)(parameters, \"value\", new Any());\n\t\tthis.local = (0, _pvutils.getParametersValue)(parameters, \"local\", false); // Could local or global array to store elements\n\t}\n\t//**********************************************************************************\n}\nexports.Repeated = Repeated; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type RawData\n//**************************************************************************************\n/**\r\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\r\n */\n\nclass RawData {\n\t//**********************************************************************************\n\t/**\r\n  * Constructor for \"Repeated\" class\r\n  * @param {Object} [parameters={}]\r\n  * @property {string} [name]\r\n  * @property {boolean} [optional]\r\n  */\n\tconstructor(parameters = {}) {\n\t\tthis.data = (0, _pvutils.getParametersValue)(parameters, \"data\", new ArrayBuffer(0));\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Base function for converting block from BER encoded array of bytes\r\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n  * @returns {number} Offset after least decoded byte\r\n  */\n\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\tthis.data = inputBuffer.slice(inputOffset, inputLength);\n\t\treturn inputOffset + inputLength;\n\t}\n\t//**********************************************************************************\n\t/**\r\n  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n  * @returns {ArrayBuffer}\r\n  */\n\ttoBER(sizeOnly = false) {\n\t\treturn this.data;\n\t}\n\t//**********************************************************************************\n}\nexports.RawData = RawData; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major ASN.1 BER decoding function\n//**************************************************************************************\n/**\r\n * Internal library function for decoding ASN.1 BER\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n * @returns {{offset: number, result: Object}}\r\n */\n\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength) {\n\tconst incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n\n\t//region Local function changing a type for ASN.1 classes\n\tfunction localChangeType(inputObject, newType) {\n\t\tif (inputObject instanceof newType) return inputObject;\n\n\t\tconst newObject = new newType();\n\t\tnewObject.idBlock = inputObject.idBlock;\n\t\tnewObject.lenBlock = inputObject.lenBlock;\n\t\tnewObject.warnings = inputObject.warnings;\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tnewObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n\n\t\treturn newObject;\n\t}\n\t//endregion\n\n\t//region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\tlet returnObject = new BaseBlock({}, Object);\n\t//endregion\n\n\t//region Basic check for parameters\n\tif ((0, _pvutils.checkBufferParams)(new LocalBaseBlock(), inputBuffer, inputOffset, inputLength) === false) {\n\t\treturnObject.error = \"Wrong input parameters\";\n\t\treturn {\n\t\t\toffset: -1,\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Getting Uint8Array from ArrayBuffer\n\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t//endregion\n\n\t//region Initial checks\n\tif (intBuffer.length === 0) {\n\t\tthis.error = \"Zero buffer length\";\n\t\treturn {\n\t\t\toffset: -1,\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Decode indentifcation block of ASN.1 BER structure\n\tlet resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\treturnObject.warnings.concat(returnObject.idBlock.warnings);\n\tif (resultOffset === -1) {\n\t\treturnObject.error = returnObject.idBlock.error;\n\t\treturn {\n\t\t\toffset: -1,\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\n\tinputOffset = resultOffset;\n\tinputLength -= returnObject.idBlock.blockLength;\n\t//endregion\n\n\t//region Decode length block of ASN.1 BER structure\n\tresultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\treturnObject.warnings.concat(returnObject.lenBlock.warnings);\n\tif (resultOffset === -1) {\n\t\treturnObject.error = returnObject.lenBlock.error;\n\t\treturn {\n\t\t\toffset: -1,\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\n\tinputOffset = resultOffset;\n\tinputLength -= returnObject.lenBlock.blockLength;\n\t//endregion\n\n\t//region Check for usign indefinite length form in encoding for primitive types\n\tif (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {\n\t\treturnObject.error = \"Indefinite length form used for primitive encoding form\";\n\t\treturn {\n\t\t\toffset: -1,\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Switch ASN.1 block type\n\tlet newASN1Type = BaseBlock;\n\n\tswitch (returnObject.idBlock.tagClass) {\n\t\t//region UNIVERSAL\n\t\tcase 1:\n\t\t\t//region Check for reserved tag numbers\n\t\t\tif (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n\t\t\t\treturnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n\t\t\t\treturn {\n\t\t\t\t\toffset: -1,\n\t\t\t\t\tresult: returnObject\n\t\t\t\t};\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tswitch (returnObject.idBlock.tagNumber) {\n\t\t\t\t//region EndOfContent type\n\t\t\t\tcase 0:\n\t\t\t\t\t//region Check for EndOfContent type\n\t\t\t\t\tif (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {\n\t\t\t\t\t\treturnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\toffset: -1,\n\t\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\n\t\t\t\t\tnewASN1Type = EndOfContent;\n\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Boolean type\n\t\t\t\tcase 1:\n\t\t\t\t\tnewASN1Type = Boolean;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Integer type\n\t\t\t\tcase 2:\n\t\t\t\t\tnewASN1Type = Integer;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region BitString type\n\t\t\t\tcase 3:\n\t\t\t\t\tnewASN1Type = BitString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region OctetString type\n\t\t\t\tcase 4:\n\t\t\t\t\tnewASN1Type = OctetString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Null type\n\t\t\t\tcase 5:\n\t\t\t\t\tnewASN1Type = Null;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region OBJECT IDENTIFIER type\n\t\t\t\tcase 6:\n\t\t\t\t\tnewASN1Type = ObjectIdentifier;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Enumerated type\n\t\t\t\tcase 10:\n\t\t\t\t\tnewASN1Type = Enumerated;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Utf8String type\n\t\t\t\tcase 12:\n\t\t\t\t\tnewASN1Type = Utf8String;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Time type\n\t\t\t\tcase 14:\n\t\t\t\t\tnewASN1Type = TIME;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region ASN.1 reserved type\n\t\t\t\tcase 15:\n\t\t\t\t\treturnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n\t\t\t\t\treturn {\n\t\t\t\t\t\toffset: -1,\n\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t};\n\t\t\t\t//endregion\n\t\t\t\t//region Sequence type\n\t\t\t\tcase 16:\n\t\t\t\t\tnewASN1Type = Sequence;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Set type\n\t\t\t\tcase 17:\n\t\t\t\t\tnewASN1Type = Set;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region NumericString type\n\t\t\t\tcase 18:\n\t\t\t\t\tnewASN1Type = NumericString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region PrintableString type\n\t\t\t\tcase 19:\n\t\t\t\t\tnewASN1Type = PrintableString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region TeletexString type\n\t\t\t\tcase 20:\n\t\t\t\t\tnewASN1Type = TeletexString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region VideotexString type\n\t\t\t\tcase 21:\n\t\t\t\t\tnewASN1Type = VideotexString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region IA5String type\n\t\t\t\tcase 22:\n\t\t\t\t\tnewASN1Type = IA5String;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region UTCTime type\n\t\t\t\tcase 23:\n\t\t\t\t\tnewASN1Type = UTCTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GeneralizedTime type\n\t\t\t\tcase 24:\n\t\t\t\t\tnewASN1Type = GeneralizedTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GraphicString type\n\t\t\t\tcase 25:\n\t\t\t\t\tnewASN1Type = GraphicString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region VisibleString type\n\t\t\t\tcase 26:\n\t\t\t\t\tnewASN1Type = VisibleString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GeneralString type\n\t\t\t\tcase 27:\n\t\t\t\t\tnewASN1Type = GeneralString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region UniversalString type\n\t\t\t\tcase 28:\n\t\t\t\t\tnewASN1Type = UniversalString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region CharacterString type\n\t\t\t\tcase 29:\n\t\t\t\t\tnewASN1Type = CharacterString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region BmpString type\n\t\t\t\tcase 30:\n\t\t\t\t\tnewASN1Type = BmpString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region DATE type\n\t\t\t\tcase 31:\n\t\t\t\t\tnewASN1Type = DATE;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region TimeOfDay type\n\t\t\t\tcase 32:\n\t\t\t\t\tnewASN1Type = TimeOfDay;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Date-Time type\n\t\t\t\tcase 33:\n\t\t\t\t\tnewASN1Type = DateTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Duration type\n\t\t\t\tcase 34:\n\t\t\t\t\tnewASN1Type = Duration;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region default\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tlet newObject;\n\n\t\t\t\t\t\tif (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();\n\n\t\t\t\t\t\tnewObject.idBlock = returnObject.idBlock;\n\t\t\t\t\t\tnewObject.lenBlock = returnObject.lenBlock;\n\t\t\t\t\t\tnewObject.warnings = returnObject.warnings;\n\n\t\t\t\t\t\treturnObject = newObject;\n\n\t\t\t\t\t\tresultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t}\n\t\t\tbreak;\n\t\t//endregion\n\t\t//region All other tag classes\n\t\tcase 2: // APPLICATION\n\t\tcase 3: // CONTEXT-SPECIFIC\n\t\tcase 4: // PRIVATE\n\t\tdefault:\n\t\t\t{\n\t\t\t\tif (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;\n\t\t\t}\n\t\t//endregion\n\t}\n\t//endregion\n\n\t//region Change type and perform BER decoding\n\treturnObject = localChangeType(returnObject, newASN1Type);\n\tresultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length);\n\t//endregion\n\n\t//region Coping incoming buffer for entire ASN.1 block\n\treturnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);\n\t//endregion\n\n\treturn {\n\t\toffset: resultOffset,\n\t\tresult: returnObject\n\t};\n}\n//**************************************************************************************\n/**\r\n * Major function for decoding ASN.1 BER array into internal library structuries\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\r\n */\nfunction fromBER(inputBuffer) {\n\tif (inputBuffer.byteLength === 0) {\n\t\tconst result = new BaseBlock({}, Object);\n\t\tresult.error = \"Input buffer has zero length\";\n\n\t\treturn {\n\t\t\toffset: -1,\n\t\t\tresult\n\t\t};\n\t}\n\n\treturn LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major scheme verification function\n//**************************************************************************************\n/**\r\n * Compare of two ASN.1 object trees\r\n * @param {!Object} root Root of input ASN.1 object tree\r\n * @param {!Object} inputData Input ASN.1 object tree\r\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\nfunction compareSchema(root, inputData, inputSchema) {\n\t//region Special case for Choice schema element type\n\tif (inputSchema instanceof Choice) {\n\t\tconst choiceResult = false;\n\n\t\tfor (let j = 0; j < inputSchema.value.length; j++) {\n\t\t\tconst result = compareSchema(root, inputData, inputSchema.value[j]);\n\t\t\tif (result.verified === true) {\n\t\t\t\treturn {\n\t\t\t\t\tverified: true,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (choiceResult === false) {\n\t\t\tconst _result = {\n\t\t\t\tverified: false,\n\t\t\t\tresult: {\n\t\t\t\t\terror: \"Wrong values for Choice type\"\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (inputSchema.hasOwnProperty(\"name\")) _result.name = inputSchema.name;\n\n\t\t\treturn _result;\n\t\t}\n\t}\n\t//endregion\n\n\t//region Special case for Any schema element type\n\tif (inputSchema instanceof Any) {\n\t\t//region Add named component of ASN.1 schema\n\t\tif (inputSchema.hasOwnProperty(\"name\")) root[inputSchema.name] = inputData;\n\t\t//endregion\n\n\t\treturn {\n\t\t\tverified: true,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\n\t//region Initial check\n\tif (root instanceof Object === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong root object\" }\n\t\t};\n\t}\n\n\tif (inputData instanceof Object === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 data\" }\n\t\t};\n\t}\n\n\tif (inputSchema instanceof Object === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif (\"idBlock\" in inputSchema === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n\t//region Encode and decode ASN.1 schema idBlock\n\t/// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\tif (\"fromBER\" in inputSchema.idBlock === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif (\"toBER\" in inputSchema.idBlock === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tconst encodedId = inputSchema.idBlock.toBER(false);\n\tif (encodedId.byteLength === 0) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Error encoding idBlock for ASN.1 schema\" }\n\t\t};\n\t}\n\n\tconst decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\tif (decodedOffset === -1) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Error decoding idBlock for ASN.1 schema\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region tagClass\n\tif (inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region tagNumber\n\tif (inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region isConstructed\n\tif (inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region isHexOnly\n\tif (\"isHexOnly\" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property\n\t\t{\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\tif (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region valueHex\n\tif (inputSchema.idBlock.isHexOnly === true) {\n\t\tif (\"valueHex\" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t\t};\n\t\t\t}\n\n\t\tconst schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n\t\tconst asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n\t\tif (schemaView.length !== asn1View.length) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\n\t\tfor (let i = 0; i < schemaView.length; i++) {\n\t\t\tif (schemaView[i] !== asn1View[1]) {\n\t\t\t\treturn {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\t//endregion\n\t//endregion\n\n\t//region Add named component of ASN.1 schema\n\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\tif (inputSchema.name !== \"\") root[inputSchema.name] = inputData;\n\t}\n\t//endregion\n\n\t//region Getting next ASN.1 block for comparition\n\tif (inputSchema.idBlock.isConstructed === true) {\n\t\tlet admission = 0;\n\t\tlet result = { verified: false };\n\n\t\tlet maxLength = inputSchema.valueBlock.value.length;\n\n\t\tif (maxLength > 0) {\n\t\t\tif (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;\n\t\t}\n\n\t\t//region Special case when constructive value has no elements\n\t\tif (maxLength === 0) {\n\t\t\treturn {\n\t\t\t\tverified: true,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\t\tif (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n\t\t\tlet _optional = true;\n\n\t\t\tfor (let i = 0; i < inputSchema.valueBlock.value.length; i++) _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n\n\t\t\tif (_optional === true) {\n\t\t\t\treturn {\n\t\t\t\t\tverified: true,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//region Delete early added name of block\n\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\tif (inputSchema.name !== \"\") delete root[inputSchema.name];\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\troot.error = \"Inconsistent object length\";\n\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\tfor (let i = 0; i < maxLength; i++) {\n\t\t\t//region Special case when there is an \"optional\" element of ASN.1 schema at the end\n\t\t\tif (i - admission >= inputData.valueBlock.value.length) {\n\t\t\t\tif (inputSchema.valueBlock.value[i].optional === false) {\n\t\t\t\t\tconst _result = {\n\t\t\t\t\t\tverified: false,\n\t\t\t\t\t\tresult: root\n\t\t\t\t\t};\n\n\t\t\t\t\troot.error = \"Inconsistent length between ASN.1 data and schema\";\n\n\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\tif (inputSchema.name !== \"\") {\n\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\n\t\t\t\t\treturn _result;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\t\t\telse {\n\t\t\t\t\t//region Special case for Repeated type of ASN.1 schema element\n\t\t\t\t\tif (inputSchema.valueBlock.value[0] instanceof Repeated) {\n\t\t\t\t\t\tresult = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n\t\t\t\t\t\tif (result.verified === false) {\n\t\t\t\t\t\t\tif (inputSchema.valueBlock.value[0].optional === true) admission++;else {\n\t\t\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\t\t\tif (inputSchema.name !== \"\") delete root[inputSchema.name];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\"name\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n\t\t\t\t\t\t\tlet arrayRoot = {};\n\n\t\t\t\t\t\t\tif (\"local\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;\n\n\t\t\t\t\t\t\tif (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n\n\t\t\t\t\t\t\tarrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n\t\t\t\t\t\t\tif (result.verified === false) {\n\t\t\t\t\t\t\t\tif (inputSchema.valueBlock.value[i].optional === true) admission++;else {\n\t\t\t\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\t\t\t\tif (inputSchema.name !== \"\") delete root[inputSchema.name];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\tif (result.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n\t\t\t{\n\t\t\t\tconst _result = {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\n\t\t\t\t//region Delete early added name of block\n\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\tif (inputSchema.name !== \"\") {\n\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\treturn _result;\n\t\t\t}\n\n\t\treturn {\n\t\t\tverified: true,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\tif (\"primitiveSchema\" in inputSchema && \"valueHex\" in inputData.valueBlock) {\n\t\t//region Decoding of raw ASN.1 data\n\t\tconst asn1 = fromBER(inputData.valueBlock.valueHex);\n\t\tif (asn1.offset === -1) {\n\t\t\tconst _result = {\n\t\t\t\tverified: false,\n\t\t\t\tresult: asn1.result\n\t\t\t};\n\n\t\t\t//region Delete early added name of block\n\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\tif (inputSchema.name !== \"\") {\n\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn _result;\n\t\t}\n\t\t//endregion\n\n\t\treturn compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n\t}\n\n\treturn {\n\t\tverified: true,\n\t\tresult: root\n\t};\n\t//endregion\n}\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n/**\r\n * ASN.1 schema verification for ArrayBuffer data\r\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\r\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\nfunction verifySchema(inputBuffer, inputSchema) {\n\t//region Initial check\n\tif (inputSchema instanceof Object === false) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema type\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region Decoding of raw ASN.1 data\n\tconst asn1 = fromBER(inputBuffer);\n\tif (asn1.offset === -1) {\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: asn1.result\n\t\t};\n\t}\n\t//endregion\n\n\t//region Compare ASN.1 struct with input schema\n\treturn compareSchema(asn1.result, asn1.result, inputSchema);\n\t//endregion\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major function converting JSON to ASN.1 objects\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n/**\r\n * Converting from JSON to ASN.1 objects\r\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\r\n */\nfunction fromJSON(json) {}\n// TODO Implement\n\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//# sourceMappingURL=asn1.js.map"],"sourceRoot":""}