(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{AjCi:function(e,t){e.exports='var WebcryptoSocket = (function (exports, protobufjs, fetch, WebSocket) {\n  \'use strict\';\n\n  fetch = fetch && fetch.hasOwnProperty(\'default\') ? fetch[\'default\'] : fetch;\n  WebSocket = WebSocket && WebSocket.hasOwnProperty(\'default\') ? WebSocket[\'default\'] : WebSocket;\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === \'function\') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function PrepareBuffer(buffer) {\n    if (typeof Buffer !== "undefined") {\n      return new Uint8Array(buffer);\n    } else {\n      return new Uint8Array(buffer instanceof ArrayBuffer ? buffer : buffer.buffer);\n    }\n  }\n\n  class Convert {\n    static ToString(buffer, enc = "utf8") {\n      const buf = PrepareBuffer(buffer);\n\n      switch (enc.toLowerCase()) {\n        case "utf8":\n          return this.ToUtf8String(buf);\n\n        case "binary":\n          return this.ToBinary(buf);\n\n        case "hex":\n          return this.ToHex(buf);\n\n        case "base64":\n          return this.ToBase64(buf);\n\n        case "base64url":\n          return this.ToBase64Url(buf);\n\n        default:\n          throw new Error(`Unknown type of encoding \'${enc}\'`);\n      }\n    }\n\n    static FromString(str, enc = "utf8") {\n      switch (enc.toLowerCase()) {\n        case "utf8":\n          return this.FromUtf8String(str);\n\n        case "binary":\n          return this.FromBinary(str);\n\n        case "hex":\n          return this.FromHex(str);\n\n        case "base64":\n          return this.FromBase64(str);\n\n        case "base64url":\n          return this.FromBase64Url(str);\n\n        default:\n          throw new Error(`Unknown type of encoding \'${enc}\'`);\n      }\n    }\n\n    static ToBase64(buffer) {\n      const buf = PrepareBuffer(buffer);\n\n      if (typeof btoa !== "undefined") {\n        const binary = this.ToString(buf, "binary");\n        return btoa(binary);\n      } else {\n        return Buffer.from(buf).toString("base64");\n      }\n    }\n\n    static FromBase64(base64Text) {\n      base64Text = base64Text.replace(/\\n/g, "").replace(/\\r/g, "").replace(/\\t/g, "").replace(/\\s/g, "");\n\n      if (typeof atob !== "undefined") {\n        return this.FromBinary(atob(base64Text));\n      } else {\n        return new Uint8Array(Buffer.from(base64Text, "base64")).buffer;\n      }\n    }\n\n    static FromBase64Url(base64url) {\n      return this.FromBase64(this.Base64Padding(base64url.replace(/\\-/g, "+").replace(/\\_/g, "/")));\n    }\n\n    static ToBase64Url(data) {\n      return this.ToBase64(data).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/\\=/g, "");\n    }\n\n    static FromUtf8String(text) {\n      const s = unescape(encodeURIComponent(text));\n      const uintArray = new Uint8Array(s.length);\n\n      for (let i = 0; i < s.length; i++) {\n        uintArray[i] = s.charCodeAt(i);\n      }\n\n      return uintArray.buffer;\n    }\n\n    static ToUtf8String(buffer) {\n      const buf = PrepareBuffer(buffer);\n      const encodedString = String.fromCharCode.apply(null, buf);\n      const decodedString = decodeURIComponent(escape(encodedString));\n      return decodedString;\n    }\n\n    static FromBinary(text) {\n      const stringLength = text.length;\n      const resultView = new Uint8Array(stringLength);\n\n      for (let i = 0; i < stringLength; i++) {\n        resultView[i] = text.charCodeAt(i);\n      }\n\n      return resultView.buffer;\n    }\n\n    static ToBinary(buffer) {\n      const buf = PrepareBuffer(buffer);\n      let resultString = "";\n      const len = buf.length;\n\n      for (let i = 0; i < len; i++) {\n        resultString = resultString + String.fromCharCode(buf[i]);\n      }\n\n      return resultString;\n    }\n\n    static ToHex(buffer) {\n      const buf = PrepareBuffer(buffer);\n      const splitter = "";\n      const res = [];\n      const len = buf.length;\n\n      for (let i = 0; i < len; i++) {\n        const char = buf[i].toString(16);\n        res.push(char.length === 1 ? "0" + char : char);\n      }\n\n      return res.join(splitter);\n    }\n\n    static FromHex(hexString) {\n      const res = new Uint8Array(hexString.length / 2);\n\n      for (let i = 0; i < hexString.length; i = i + 2) {\n        const c = hexString.slice(i, i + 2);\n        res[i / 2] = parseInt(c, 16);\n      }\n\n      return res.buffer;\n    }\n\n    static Base64Padding(base64) {\n      const padCount = 4 - base64.length % 4;\n\n      if (padCount < 4) {\n        for (let i = 0; i < padCount; i++) {\n          base64 += "=";\n        }\n      }\n\n      return base64;\n    }\n\n  }\n\n  function assign(target, ...sources) {\n    const res = arguments[0];\n\n    for (let i = 1; i < arguments.length; i++) {\n      const obj = arguments[i];\n\n      for (const prop in obj) {\n        res[prop] = obj[prop];\n      }\n    }\n\n    return res;\n  }\n\n  function combine(...buf) {\n    const totalByteLength = buf.map(item => item.byteLength).reduce((prev, cur) => prev + cur);\n    const res = new Uint8Array(totalByteLength);\n    let currentPos = 0;\n    buf.map(item => new Uint8Array(item)).forEach(arr => {\n      for (let i = 0; i < arr.length; i++) {\n        res[currentPos++] = arr[i];\n      }\n    });\n    return res.buffer;\n  }\n\n  function isEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n      return false;\n    }\n\n    if (bytes1.byteLength !== bytes2.byteLength) {\n      return false;\n    }\n\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n\n    for (let i = 0; i < bytes1.byteLength; i++) {\n      if (b1[i] !== b2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the "License"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n  See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n\n  function __decorate(decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  }\n\n  class ArrayBufferConverter {\n    static async set(value) {\n      return new Uint8Array(value);\n    }\n\n    static async get(value) {\n      return new Uint8Array(value).buffer;\n    }\n\n  }\n\n  function ProtobufElement(params) {\n    return target => {\n      const t = target;\n      t.localName = params.name || t.name || t.toString().match(/^function\\s*([^\\s(]+)/)[1];\n      t.items = t.items || {};\n      t.target = target;\n      t.items = assign({}, t.items);\n      const scheme = new protobufjs.Type(t.localName);\n\n      for (const key in t.items) {\n        const item = t.items[key];\n        let rule = void 0;\n\n        if (item.repeated) {\n          rule = "repeated";\n        } else if (item.required) {\n          rule = "required";\n        }\n\n        scheme.add(new protobufjs.Field(item.name, item.id, item.type, rule));\n      }\n\n      t.protobuf = scheme;\n    };\n  }\n\n  function defineProperty(target, key, params) {\n    const propertyKey = `_${key}`;\n    const opt = {\n      set: function (v) {\n        if (this[propertyKey] !== v) {\n          this.raw = null;\n          this[propertyKey] = v;\n        }\n      },\n      get: function () {\n        if (this[propertyKey] === void 0) {\n          let defaultValue = params.defaultValue;\n\n          if (params.parser && !params.repeated) {\n            defaultValue = new params.parser();\n          }\n\n          this[propertyKey] = defaultValue;\n        }\n\n        return this[propertyKey];\n      },\n      enumerable: true\n    };\n    Object.defineProperty(target, propertyKey, {\n      writable: true,\n      enumerable: false\n    });\n    Object.defineProperty(target, key, opt);\n  }\n\n  function ProtobufProperty(params) {\n    return (target, propertyKey) => {\n      const t = target.constructor;\n      const key = propertyKey;\n      t.items = t.items || {};\n\n      if (t.target !== t) {\n        t.items = assign({}, t.items);\n        t.target = t;\n      }\n\n      t.items[key] = {\n        id: params.id,\n        type: params.type || "bytes",\n        defaultValue: params.defaultValue,\n        converter: params.converter || null,\n        parser: params.parser || null\n      };\n      params.name = params.name || key;\n      t.items[key].name = params.name;\n      t.items[key].required = params.required || false;\n      t.items[key].repeated = params.repeated || false;\n      defineProperty(target, key, t.items[key]);\n    };\n  }\n\n  class ObjectProto {\n    static async importProto(data) {\n      const res = new this();\n      await res.importProto(data);\n      return res;\n    }\n\n    isEmpty() {\n      return this.raw === undefined;\n    }\n\n    hasChanged() {\n      if (this.raw === null) {\n        return true;\n      }\n\n      const thisStatic = this.constructor;\n      const that = this;\n\n      for (const key in thisStatic.items) {\n        const item = thisStatic.items[key];\n\n        if (item.repeated) {\n          if (item.parser) {\n            return that[key].some(arrayItem => arrayItem.hasChanged());\n          }\n        } else {\n          if (item.parser && that[key] && that[key].hasChanged()) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    async importProto(data) {\n      const thisStatic = this.constructor;\n      const that = this;\n      let scheme;\n      let raw;\n\n      if (data instanceof ObjectProto) {\n        raw = await data.exportProto();\n      } else {\n        raw = data;\n      }\n\n      try {\n        scheme = thisStatic.protobuf.decode(new Uint8Array(raw));\n      } catch (e) {\n        throw new Error(`Error: Cannot decode message for ${thisStatic.localName}.\\n$ProtobufError: ${e.message}`);\n      }\n\n      for (const key in thisStatic.items) {\n        const item = thisStatic.items[key];\n        let schemeValues = scheme[item.name];\n\n        if (ArrayBuffer.isView(schemeValues)) {\n          schemeValues = new Uint8Array(schemeValues);\n        }\n\n        if (!Array.isArray(schemeValues)) {\n          if (item.repeated) {\n            that[key] = schemeValues = [];\n          } else {\n            schemeValues = [schemeValues];\n          }\n        }\n\n        if (item.repeated && !that[key]) {\n          that[key] = [];\n        }\n\n        for (const schemeValue of schemeValues) {\n          if (item.repeated) {\n            that[key].push((await this.importItem(item, schemeValue)));\n          } else {\n            that[key] = await this.importItem(item, schemeValue);\n          }\n        }\n      }\n\n      this.raw = raw;\n    }\n\n    async exportProto() {\n      if (!this.hasChanged()) {\n        return this.raw;\n      }\n\n      const thisStatic = this.constructor;\n      const that = this;\n      const protobuf = {};\n\n      for (const key in thisStatic.items) {\n        const item = thisStatic.items[key];\n        let values = that[key];\n\n        if (!Array.isArray(values)) {\n          values = values === void 0 ? [] : [values];\n        }\n\n        for (const value of values) {\n          const protobufValue = await this.exportItem(item, value);\n\n          if (item.repeated) {\n            if (!protobuf[item.name]) {\n              protobuf[item.name] = [];\n            }\n\n            protobuf[item.name].push(protobufValue);\n          } else {\n            protobuf[item.name] = protobufValue;\n          }\n        }\n      }\n\n      this.raw = new Uint8Array(thisStatic.protobuf.encode(protobuf).finish()).buffer;\n      return this.raw;\n    }\n\n    async exportItem(template, value) {\n      const thisStatic = this.constructor;\n      let result;\n\n      if (template.parser) {\n        const obj = value;\n        const raw = await obj.exportProto();\n\n        if (template.required && !raw) {\n          throw new Error(`Error: Paramter \'${template.name}\' is required in \'${thisStatic.localName}\' protobuf message.`);\n        }\n\n        if (raw) {\n          result = new Uint8Array(raw);\n        }\n      } else {\n        if (template.required && value === void 0) {\n          throw new Error(`Error: Paramter \'${template.name}\' is required in \'${thisStatic.localName}\' protobuf message.`);\n        }\n\n        if (template.converter) {\n          if (value) {\n            result = await template.converter.set(value);\n          }\n        } else {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n\n          result = value;\n        }\n      }\n\n      return result;\n    }\n\n    async importItem(template, value) {\n      const thisStatic = this.constructor;\n      let result;\n\n      if (template.parser) {\n        const parser = template.parser;\n\n        if (value && value.byteLength) {\n          result = await parser.importProto(new Uint8Array(value).buffer);\n        } else if (template.required) {\n          throw new Error(`Error: Parameter \'${template.name}\' is required in \'${thisStatic.localName}\' protobuf message.`);\n        }\n      } else if (template.converter) {\n        if (value && value.byteLength) {\n          result = await template.converter.get(value);\n        } else if (template.required) {\n          throw new Error(`Error: Parameter \'${template.name}\' is required in \'${thisStatic.localName}\' protobuf message.`);\n        }\n      } else {\n        result = value;\n      }\n\n      return result;\n    }\n\n  }\n\n  var domain; // This constructor is used to store event handlers. Instantiating this is\n  // faster than explicitly calling `Object.create(null)` to get a "clean" empty\n  // object (tested with v8 v4.9).\n\n  function EventHandlers() {}\n\n  EventHandlers.prototype = Object.create(null);\n\n  function EventEmitter() {\n    EventEmitter.init.call(this);\n  } // nodejs oddity\n  // require(\'events\') === require(\'events\').EventEmitter\n\n\n  EventEmitter.EventEmitter = EventEmitter;\n  EventEmitter.usingDomains = false;\n  EventEmitter.prototype.domain = undefined;\n  EventEmitter.prototype._events = undefined;\n  EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n  // added to it. This is a useful default which helps finding memory leaks.\n\n  EventEmitter.defaultMaxListeners = 10;\n\n  EventEmitter.init = function () {\n    this.domain = null;\n\n    if (EventEmitter.usingDomains) {\n      // if there is an active domain, then attach to it.\n      if (domain.active && !(this instanceof domain.Domain)) ;\n    }\n\n    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n      this._events = new EventHandlers();\n      this._eventsCount = 0;\n    }\n\n    this._maxListeners = this._maxListeners || undefined;\n  }; // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== \'number\' || n < 0 || isNaN(n)) throw new TypeError(\'"n" argument must be a positive number\');\n    this._maxListeners = n;\n    return this;\n  };\n\n  function $getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n  }\n\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return $getMaxListeners(this);\n  }; // These standalone emit* functions are used to optimize calling of event\n  // handlers for fast cases because emit() itself often has a variable number of\n  // arguments and can be deoptimized because of that. These functions always have\n  // the same number of arguments and thus do not get deoptimized, so the code\n  // inside them can execute faster.\n\n\n  function emitNone(handler, isFn, self) {\n    if (isFn) handler.call(self);else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n\n      for (var i = 0; i < len; ++i) listeners[i].call(self);\n    }\n  }\n\n  function emitOne(handler, isFn, self, arg1) {\n    if (isFn) handler.call(self, arg1);else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n\n      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);\n    }\n  }\n\n  function emitTwo(handler, isFn, self, arg1, arg2) {\n    if (isFn) handler.call(self, arg1, arg2);else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n\n      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);\n    }\n  }\n\n  function emitThree(handler, isFn, self, arg1, arg2, arg3) {\n    if (isFn) handler.call(self, arg1, arg2, arg3);else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n\n      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);\n    }\n  }\n\n  function emitMany(handler, isFn, self, args) {\n    if (isFn) handler.apply(self, args);else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n\n      for (var i = 0; i < len; ++i) listeners[i].apply(self, args);\n    }\n  }\n\n  EventEmitter.prototype.emit = function emit(type) {\n    var er, handler, len, args, i, events, domain;\n    var doError = type === \'error\';\n    events = this._events;\n    if (events) doError = doError && events.error == null;else if (!doError) return false;\n    domain = this.domain; // If there is no \'error\' event listener then throw.\n\n    if (doError) {\n      er = arguments[1];\n\n      if (domain) {\n        if (!er) er = new Error(\'Uncaught, unspecified "error" event\');\n        er.domainEmitter = this;\n        er.domain = domain;\n        er.domainThrown = false;\n        domain.emit(\'error\', er);\n      } else if (er instanceof Error) {\n        throw er; // Unhandled \'error\' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error(\'Uncaught, unspecified "error" event. (\' + er + \')\');\n        err.context = er;\n        throw err;\n      }\n\n      return false;\n    }\n\n    handler = events[type];\n    if (!handler) return false;\n    var isFn = typeof handler === \'function\';\n    len = arguments.length;\n\n    switch (len) {\n      // fast cases\n      case 1:\n        emitNone(handler, isFn, this);\n        break;\n\n      case 2:\n        emitOne(handler, isFn, this, arguments[1]);\n        break;\n\n      case 3:\n        emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n        break;\n\n      case 4:\n        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n        break;\n      // slower\n\n      default:\n        args = new Array(len - 1);\n\n        for (i = 1; i < len; i++) args[i - 1] = arguments[i];\n\n        emitMany(handler, isFn, this, args);\n    }\n\n    return true;\n  };\n\n  function _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    if (typeof listener !== \'function\') throw new TypeError(\'"listener" argument must be a function\');\n    events = target._events;\n\n    if (!events) {\n      events = target._events = new EventHandlers();\n      target._eventsCount = 0;\n    } else {\n      // To avoid recursion in the case that type === "newListener"! Before\n      // adding it to the listeners, first emit "newListener".\n      if (events.newListener) {\n        target.emit(\'newListener\', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n        // this._events to be assigned to a new object\n\n        events = target._events;\n      }\n\n      existing = events[type];\n    }\n\n    if (!existing) {\n      // Optimize the case of one listener. Don\'t need the extra array object.\n      existing = events[type] = listener;\n      ++target._eventsCount;\n    } else {\n      if (typeof existing === \'function\') {\n        // Adding the second element, need to change to array.\n        existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      } else {\n        // If we\'ve already got an array, just append.\n        if (prepend) {\n          existing.unshift(listener);\n        } else {\n          existing.push(listener);\n        }\n      } // Check for listener leak\n\n\n      if (!existing.warned) {\n        m = $getMaxListeners(target);\n\n        if (m && m > 0 && existing.length > m) {\n          existing.warned = true;\n          var w = new Error(\'Possible EventEmitter memory leak detected. \' + existing.length + \' \' + type + \' listeners added. \' + \'Use emitter.setMaxListeners() to increase limit\');\n          w.name = \'MaxListenersExceededWarning\';\n          w.emitter = target;\n          w.type = type;\n          w.count = existing.length;\n          emitWarning(w);\n        }\n      }\n    }\n\n    return target;\n  }\n\n  function emitWarning(e) {\n    typeof console.warn === \'function\' ? console.warn(e) : console.log(e);\n  }\n\n  EventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  };\n\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n  EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  };\n\n  function _onceWrap(target, type, listener) {\n    var fired = false;\n\n    function g() {\n      target.removeListener(type, g);\n\n      if (!fired) {\n        fired = true;\n        listener.apply(target, arguments);\n      }\n    }\n\n    g.listener = listener;\n    return g;\n  }\n\n  EventEmitter.prototype.once = function once(type, listener) {\n    if (typeof listener !== \'function\') throw new TypeError(\'"listener" argument must be a function\');\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n  };\n\n  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    if (typeof listener !== \'function\') throw new TypeError(\'"listener" argument must be a function\');\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n  }; // emits a \'removeListener\' event iff the listener was removed\n\n\n  EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    if (typeof listener !== \'function\') throw new TypeError(\'"listener" argument must be a function\');\n    events = this._events;\n    if (!events) return this;\n    list = events[type];\n    if (!list) return this;\n\n    if (list === listener || list.listener && list.listener === listener) {\n      if (--this._eventsCount === 0) this._events = new EventHandlers();else {\n        delete events[type];\n        if (events.removeListener) this.emit(\'removeListener\', type, list.listener || listener);\n      }\n    } else if (typeof list !== \'function\') {\n      position = -1;\n\n      for (i = list.length; i-- > 0;) {\n        if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n          originalListener = list[i].listener;\n          position = i;\n          break;\n        }\n      }\n\n      if (position < 0) return this;\n\n      if (list.length === 1) {\n        list[0] = undefined;\n\n        if (--this._eventsCount === 0) {\n          this._events = new EventHandlers();\n          return this;\n        } else {\n          delete events[type];\n        }\n      } else {\n        spliceOne(list, position);\n      }\n\n      if (events.removeListener) this.emit(\'removeListener\', type, originalListener || listener);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events;\n    events = this._events;\n    if (!events) return this; // not listening for removeListener, no need to emit\n\n    if (!events.removeListener) {\n      if (arguments.length === 0) {\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n      } else if (events[type]) {\n        if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];\n      }\n\n      return this;\n    } // emit removeListener for all listeners on all events\n\n\n    if (arguments.length === 0) {\n      var keys = Object.keys(events);\n\n      for (var i = 0, key; i < keys.length; ++i) {\n        key = keys[i];\n        if (key === \'removeListener\') continue;\n        this.removeAllListeners(key);\n      }\n\n      this.removeAllListeners(\'removeListener\');\n      this._events = new EventHandlers();\n      this._eventsCount = 0;\n      return this;\n    }\n\n    listeners = events[type];\n\n    if (typeof listeners === \'function\') {\n      this.removeListener(type, listeners);\n    } else if (listeners) {\n      // LIFO order\n      do {\n        this.removeListener(type, listeners[listeners.length - 1]);\n      } while (listeners[0]);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function listeners(type) {\n    var evlistener;\n    var ret;\n    var events = this._events;\n    if (!events) ret = [];else {\n      evlistener = events[type];\n      if (!evlistener) ret = [];else if (typeof evlistener === \'function\') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);\n    }\n    return ret;\n  };\n\n  EventEmitter.listenerCount = function (emitter, type) {\n    if (typeof emitter.listenerCount === \'function\') {\n      return emitter.listenerCount(type);\n    } else {\n      return listenerCount.call(emitter, type);\n    }\n  };\n\n  EventEmitter.prototype.listenerCount = listenerCount;\n\n  function listenerCount(type) {\n    var events = this._events;\n\n    if (events) {\n      var evlistener = events[type];\n\n      if (typeof evlistener === \'function\') {\n        return 1;\n      } else if (evlistener) {\n        return evlistener.length;\n      }\n    }\n\n    return 0;\n  }\n\n  EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n  }; // About 1.5x faster than the two-arg version of Array#splice().\n\n\n  function spliceOne(list, index) {\n    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];\n\n    list.pop();\n  }\n\n  function arrayClone(arr, i) {\n    var copy = new Array(i);\n\n    while (i--) copy[i] = arr[i];\n\n    return copy;\n  }\n\n  function unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n\n    for (var i = 0; i < ret.length; ++i) {\n      ret[i] = arr[i].listener || arr[i];\n    }\n\n    return ret;\n  }\n  /**\n   *\n   * 2key-ratchet\n   * Copyright (c) 2019 Peculiar Ventures, Inc\n   * Based on https://whispersystems.org/docs/specifications/doubleratchet/ and\n   * https://whispersystems.org/docs/specifications/x3dh/ by Open Whisper Systems\n   *\n   */\n\n\n  const SIGN_ALGORITHM_NAME = "ECDSA";\n  const DH_ALGORITHM_NAME = "ECDH";\n  const SECRET_KEY_NAME = "AES-CBC";\n  const HASH_NAME = "SHA-256";\n  const HMAC_NAME = "HMAC";\n  const MAX_RATCHET_STACK_SIZE = 20;\n  const INFO_TEXT = Convert.FromBinary("InfoText");\n  const INFO_RATCHET = Convert.FromBinary("InfoRatchet");\n  const INFO_MESSAGE_KEYS = Convert.FromBinary("InfoMessageKeys");\n  let engine = null;\n\n  if (typeof self !== "undefined") {\n    engine = {\n      crypto: self.crypto,\n      name: "WebCrypto"\n    };\n  }\n\n  function setEngine(name, crypto) {\n    engine = {\n      crypto,\n      name\n    };\n  }\n\n  function getEngine() {\n    if (!engine) {\n      throw new Error("WebCrypto engine is empty. Use setEngine to resolve it.");\n    }\n\n    return engine;\n  }\n\n  class Curve {\n    static async generateKeyPair(type) {\n      const name = type;\n      const usage = type === "ECDSA" ? ["sign", "verify"] : ["deriveKey", "deriveBits"];\n      const keys = await getEngine().crypto.subtle.generateKey({\n        name,\n        namedCurve: this.NAMED_CURVE\n      }, false, usage);\n      const publicKey = await ECPublicKey.create(keys.publicKey);\n      const res = {\n        privateKey: keys.privateKey,\n        publicKey\n      };\n      return res;\n    }\n\n    static deriveBytes(privateKey, publicKey) {\n      return getEngine().crypto.subtle.deriveBits({\n        name: "ECDH",\n        public: publicKey.key\n      }, privateKey, 256);\n    }\n\n    static verify(signingKey, message, signature) {\n      return getEngine().crypto.subtle.verify({\n        name: "ECDSA",\n        hash: this.DIGEST_ALGORITHM\n      }, signingKey.key, signature, message);\n    }\n\n    static async sign(signingKey, message) {\n      return getEngine().crypto.subtle.sign({\n        name: "ECDSA",\n        hash: this.DIGEST_ALGORITHM\n      }, signingKey, message);\n    }\n\n    static async ecKeyPairToJson(key) {\n      return {\n        privateKey: key.privateKey,\n        publicKey: key.publicKey.key,\n        thumbprint: await key.publicKey.thumbprint()\n      };\n    }\n\n    static async ecKeyPairFromJson(keys) {\n      return {\n        privateKey: keys.privateKey,\n        publicKey: await ECPublicKey.create(keys.publicKey)\n      };\n    }\n\n  }\n\n  Curve.NAMED_CURVE = "P-256";\n  Curve.DIGEST_ALGORITHM = "SHA-512";\n  const AES_ALGORITHM = {\n    name: "AES-CBC",\n    length: 256\n  };\n\n  class Secret {\n    static randomBytes(size) {\n      const array = new Uint8Array(size);\n      getEngine().crypto.getRandomValues(array);\n      return array.buffer;\n    }\n\n    static digest(alg, message) {\n      return getEngine().crypto.subtle.digest(alg, message);\n    }\n\n    static encrypt(key, data, iv) {\n      return getEngine().crypto.subtle.encrypt({\n        name: SECRET_KEY_NAME,\n        iv: new Uint8Array(iv)\n      }, key, data);\n    }\n\n    static decrypt(key, data, iv) {\n      return getEngine().crypto.subtle.decrypt({\n        name: SECRET_KEY_NAME,\n        iv: new Uint8Array(iv)\n      }, key, data);\n    }\n\n    static importHMAC(raw) {\n      return getEngine().crypto.subtle.importKey("raw", raw, {\n        name: HMAC_NAME,\n        hash: {\n          name: HASH_NAME\n        }\n      }, false, ["sign", "verify"]);\n    }\n\n    static importAES(raw) {\n      return getEngine().crypto.subtle.importKey("raw", raw, AES_ALGORITHM, false, ["encrypt", "decrypt"]);\n    }\n\n    static async sign(key, data) {\n      return await getEngine().crypto.subtle.sign({\n        name: HMAC_NAME,\n        hash: HASH_NAME\n      }, key, data);\n    }\n\n    static async HKDF(IKM, keysCount = 1, salt, info = new ArrayBuffer(0)) {\n      if (!salt) {\n        salt = await this.importHMAC(new Uint8Array(32).buffer);\n      }\n\n      const PRKBytes = await this.sign(salt, IKM);\n      const infoBuffer = new ArrayBuffer(32 + info.byteLength + 1);\n      const PRK = await this.importHMAC(PRKBytes);\n      const T = [new ArrayBuffer(0)];\n\n      for (let i = 0; i < keysCount; i++) {\n        T[i + 1] = await this.sign(PRK, combine(T[i], info, new Uint8Array([i + 1]).buffer));\n      }\n\n      return T.slice(1);\n    }\n\n  }\n\n  class ECPublicKey {\n    static async create(publicKey) {\n      const res = new this();\n      const algName = publicKey.algorithm.name.toUpperCase();\n\n      if (!(algName === "ECDH" || algName === "ECDSA")) {\n        throw new Error("Error: Unsupported asymmetric key algorithm.");\n      }\n\n      if (publicKey.type !== "public") {\n        throw new Error("Error: Expected key type to be public but it was not.");\n      }\n\n      res.key = publicKey;\n      const jwk = await getEngine().crypto.subtle.exportKey("jwk", publicKey);\n\n      if (!(jwk.x && jwk.y)) {\n        throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");\n      }\n\n      const x = Convert.FromBase64Url(jwk.x);\n      const y = Convert.FromBase64Url(jwk.y);\n      const xy = Convert.ToBinary(x) + Convert.ToBinary(y);\n      res.serialized = Convert.FromBinary(xy);\n      res.id = await res.thumbprint();\n      return res;\n    }\n\n    static async importKey(bytes, type) {\n      const x = Convert.ToBase64Url(bytes.slice(0, 32));\n      const y = Convert.ToBase64Url(bytes.slice(32));\n      const jwk = {\n        crv: Curve.NAMED_CURVE,\n        kty: "EC",\n        x,\n        y\n      };\n      const usage = type === "ECDSA" ? ["verify"] : [];\n      const key = await getEngine().crypto.subtle.importKey("jwk", jwk, {\n        name: type,\n        namedCurve: Curve.NAMED_CURVE\n      }, true, usage);\n      const res = await ECPublicKey.create(key);\n      return res;\n    }\n\n    serialize() {\n      return this.serialized;\n    }\n\n    async thumbprint() {\n      const bytes = await this.serialize();\n      const thumbprint = await Secret.digest("SHA-256", bytes);\n      return Convert.ToHex(thumbprint);\n    }\n\n    async isEqual(other) {\n      if (!(other && other instanceof ECPublicKey)) {\n        return false;\n      }\n\n      return isEqual(this.serialized, other.serialized);\n    }\n\n  }\n\n  class Identity {\n    static async fromJSON(obj) {\n      const signingKey = await Curve.ecKeyPairFromJson(obj.signingKey);\n      const exchangeKey = await Curve.ecKeyPairFromJson(obj.exchangeKey);\n      const res = new this(obj.id, signingKey, exchangeKey);\n      res.createdAt = new Date(obj.createdAt);\n      await res.fromJSON(obj);\n      return res;\n    }\n\n    static async create(id, signedPreKeyAmount = 0, preKeyAmount = 0) {\n      const signingKey = await Curve.generateKeyPair(SIGN_ALGORITHM_NAME);\n      const exchangeKey = await Curve.generateKeyPair(DH_ALGORITHM_NAME);\n      const res = new Identity(id, signingKey, exchangeKey);\n      res.createdAt = new Date();\n\n      for (let i = 0; i < preKeyAmount; i++) {\n        res.preKeys.push((await Curve.generateKeyPair("ECDH")));\n      }\n\n      for (let i = 0; i < signedPreKeyAmount; i++) {\n        res.signedPreKeys.push((await Curve.generateKeyPair("ECDH")));\n      }\n\n      return res;\n    }\n\n    constructor(id, signingKey, exchangeKey) {\n      this.id = id;\n      this.signingKey = signingKey;\n      this.exchangeKey = exchangeKey;\n      this.preKeys = [];\n      this.signedPreKeys = [];\n    }\n\n    async toJSON() {\n      const preKeys = [];\n      const signedPreKeys = [];\n\n      for (const key of this.preKeys) {\n        preKeys.push((await Curve.ecKeyPairToJson(key)));\n      }\n\n      for (const key of this.signedPreKeys) {\n        signedPreKeys.push((await Curve.ecKeyPairToJson(key)));\n      }\n\n      return {\n        createdAt: this.createdAt.toISOString(),\n        exchangeKey: await Curve.ecKeyPairToJson(this.exchangeKey),\n        id: this.id,\n        preKeys,\n        signedPreKeys,\n        signingKey: await Curve.ecKeyPairToJson(this.signingKey)\n      };\n    }\n\n    async fromJSON(obj) {\n      this.id = obj.id;\n      this.signingKey = await Curve.ecKeyPairFromJson(obj.signingKey);\n      this.exchangeKey = await Curve.ecKeyPairFromJson(obj.exchangeKey);\n      this.preKeys = [];\n\n      for (const key of obj.preKeys) {\n        this.preKeys.push((await Curve.ecKeyPairFromJson(key)));\n      }\n\n      this.signedPreKeys = [];\n\n      for (const key of obj.signedPreKeys) {\n        this.signedPreKeys.push((await Curve.ecKeyPairFromJson(key)));\n      }\n    }\n\n  }\n\n  class RemoteIdentity {\n    static fill(protocol) {\n      const res = new RemoteIdentity();\n      res.fill(protocol);\n      return res;\n    }\n\n    static async fromJSON(obj) {\n      const res = new this();\n      await res.fromJSON(obj);\n      return res;\n    }\n\n    fill(protocol) {\n      this.signingKey = protocol.signingKey;\n      this.exchangeKey = protocol.exchangeKey;\n      this.signature = protocol.signature;\n      this.createdAt = protocol.createdAt;\n    }\n\n    verify() {\n      return Curve.verify(this.signingKey, this.exchangeKey.serialize(), this.signature);\n    }\n\n    async toJSON() {\n      return {\n        createdAt: this.createdAt.toISOString(),\n        exchangeKey: await this.exchangeKey.key,\n        id: this.id,\n        signature: this.signature,\n        signingKey: await this.signingKey.key,\n        thumbprint: await this.signingKey.thumbprint()\n      };\n    }\n\n    async fromJSON(obj) {\n      this.id = obj.id;\n      this.signature = obj.signature;\n      this.signingKey = await ECPublicKey.create(obj.signingKey);\n      this.exchangeKey = await ECPublicKey.create(obj.exchangeKey);\n      this.createdAt = new Date(obj.createdAt);\n      const ok = await this.verify();\n\n      if (!ok) {\n        throw new Error("Error: Wrong signature for RemoteIdentity");\n      }\n    }\n\n  }\n\n  let BaseProtocol = class BaseProtocol extends ObjectProto {};\n\n  __decorate([ProtobufProperty({\n    id: 0,\n    type: "uint32",\n    defaultValue: 1\n  })], BaseProtocol.prototype, "version", void 0);\n\n  BaseProtocol = __decorate([ProtobufElement({\n    name: "Base"\n  })], BaseProtocol);\n\n  class ECDSAPublicKeyConverter {\n    static async set(value) {\n      return new Uint8Array(value.serialize());\n    }\n\n    static async get(value) {\n      return ECPublicKey.importKey(value.buffer, "ECDSA");\n    }\n\n  }\n\n  class ECDHPublicKeyConverter {\n    static async set(value) {\n      return new Uint8Array(value.serialize());\n    }\n\n    static async get(value) {\n      return ECPublicKey.importKey(value.buffer, "ECDH");\n    }\n\n  }\n\n  class DateConverter {\n    static async set(value) {\n      return new Uint8Array(Convert.FromString(value.toISOString()));\n    }\n\n    static async get(value) {\n      return new Date(Convert.ToString(value));\n    }\n\n  }\n\n  var IdentityProtocol_1;\n  let IdentityProtocol = IdentityProtocol_1 = class IdentityProtocol extends BaseProtocol {\n    static async fill(identity) {\n      const res = new IdentityProtocol_1();\n      await res.fill(identity);\n      return res;\n    }\n\n    async sign(key) {\n      this.signature = await Curve.sign(key, this.exchangeKey.serialize());\n    }\n\n    async verify() {\n      return await Curve.verify(this.signingKey, this.exchangeKey.serialize(), this.signature);\n    }\n\n    async fill(identity) {\n      this.signingKey = identity.signingKey.publicKey;\n      this.exchangeKey = identity.exchangeKey.publicKey;\n      this.createdAt = identity.createdAt;\n      await this.sign(identity.signingKey.privateKey);\n    }\n\n  };\n\n  __decorate([ProtobufProperty({\n    id: 1,\n    converter: ECDSAPublicKeyConverter\n  })], IdentityProtocol.prototype, "signingKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 2,\n    converter: ECDHPublicKeyConverter\n  })], IdentityProtocol.prototype, "exchangeKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 3\n  })], IdentityProtocol.prototype, "signature", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 4,\n    converter: DateConverter\n  })], IdentityProtocol.prototype, "createdAt", void 0);\n\n  IdentityProtocol = IdentityProtocol_1 = __decorate([ProtobufElement({\n    name: "Identity"\n  })], IdentityProtocol);\n  let MessageProtocol = class MessageProtocol extends BaseProtocol {};\n\n  __decorate([ProtobufProperty({\n    id: 1,\n    converter: ECDHPublicKeyConverter,\n    required: true\n  })], MessageProtocol.prototype, "senderRatchetKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 2,\n    type: "uint32",\n    required: true\n  })], MessageProtocol.prototype, "counter", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 3,\n    type: "uint32",\n    required: true\n  })], MessageProtocol.prototype, "previousCounter", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 4,\n    converter: ArrayBufferConverter,\n    required: true\n  })], MessageProtocol.prototype, "cipherText", void 0);\n\n  MessageProtocol = __decorate([ProtobufElement({\n    name: "Message"\n  })], MessageProtocol);\n  let MessageSignedProtocol = class MessageSignedProtocol extends BaseProtocol {\n    async sign(hmacKey) {\n      this.signature = await this.signHMAC(hmacKey);\n    }\n\n    async verify(hmacKey) {\n      const signature = await this.signHMAC(hmacKey);\n      return isEqual(signature, this.signature);\n    }\n\n    async getSignedRaw() {\n      const receiverKey = this.receiverKey.serialize();\n      const senderKey = this.senderKey.serialize();\n      const message = await this.message.exportProto();\n      const data = combine(receiverKey, senderKey, message);\n      return data;\n    }\n\n    async signHMAC(macKey) {\n      const data = await this.getSignedRaw();\n      const signature = await Secret.sign(macKey, data);\n      return signature;\n    }\n\n  };\n\n  __decorate([ProtobufProperty({\n    id: 1,\n    converter: ECDSAPublicKeyConverter,\n    required: true\n  })], MessageSignedProtocol.prototype, "senderKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 2,\n    parser: MessageProtocol,\n    required: true\n  })], MessageSignedProtocol.prototype, "message", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 3,\n    required: true\n  })], MessageSignedProtocol.prototype, "signature", void 0);\n\n  MessageSignedProtocol = __decorate([ProtobufElement({\n    name: "MessageSigned"\n  })], MessageSignedProtocol);\n  let PreKeyMessageProtocol = class PreKeyMessageProtocol extends BaseProtocol {};\n\n  __decorate([ProtobufProperty({\n    id: 1,\n    type: "uint32",\n    required: true\n  })], PreKeyMessageProtocol.prototype, "registrationId", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 2,\n    type: "uint32"\n  })], PreKeyMessageProtocol.prototype, "preKeyId", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 3,\n    type: "uint32",\n    required: true\n  })], PreKeyMessageProtocol.prototype, "preKeySignedId", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 4,\n    converter: ECDHPublicKeyConverter,\n    required: true\n  })], PreKeyMessageProtocol.prototype, "baseKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 5,\n    parser: IdentityProtocol,\n    required: true\n  })], PreKeyMessageProtocol.prototype, "identity", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 6,\n    parser: MessageSignedProtocol,\n    required: true\n  })], PreKeyMessageProtocol.prototype, "signedMessage", void 0);\n\n  PreKeyMessageProtocol = __decorate([ProtobufElement({\n    name: "PreKeyMessage"\n  })], PreKeyMessageProtocol);\n  let PreKeyProtocol = class PreKeyProtocol extends BaseProtocol {};\n\n  __decorate([ProtobufProperty({\n    id: 1,\n    type: "uint32",\n    required: true\n  })], PreKeyProtocol.prototype, "id", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 2,\n    converter: ECDHPublicKeyConverter,\n    required: true\n  })], PreKeyProtocol.prototype, "key", void 0);\n\n  PreKeyProtocol = __decorate([ProtobufElement({\n    name: "PreKey"\n  })], PreKeyProtocol);\n  let PreKeySignedProtocol = class PreKeySignedProtocol extends PreKeyProtocol {\n    async sign(key) {\n      this.signature = await Curve.sign(key, this.key.serialize());\n    }\n\n    verify(key) {\n      return Curve.verify(key, this.key.serialize(), this.signature);\n    }\n\n  };\n\n  __decorate([ProtobufProperty({\n    id: 3,\n    converter: ArrayBufferConverter,\n    required: true\n  })], PreKeySignedProtocol.prototype, "signature", void 0);\n\n  PreKeySignedProtocol = __decorate([ProtobufElement({\n    name: "PreKeySigned"\n  })], PreKeySignedProtocol);\n  let PreKeyBundleProtocol = class PreKeyBundleProtocol extends BaseProtocol {};\n\n  __decorate([ProtobufProperty({\n    id: 1,\n    type: "uint32",\n    required: true\n  })], PreKeyBundleProtocol.prototype, "registrationId", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 2,\n    parser: IdentityProtocol,\n    required: true\n  })], PreKeyBundleProtocol.prototype, "identity", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 3,\n    parser: PreKeyProtocol\n  })], PreKeyBundleProtocol.prototype, "preKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: 4,\n    parser: PreKeySignedProtocol,\n    required: true\n  })], PreKeyBundleProtocol.prototype, "preKeySigned", void 0);\n\n  PreKeyBundleProtocol = __decorate([ProtobufElement({\n    name: "PreKeyBundle"\n  })], PreKeyBundleProtocol);\n\n  class Stack {\n    constructor(maxSize = 20) {\n      this.items = [];\n      this.maxSize = maxSize;\n    }\n\n    get length() {\n      return this.items.length;\n    }\n\n    get latest() {\n      return this.items[this.length - 1];\n    }\n\n    push(item) {\n      if (this.length === this.maxSize) {\n        this.items = this.items.slice(1);\n      }\n\n      this.items.push(item);\n    }\n\n    async toJSON() {\n      const res = [];\n\n      for (const item of this.items) {\n        res.push((await item.toJSON()));\n      }\n\n      return res;\n    }\n\n    async fromJSON(obj) {\n      this.items = obj;\n    }\n\n  }\n\n  const CIPHER_KEY_KDF_INPUT = new Uint8Array([1]).buffer;\n  const ROOT_KEY_KDF_INPUT = new Uint8Array([2]).buffer;\n\n  class SymmetricRatchet {\n    constructor(rootKey) {\n      this.counter = 0;\n      this.rootKey = rootKey;\n    }\n\n    static async fromJSON(obj) {\n      const res = new this(obj.rootKey);\n      res.fromJSON(obj);\n      return res;\n    }\n\n    async toJSON() {\n      return {\n        counter: this.counter,\n        rootKey: this.rootKey\n      };\n    }\n\n    async fromJSON(obj) {\n      this.counter = obj.counter;\n      this.rootKey = obj.rootKey;\n    }\n\n    async calculateKey(rootKey) {\n      const cipherKeyBytes = await Secret.sign(rootKey, CIPHER_KEY_KDF_INPUT);\n      const nextRootKeyBytes = await Secret.sign(rootKey, ROOT_KEY_KDF_INPUT);\n      const res = {\n        cipher: cipherKeyBytes,\n        rootKey: await Secret.importHMAC(nextRootKeyBytes)\n      };\n      return res;\n    }\n\n    async click() {\n      const rootKey = this.rootKey;\n      const res = await this.calculateKey(rootKey);\n      this.rootKey = res.rootKey;\n      this.counter++;\n      return res.cipher;\n    }\n\n  }\n\n  class SendingRatchet extends SymmetricRatchet {\n    async encrypt(message) {\n      const cipherKey = await this.click();\n      const keys = await Secret.HKDF(cipherKey, 3, void 0, INFO_MESSAGE_KEYS);\n      const aesKey = await Secret.importAES(keys[0]);\n      const hmacKey = await Secret.importHMAC(keys[1]);\n      const iv = keys[2].slice(0, 16);\n      const cipherText = await Secret.encrypt(aesKey, message, iv);\n      return {\n        cipherText,\n        hmacKey\n      };\n    }\n\n  }\n\n  class ReceivingRatchet extends SymmetricRatchet {\n    constructor() {\n      super(...arguments);\n      this.keys = [];\n    }\n\n    async toJSON() {\n      const res = await super.toJSON();\n      res.keys = this.keys;\n      return res;\n    }\n\n    async fromJSON(obj) {\n      await super.fromJSON(obj);\n      this.keys = obj.keys;\n    }\n\n    async decrypt(message, counter) {\n      const cipherKey = await this.getKey(counter);\n      const keys = await Secret.HKDF(cipherKey, 3, void 0, INFO_MESSAGE_KEYS);\n      const aesKey = await Secret.importAES(keys[0]);\n      const hmacKey = await Secret.importHMAC(keys[1]);\n      const iv = keys[2].slice(0, 16);\n      const cipherText = await Secret.decrypt(aesKey, message, iv);\n      return {\n        cipherText,\n        hmacKey\n      };\n    }\n\n    async getKey(counter) {\n      while (this.counter <= counter) {\n        const cipherKey = await this.click();\n        this.keys.push(cipherKey);\n      }\n\n      const key = this.keys[counter];\n      return key;\n    }\n\n  }\n\n  async function authenticateA(IKa, EKa, IKb, SPKb, OPKb) {\n    const DH1 = await Curve.deriveBytes(IKa.exchangeKey.privateKey, SPKb);\n    const DH2 = await Curve.deriveBytes(EKa.privateKey, IKb);\n    const DH3 = await Curve.deriveBytes(EKa.privateKey, SPKb);\n    let DH4 = new ArrayBuffer(0);\n\n    if (OPKb) {\n      DH4 = await Curve.deriveBytes(EKa.privateKey, OPKb);\n    }\n\n    const _F = new Uint8Array(32);\n\n    for (let i = 0; i < _F.length; i++) {\n      _F[i] = 0xff;\n    }\n\n    const F = _F.buffer;\n    const KM = combine(F, DH1, DH2, DH3, DH4);\n    const keys = await Secret.HKDF(KM, 1, void 0, INFO_TEXT);\n    return await Secret.importHMAC(keys[0]);\n  }\n\n  async function authenticateB(IKb, SPKb, IKa, EKa, OPKb) {\n    const DH1 = await Curve.deriveBytes(SPKb.privateKey, IKa);\n    const DH2 = await Curve.deriveBytes(IKb.exchangeKey.privateKey, EKa);\n    const DH3 = await Curve.deriveBytes(SPKb.privateKey, EKa);\n    let DH4 = new ArrayBuffer(0);\n\n    if (OPKb) {\n      DH4 = await Curve.deriveBytes(OPKb, EKa);\n    }\n\n    const _F = new Uint8Array(32);\n\n    for (let i = 0; i < _F.length; i++) {\n      _F[i] = 0xff;\n    }\n\n    const F = _F.buffer;\n    const KM = combine(F, DH1, DH2, DH3, DH4);\n    const keys = await Secret.HKDF(KM, 1, void 0, INFO_TEXT);\n    return await Secret.importHMAC(keys[0]);\n  }\n\n  class AsymmetricRatchet extends EventEmitter {\n    constructor() {\n      super();\n      this.counter = 0;\n      this.currentStep = new DHRatchetStep();\n      this.steps = new DHRatchetStepStack(MAX_RATCHET_STACK_SIZE);\n      this.promises = {};\n    }\n\n    static async create(identity, protocol) {\n      let rootKey;\n      const ratchet = new AsymmetricRatchet();\n\n      if (protocol instanceof PreKeyBundleProtocol) {\n        if (!(await protocol.identity.verify())) {\n          throw new Error("Error: Remote client\'s identity key is invalid.");\n        }\n\n        if (!(await protocol.preKeySigned.verify(protocol.identity.signingKey))) {\n          throw new Error("Error: Remote client\'s signed prekey is invalid.");\n        }\n\n        ratchet.currentRatchetKey = await ratchet.generateRatchetKey();\n        ratchet.currentStep.remoteRatchetKey = protocol.preKeySigned.key;\n        ratchet.remoteIdentity = RemoteIdentity.fill(protocol.identity);\n        ratchet.remoteIdentity.id = protocol.registrationId;\n        ratchet.remotePreKeyId = protocol.preKey.id;\n        ratchet.remotePreKeySignedId = protocol.preKeySigned.id;\n        rootKey = await authenticateA(identity, ratchet.currentRatchetKey, protocol.identity.exchangeKey, protocol.preKeySigned.key, protocol.preKey.key);\n      } else {\n        if (!(await protocol.identity.verify())) {\n          throw new Error("Error: Remote client\'s identity key is invalid.");\n        }\n\n        const signedPreKey = identity.signedPreKeys[protocol.preKeySignedId];\n\n        if (!signedPreKey) {\n          throw new Error(`Error: PreKey with id ${protocol.preKeySignedId} not found`);\n        }\n\n        let preKey;\n\n        if (protocol.preKeyId !== void 0) {\n          preKey = identity.preKeys[protocol.preKeyId];\n        }\n\n        ratchet.remoteIdentity = RemoteIdentity.fill(protocol.identity);\n        ratchet.currentRatchetKey = signedPreKey;\n        rootKey = await authenticateB(identity, ratchet.currentRatchetKey, protocol.identity.exchangeKey, protocol.signedMessage.message.senderRatchetKey, preKey && preKey.privateKey);\n      }\n\n      ratchet.identity = identity;\n      ratchet.id = identity.id;\n      ratchet.rootKey = rootKey;\n      return ratchet;\n    }\n\n    static async fromJSON(identity, remote, obj) {\n      const res = new AsymmetricRatchet();\n      res.identity = identity;\n      res.remoteIdentity = remote;\n      await res.fromJSON(obj);\n      return res;\n    }\n\n    on(event, listener) {\n      return super.on(event, listener);\n    }\n\n    once(event, listener) {\n      return super.once(event, listener);\n    }\n\n    async decrypt(protocol) {\n      return this.queuePromise("encrypt", async () => {\n        const remoteRatchetKey = protocol.message.senderRatchetKey;\n        const message = protocol.message;\n\n        if (protocol.message.previousCounter < this.counter - MAX_RATCHET_STACK_SIZE) {\n          throw new Error("Error: Too old message");\n        }\n\n        let step = this.steps.getStep(remoteRatchetKey);\n\n        if (!step) {\n          const ratchetStep = new DHRatchetStep();\n          ratchetStep.remoteRatchetKey = remoteRatchetKey;\n          this.steps.push(ratchetStep);\n          this.currentStep = ratchetStep;\n          step = ratchetStep;\n        }\n\n        if (!step.receivingChain) {\n          step.receivingChain = await this.createChain(this.currentRatchetKey.privateKey, remoteRatchetKey, ReceivingRatchet);\n        }\n\n        const decryptedMessage = await step.receivingChain.decrypt(message.cipherText, message.counter);\n        this.update();\n        protocol.senderKey = this.remoteIdentity.signingKey;\n        protocol.receiverKey = this.identity.signingKey.publicKey;\n\n        if (!(await protocol.verify(decryptedMessage.hmacKey))) {\n          throw new Error("Error: The Message did not successfully verify!");\n        }\n\n        return decryptedMessage.cipherText;\n      });\n    }\n\n    async encrypt(message) {\n      return this.queuePromise("encrypt", async () => {\n        if (this.currentStep.receivingChain && !this.currentStep.sendingChain) {\n          this.counter++;\n          this.currentRatchetKey = await this.generateRatchetKey();\n        }\n\n        if (!this.currentStep.sendingChain) {\n          if (!this.currentStep.remoteRatchetKey) {\n            throw new Error("currentStep has empty remoteRatchetKey");\n          }\n\n          this.currentStep.sendingChain = await this.createChain(this.currentRatchetKey.privateKey, this.currentStep.remoteRatchetKey, SendingRatchet);\n        }\n\n        const encryptedMessage = await this.currentStep.sendingChain.encrypt(message);\n        this.update();\n        let preKeyMessage;\n\n        if (this.steps.length === 0 && !this.currentStep.receivingChain && this.currentStep.sendingChain.counter === 1) {\n          preKeyMessage = new PreKeyMessageProtocol();\n          preKeyMessage.registrationId = this.identity.id;\n          preKeyMessage.preKeyId = this.remotePreKeyId;\n          preKeyMessage.preKeySignedId = this.remotePreKeySignedId;\n          preKeyMessage.baseKey = this.currentRatchetKey.publicKey;\n          await preKeyMessage.identity.fill(this.identity);\n        }\n\n        const signedMessage = new MessageSignedProtocol();\n        signedMessage.receiverKey = this.remoteIdentity.signingKey;\n        signedMessage.senderKey = this.identity.signingKey.publicKey;\n        signedMessage.message.cipherText = encryptedMessage.cipherText;\n        signedMessage.message.counter = this.currentStep.sendingChain.counter - 1;\n        signedMessage.message.previousCounter = this.counter;\n        signedMessage.message.senderRatchetKey = this.currentRatchetKey.publicKey;\n        await signedMessage.sign(encryptedMessage.hmacKey);\n\n        if (preKeyMessage) {\n          preKeyMessage.signedMessage = signedMessage;\n          return preKeyMessage;\n        } else {\n          return signedMessage;\n        }\n      });\n    }\n\n    async hasRatchetKey(key) {\n      let ecKey;\n\n      if (!(key instanceof ECPublicKey)) {\n        ecKey = await ECPublicKey.create(key);\n      } else {\n        ecKey = key;\n      }\n\n      for (const item of this.steps.items) {\n        if (await item.remoteRatchetKey.isEqual(ecKey)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    async toJSON() {\n      return {\n        counter: this.counter,\n        ratchetKey: await Curve.ecKeyPairToJson(this.currentRatchetKey),\n        remoteIdentity: await this.remoteIdentity.signingKey.thumbprint(),\n        rootKey: this.rootKey,\n        steps: await this.steps.toJSON()\n      };\n    }\n\n    async fromJSON(obj) {\n      this.currentRatchetKey = await Curve.ecKeyPairFromJson(obj.ratchetKey);\n      this.counter = obj.counter;\n      this.rootKey = obj.rootKey;\n\n      for (const step of obj.steps) {\n        this.currentStep = await DHRatchetStep.fromJSON(step);\n        this.steps.push(this.currentStep);\n      }\n    }\n\n    update() {\n      this.emit("update");\n    }\n\n    generateRatchetKey() {\n      return Curve.generateKeyPair("ECDH");\n    }\n\n    async createChain(ourRatchetKey, theirRatchetKey, ratchetClass) {\n      const derivedBytes = await Curve.deriveBytes(ourRatchetKey, theirRatchetKey);\n      const keys = await Secret.HKDF(derivedBytes, 2, this.rootKey, INFO_RATCHET);\n      const rootKey = await Secret.importHMAC(keys[0]);\n      const chainKey = await Secret.importHMAC(keys[1]);\n      const chain = new ratchetClass(chainKey);\n      this.rootKey = rootKey;\n      return chain;\n    }\n\n    queuePromise(key, fn) {\n      const prev = this.promises[key] || Promise.resolve();\n      const cur = this.promises[key] = prev.then(fn, fn);\n      cur.then(() => {\n        if (this.promises[key] === cur) {\n          delete this.promises[key];\n        }\n      });\n      return cur;\n    }\n\n  }\n\n  class DHRatchetStep {\n    static async fromJSON(obj) {\n      const res = new this();\n      await res.fromJSON(obj);\n      return res;\n    }\n\n    async toJSON() {\n      const res = {};\n\n      if (this.remoteRatchetKey) {\n        res.remoteRatchetKey = this.remoteRatchetKey.key;\n      }\n\n      if (this.sendingChain) {\n        res.sendingChain = await this.sendingChain.toJSON();\n      }\n\n      if (this.receivingChain) {\n        res.receivingChain = await this.receivingChain.toJSON();\n      }\n\n      return res;\n    }\n\n    async fromJSON(obj) {\n      if (obj.remoteRatchetKey) {\n        this.remoteRatchetKey = await ECPublicKey.create(obj.remoteRatchetKey);\n      }\n\n      if (obj.sendingChain) {\n        this.sendingChain = await SendingRatchet.fromJSON(obj.sendingChain);\n      }\n\n      if (obj.receivingChain) {\n        this.receivingChain = await ReceivingRatchet.fromJSON(obj.receivingChain);\n      }\n    }\n\n  }\n\n  class DHRatchetStepStack extends Stack {\n    getStep(remoteRatchetKey) {\n      let found;\n      this.items.some(step => {\n        if (step.remoteRatchetKey.id === remoteRatchetKey.id) {\n          found = step;\n        }\n\n        return !!found;\n      });\n      return found;\n    }\n\n  }\n\n  class DateConverter$1 {\n    static async set(value) {\n      return new Uint8Array(Convert.FromUtf8String(value.toISOString()));\n    }\n\n    static async get(value) {\n      return new Date(Convert.ToUtf8String(value));\n    }\n\n  }\n\n  class HexStringConverter {\n    static async set(value) {\n      return new Uint8Array(Convert.FromHex(value));\n    }\n\n    static async get(value) {\n      return Convert.ToHex(value);\n    }\n\n  }\n\n  var BaseProto_1, ActionProto_1, BaseAlgorithmProto_1, AlgorithmProto_1, CryptoItemProto_1, CryptoKeyProto_1, CryptoKeyPairProto_1, ErrorProto_1, ResultProto_1;\n  let BaseProto = BaseProto_1 = class BaseProto extends ObjectProto {};\n  BaseProto.INDEX = 1;\n\n  __decorate([ProtobufProperty({\n    id: BaseProto_1.INDEX++,\n    type: "uint32",\n    required: true,\n    defaultValue: 1\n  })], BaseProto.prototype, "version", void 0);\n\n  BaseProto = BaseProto_1 = __decorate([ProtobufElement({\n    name: "BaseMessage"\n  })], BaseProto);\n  let ActionProto = ActionProto_1 = class ActionProto extends BaseProto {\n    constructor() {\n      super();\n      this.action = this.constructor.ACTION;\n    }\n\n  };\n  ActionProto.INDEX = BaseProto.INDEX;\n  ActionProto.ACTION = "action";\n\n  __decorate([ProtobufProperty({\n    id: ActionProto_1.INDEX++,\n    type: "string",\n    required: true\n  })], ActionProto.prototype, "action", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ActionProto_1.INDEX++,\n    type: "string",\n    required: false\n  })], ActionProto.prototype, "actionId", void 0);\n\n  ActionProto = ActionProto_1 = __decorate([ProtobufElement({\n    name: "Action"\n  })], ActionProto);\n  let BaseAlgorithmProto = BaseAlgorithmProto_1 = class BaseAlgorithmProto extends BaseProto {\n    toAlgorithm() {\n      return {\n        name: this.name\n      };\n    }\n\n    fromAlgorithm(alg) {\n      this.name = alg.name;\n    }\n\n  };\n  BaseAlgorithmProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: BaseAlgorithmProto_1.INDEX++,\n    type: "string",\n    required: true\n  })], BaseAlgorithmProto.prototype, "name", void 0);\n\n  BaseAlgorithmProto = BaseAlgorithmProto_1 = __decorate([ProtobufElement({\n    name: "BaseAlgorithm"\n  })], BaseAlgorithmProto);\n  let AlgorithmProto = AlgorithmProto_1 = class AlgorithmProto extends BaseAlgorithmProto {\n    toAlgorithm() {\n      const res = {};\n      const thisStatic = this.constructor;\n\n      for (const key in thisStatic.items) {\n        if (key === "version") {\n          continue;\n        }\n\n        const value = this[key];\n\n        if (value !== void 0) {\n          if (value instanceof BaseAlgorithmProto) {\n            if (!value.isEmpty()) {\n              res[key] = value.toAlgorithm();\n            }\n          } else {\n            res[key] = value;\n          }\n        }\n      }\n\n      return res;\n    }\n\n    fromAlgorithm(alg) {\n      if (alg instanceof AlgorithmProto_1) {\n        alg = alg.toAlgorithm();\n      }\n\n      const thisStatic = this.constructor;\n\n      for (const key in alg) {\n        if (!thisStatic.items) {\n          continue;\n        }\n\n        if (key in thisStatic.items) {\n          const item = thisStatic.items[key];\n\n          if (item.parser) {\n            switch (item.parser) {\n              case BaseAlgorithmProto:\n                {\n                  this[key].fromAlgorithm(alg[key]);\n                  break;\n                }\n\n              default:\n                throw new Error(`Unsupported parser \'${item.parser.name}\'`);\n            }\n          } else {\n            this[key] = alg[key];\n          }\n        }\n      }\n    }\n\n  };\n  AlgorithmProto.INDEX = BaseAlgorithmProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++,\n    type: "bytes",\n    parser: BaseAlgorithmProto\n  })], AlgorithmProto.prototype, "hash", void 0);\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++,\n    type: "bytes"\n  })], AlgorithmProto.prototype, "publicExponent", void 0);\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++,\n    type: "uint32"\n  })], AlgorithmProto.prototype, "modulusLength", void 0);\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++,\n    type: "uint32"\n  })], AlgorithmProto.prototype, "saltLength", void 0);\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++,\n    type: "bytes"\n  })], AlgorithmProto.prototype, "label", void 0);\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++,\n    type: "string"\n  })], AlgorithmProto.prototype, "namedCurve", void 0);\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++,\n    converter: ArrayBufferConverter\n  })], AlgorithmProto.prototype, "public", void 0);\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++,\n    type: "uint32"\n  })], AlgorithmProto.prototype, "length", void 0);\n\n  __decorate([ProtobufProperty({\n    id: AlgorithmProto_1.INDEX++\n  })], AlgorithmProto.prototype, "iv", void 0);\n\n  AlgorithmProto = AlgorithmProto_1 = __decorate([ProtobufElement({\n    name: "Algorithm"\n  })], AlgorithmProto);\n  let CryptoItemProto = CryptoItemProto_1 = class CryptoItemProto extends BaseProto {};\n  CryptoItemProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: CryptoItemProto_1.INDEX++,\n    type: "string",\n    required: true\n  })], CryptoItemProto.prototype, "providerID", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoItemProto_1.INDEX++,\n    type: "bytes",\n    required: true,\n    converter: HexStringConverter\n  })], CryptoItemProto.prototype, "id", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoItemProto_1.INDEX++,\n    type: "string",\n    required: true\n  })], CryptoItemProto.prototype, "type", void 0);\n\n  CryptoItemProto = CryptoItemProto_1 = __decorate([ProtobufElement({\n    name: "CryptoItem"\n  })], CryptoItemProto);\n  let CryptoKeyProto = CryptoKeyProto_1 = class CryptoKeyProto extends CryptoItemProto {};\n  CryptoKeyProto.INDEX = CryptoItemProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: CryptoKeyProto_1.INDEX++,\n    type: "bytes",\n    required: true,\n    parser: AlgorithmProto\n  })], CryptoKeyProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoKeyProto_1.INDEX++,\n    type: "bool"\n  })], CryptoKeyProto.prototype, "extractable", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoKeyProto_1.INDEX++,\n    type: "string",\n    repeated: true\n  })], CryptoKeyProto.prototype, "usages", void 0);\n\n  CryptoKeyProto = CryptoKeyProto_1 = __decorate([ProtobufElement({\n    name: "CryptoKey"\n  })], CryptoKeyProto);\n  let CryptoKeyPairProto = CryptoKeyPairProto_1 = class CryptoKeyPairProto extends BaseProto {};\n  CryptoKeyPairProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: CryptoKeyPairProto_1.INDEX++,\n    name: "privateKey",\n    type: "bytes",\n    parser: CryptoKeyProto\n  })], CryptoKeyPairProto.prototype, "privateKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoKeyPairProto_1.INDEX++,\n    name: "publicKey",\n    type: "bytes",\n    parser: CryptoKeyProto\n  })], CryptoKeyPairProto.prototype, "publicKey", void 0);\n\n  CryptoKeyPairProto = CryptoKeyPairProto_1 = __decorate([ProtobufElement({\n    name: "CryptoKeyPair"\n  })], CryptoKeyPairProto);\n  let ErrorProto = ErrorProto_1 = class ErrorProto extends BaseProto {\n    constructor(message, code = 0, type = "error") {\n      super();\n\n      if (message) {\n        this.message = message;\n        this.code = code;\n        this.type = type;\n      }\n    }\n\n  };\n  ErrorProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: ErrorProto_1.INDEX++,\n    type: "uint32",\n    defaultValue: 0\n  })], ErrorProto.prototype, "code", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ErrorProto_1.INDEX++,\n    type: "string",\n    defaultValue: "error"\n  })], ErrorProto.prototype, "type", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ErrorProto_1.INDEX++,\n    type: "string",\n    defaultValue: ""\n  })], ErrorProto.prototype, "message", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ErrorProto_1.INDEX++,\n    type: "string",\n    defaultValue: "Error"\n  })], ErrorProto.prototype, "name", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ErrorProto_1.INDEX++,\n    type: "string",\n    defaultValue: ""\n  })], ErrorProto.prototype, "stack", void 0);\n\n  ErrorProto = ErrorProto_1 = __decorate([ProtobufElement({\n    name: "Error"\n  })], ErrorProto);\n  let ResultProto = ResultProto_1 = class ResultProto extends ActionProto {\n    constructor(proto) {\n      super();\n\n      if (proto) {\n        this.actionId = proto.actionId;\n        this.action = proto.action;\n      }\n    }\n\n  };\n  ResultProto.INDEX = ActionProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: ResultProto_1.INDEX++,\n    type: "bool",\n    defaultValue: false\n  })], ResultProto.prototype, "status", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ResultProto_1.INDEX++,\n    type: "bytes",\n    parser: ErrorProto\n  })], ResultProto.prototype, "error", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ResultProto_1.INDEX++,\n    type: "bytes",\n    converter: ArrayBufferConverter\n  })], ResultProto.prototype, "data", void 0);\n\n  ResultProto = ResultProto_1 = __decorate([ProtobufElement({\n    name: "Result"\n  })], ResultProto);\n  let AuthRequestProto = class AuthRequestProto extends ActionProto {};\n  AuthRequestProto.INDEX = ActionProto.INDEX;\n  AuthRequestProto.ACTION = "auth";\n  AuthRequestProto = __decorate([ProtobufElement({\n    name: "AuthRequest"\n  })], AuthRequestProto);\n  let ServerLoginActionProto = class ServerLoginActionProto extends ActionProto {};\n  ServerLoginActionProto.INDEX = ActionProto.INDEX;\n  ServerLoginActionProto.ACTION = "server/login";\n  ServerLoginActionProto = __decorate([ProtobufElement({})], ServerLoginActionProto);\n  let ServerIsLoggedInActionProto = class ServerIsLoggedInActionProto extends ActionProto {};\n  ServerIsLoggedInActionProto.INDEX = ActionProto.INDEX;\n  ServerIsLoggedInActionProto.ACTION = "server/isLoggedIn";\n  ServerIsLoggedInActionProto = __decorate([ProtobufElement({})], ServerIsLoggedInActionProto);\n  var CardReaderEventProto_1;\n  let CardReaderActionProto = class CardReaderActionProto extends ActionProto {};\n  CardReaderActionProto.INDEX = ActionProto.INDEX;\n  CardReaderActionProto.ACTION = "cardReader";\n  CardReaderActionProto = __decorate([ProtobufElement({})], CardReaderActionProto);\n  let CardReaderGetReadersActionProto = class CardReaderGetReadersActionProto extends ActionProto {};\n  CardReaderGetReadersActionProto.INDEX = ActionProto.INDEX;\n  CardReaderGetReadersActionProto.ACTION = "cardReader/readers";\n  CardReaderGetReadersActionProto = __decorate([ProtobufElement({})], CardReaderGetReadersActionProto);\n  let CardReaderEventProto = CardReaderEventProto_1 = class CardReaderEventProto extends CardReaderActionProto {\n    constructor(reader, atr) {\n      super();\n\n      if (reader && atr) {\n        this.reader = reader;\n        this.atr = atr;\n      }\n    }\n\n  };\n  CardReaderEventProto.INDEX = CardReaderActionProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: CardReaderEventProto_1.INDEX++,\n    required: true,\n    type: "string",\n    defaultValue: ""\n  })], CardReaderEventProto.prototype, "reader", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CardReaderEventProto_1.INDEX++,\n    required: true,\n    converter: HexStringConverter\n  })], CardReaderEventProto.prototype, "atr", void 0);\n\n  CardReaderEventProto = CardReaderEventProto_1 = __decorate([ProtobufElement({})], CardReaderEventProto);\n  let CardReaderInsertEventProto = class CardReaderInsertEventProto extends CardReaderEventProto {};\n  CardReaderInsertEventProto.INDEX = CardReaderEventProto.INDEX;\n  CardReaderInsertEventProto.ACTION = CardReaderEventProto.ACTION + "/insert";\n  CardReaderInsertEventProto = __decorate([ProtobufElement({})], CardReaderInsertEventProto);\n  let CardReaderRemoveEventProto = class CardReaderRemoveEventProto extends CardReaderEventProto {};\n  CardReaderRemoveEventProto.INDEX = CardReaderEventProto.INDEX;\n  CardReaderRemoveEventProto.ACTION = CardReaderEventProto.ACTION + "/remove";\n  CardReaderRemoveEventProto = __decorate([ProtobufElement({})], CardReaderRemoveEventProto);\n  var CryptoActionProto_1;\n  let CryptoActionProto = CryptoActionProto_1 = class CryptoActionProto extends ActionProto {};\n  CryptoActionProto.INDEX = ActionProto.INDEX;\n  CryptoActionProto.ACTION = "crypto";\n\n  __decorate([ProtobufProperty({\n    id: CryptoActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CryptoActionProto.prototype, "providerID", void 0);\n\n  CryptoActionProto = CryptoActionProto_1 = __decorate([ProtobufElement({})], CryptoActionProto);\n  let LoginActionProto = class LoginActionProto extends CryptoActionProto {};\n  LoginActionProto.INDEX = CryptoActionProto.INDEX;\n  LoginActionProto.ACTION = "crypto/login";\n  LoginActionProto = __decorate([ProtobufElement({})], LoginActionProto);\n  let LogoutActionProto = class LogoutActionProto extends CryptoActionProto {};\n  LogoutActionProto.INDEX = CryptoActionProto.INDEX;\n  LogoutActionProto.ACTION = "crypto/logout";\n  LogoutActionProto = __decorate([ProtobufElement({})], LogoutActionProto);\n  let IsLoggedInActionProto = class IsLoggedInActionProto extends CryptoActionProto {};\n  IsLoggedInActionProto.INDEX = CryptoActionProto.INDEX;\n  IsLoggedInActionProto.ACTION = "crypto/isLoggedIn";\n  IsLoggedInActionProto = __decorate([ProtobufElement({})], IsLoggedInActionProto);\n  let ResetActionProto = class ResetActionProto extends CryptoActionProto {};\n  ResetActionProto.INDEX = CryptoActionProto.INDEX;\n  ResetActionProto.ACTION = "crypto/reset";\n  ResetActionProto = __decorate([ProtobufElement({})], ResetActionProto);\n  var CryptoCertificateProto_1, CryptoX509CertificateProto_1, CryptoX509CertificateRequestProto_1, ChainItemProto_1, CertificateStorageGetChainResultProto_1, CertificateStorageSetItemActionProto_1, CertificateStorageGetItemActionProto_1, CertificateStorageRemoveItemActionProto_1, CertificateStorageImportActionProto_1, CertificateStorageExportActionProto_1, CertificateStorageIndexOfActionProto_1, CertificateStorageGetCRLActionProto_1, OCSPRequestOptionsProto_1, CertificateStorageGetOCSPActionProto_1;\n  let CryptoCertificateProto = CryptoCertificateProto_1 = class CryptoCertificateProto extends CryptoItemProto {};\n  CryptoCertificateProto.INDEX = CryptoItemProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: CryptoCertificateProto_1.INDEX++,\n    required: true,\n    converter: HexStringConverter\n  })], CryptoCertificateProto.prototype, "id", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoCertificateProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], CryptoCertificateProto.prototype, "publicKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoCertificateProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CryptoCertificateProto.prototype, "type", void 0);\n\n  CryptoCertificateProto = CryptoCertificateProto_1 = __decorate([ProtobufElement({})], CryptoCertificateProto);\n  let CryptoX509CertificateProto = CryptoX509CertificateProto_1 = class CryptoX509CertificateProto extends CryptoCertificateProto {\n    constructor() {\n      super(...arguments);\n      this.type = "x509";\n    }\n\n  };\n  CryptoX509CertificateProto.INDEX = CryptoCertificateProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: CryptoX509CertificateProto_1.INDEX++,\n    required: true,\n    converter: HexStringConverter\n  })], CryptoX509CertificateProto.prototype, "serialNumber", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoX509CertificateProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CryptoX509CertificateProto.prototype, "issuerName", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoX509CertificateProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CryptoX509CertificateProto.prototype, "subjectName", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoX509CertificateProto_1.INDEX++,\n    required: true,\n    converter: DateConverter$1\n  })], CryptoX509CertificateProto.prototype, "notBefore", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CryptoX509CertificateProto_1.INDEX++,\n    required: true,\n    converter: DateConverter$1\n  })], CryptoX509CertificateProto.prototype, "notAfter", void 0);\n\n  CryptoX509CertificateProto = CryptoX509CertificateProto_1 = __decorate([ProtobufElement({})], CryptoX509CertificateProto);\n  let CryptoX509CertificateRequestProto = CryptoX509CertificateRequestProto_1 = class CryptoX509CertificateRequestProto extends CryptoCertificateProto {\n    constructor() {\n      super(...arguments);\n      this.type = "request";\n    }\n\n  };\n  CryptoX509CertificateRequestProto.INDEX = CryptoCertificateProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: CryptoX509CertificateRequestProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CryptoX509CertificateRequestProto.prototype, "subjectName", void 0);\n\n  CryptoX509CertificateRequestProto = CryptoX509CertificateRequestProto_1 = __decorate([ProtobufElement({})], CryptoX509CertificateRequestProto);\n  let ChainItemProto = ChainItemProto_1 = class ChainItemProto extends BaseProto {};\n  ChainItemProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: ChainItemProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], ChainItemProto.prototype, "type", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ChainItemProto_1.INDEX++,\n    required: true,\n    converter: ArrayBufferConverter\n  })], ChainItemProto.prototype, "value", void 0);\n\n  ChainItemProto = ChainItemProto_1 = __decorate([ProtobufElement({})], ChainItemProto);\n  let CertificateStorageGetChainResultProto = CertificateStorageGetChainResultProto_1 = class CertificateStorageGetChainResultProto extends BaseProto {\n    constructor() {\n      super(...arguments);\n      this.items = [];\n    }\n\n  };\n  CertificateStorageGetChainResultProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageGetChainResultProto_1.INDEX++,\n    required: true,\n    repeated: true,\n    parser: ChainItemProto\n  })], CertificateStorageGetChainResultProto.prototype, "items", void 0);\n\n  CertificateStorageGetChainResultProto = CertificateStorageGetChainResultProto_1 = __decorate([ProtobufElement({})], CertificateStorageGetChainResultProto);\n  let CertificateStorageSetItemActionProto = CertificateStorageSetItemActionProto_1 = class CertificateStorageSetItemActionProto extends CryptoActionProto {};\n  CertificateStorageSetItemActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageSetItemActionProto.ACTION = "crypto/certificateStorage/setItem";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageSetItemActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoCertificateProto\n  })], CertificateStorageSetItemActionProto.prototype, "item", void 0);\n\n  CertificateStorageSetItemActionProto = CertificateStorageSetItemActionProto_1 = __decorate([ProtobufElement({})], CertificateStorageSetItemActionProto);\n  let CertificateStorageGetItemActionProto = CertificateStorageGetItemActionProto_1 = class CertificateStorageGetItemActionProto extends CryptoActionProto {};\n  CertificateStorageGetItemActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageGetItemActionProto.ACTION = "crypto/certificateStorage/getItem";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageGetItemActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CertificateStorageGetItemActionProto.prototype, "key", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageGetItemActionProto_1.INDEX++,\n    parser: AlgorithmProto\n  })], CertificateStorageGetItemActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageGetItemActionProto_1.INDEX++,\n    repeated: true,\n    type: "string"\n  })], CertificateStorageGetItemActionProto.prototype, "keyUsages", void 0);\n\n  CertificateStorageGetItemActionProto = CertificateStorageGetItemActionProto_1 = __decorate([ProtobufElement({})], CertificateStorageGetItemActionProto);\n  let CertificateStorageKeysActionProto = class CertificateStorageKeysActionProto extends CryptoActionProto {};\n  CertificateStorageKeysActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageKeysActionProto.ACTION = "crypto/certificateStorage/keys";\n  CertificateStorageKeysActionProto = __decorate([ProtobufElement({})], CertificateStorageKeysActionProto);\n  let CertificateStorageRemoveItemActionProto = CertificateStorageRemoveItemActionProto_1 = class CertificateStorageRemoveItemActionProto extends CryptoActionProto {};\n  CertificateStorageRemoveItemActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageRemoveItemActionProto.ACTION = "crypto/certificateStorage/removeItem";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageRemoveItemActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CertificateStorageRemoveItemActionProto.prototype, "key", void 0);\n\n  CertificateStorageRemoveItemActionProto = CertificateStorageRemoveItemActionProto_1 = __decorate([ProtobufElement({})], CertificateStorageRemoveItemActionProto);\n  let CertificateStorageClearActionProto = class CertificateStorageClearActionProto extends CryptoActionProto {};\n  CertificateStorageClearActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageClearActionProto.ACTION = "crypto/certificateStorage/clear";\n  CertificateStorageClearActionProto = __decorate([ProtobufElement({})], CertificateStorageClearActionProto);\n  let CertificateStorageImportActionProto = CertificateStorageImportActionProto_1 = class CertificateStorageImportActionProto extends CryptoActionProto {};\n  CertificateStorageImportActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageImportActionProto.ACTION = "crypto/certificateStorage/import";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageImportActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CertificateStorageImportActionProto.prototype, "format", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageImportActionProto_1.INDEX++,\n    required: true,\n    converter: ArrayBufferConverter\n  })], CertificateStorageImportActionProto.prototype, "data", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageImportActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], CertificateStorageImportActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageImportActionProto_1.INDEX++,\n    repeated: true,\n    type: "string"\n  })], CertificateStorageImportActionProto.prototype, "keyUsages", void 0);\n\n  CertificateStorageImportActionProto = CertificateStorageImportActionProto_1 = __decorate([ProtobufElement({})], CertificateStorageImportActionProto);\n  let CertificateStorageExportActionProto = CertificateStorageExportActionProto_1 = class CertificateStorageExportActionProto extends CryptoActionProto {};\n  CertificateStorageExportActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageExportActionProto.ACTION = "crypto/certificateStorage/export";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageExportActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CertificateStorageExportActionProto.prototype, "format", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageExportActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoCertificateProto\n  })], CertificateStorageExportActionProto.prototype, "item", void 0);\n\n  CertificateStorageExportActionProto = CertificateStorageExportActionProto_1 = __decorate([ProtobufElement({})], CertificateStorageExportActionProto);\n  let CertificateStorageIndexOfActionProto = CertificateStorageIndexOfActionProto_1 = class CertificateStorageIndexOfActionProto extends CryptoActionProto {};\n  CertificateStorageIndexOfActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageIndexOfActionProto.ACTION = "crypto/certificateStorage/indexOf";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageIndexOfActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoCertificateProto\n  })], CertificateStorageIndexOfActionProto.prototype, "item", void 0);\n\n  CertificateStorageIndexOfActionProto = CertificateStorageIndexOfActionProto_1 = __decorate([ProtobufElement({})], CertificateStorageIndexOfActionProto);\n  let CertificateStorageGetChainActionProto = class CertificateStorageGetChainActionProto extends CryptoActionProto {};\n  CertificateStorageGetChainActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageGetChainActionProto.ACTION = "crypto/certificateStorage/getChain";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageSetItemActionProto.INDEX++,\n    required: true,\n    parser: CryptoCertificateProto\n  })], CertificateStorageGetChainActionProto.prototype, "item", void 0);\n\n  CertificateStorageGetChainActionProto = __decorate([ProtobufElement({})], CertificateStorageGetChainActionProto);\n  let CertificateStorageGetCRLActionProto = CertificateStorageGetCRLActionProto_1 = class CertificateStorageGetCRLActionProto extends CryptoActionProto {};\n  CertificateStorageGetCRLActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageGetCRLActionProto.ACTION = "crypto/certificateStorage/getCRL";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageGetCRLActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CertificateStorageGetCRLActionProto.prototype, "url", void 0);\n\n  CertificateStorageGetCRLActionProto = CertificateStorageGetCRLActionProto_1 = __decorate([ProtobufElement({})], CertificateStorageGetCRLActionProto);\n  let OCSPRequestOptionsProto = OCSPRequestOptionsProto_1 = class OCSPRequestOptionsProto extends BaseProto {};\n  OCSPRequestOptionsProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: OCSPRequestOptionsProto_1.INDEX++,\n    required: false,\n    type: "string",\n    defaultValue: "get"\n  })], OCSPRequestOptionsProto.prototype, "method", void 0);\n\n  OCSPRequestOptionsProto = OCSPRequestOptionsProto_1 = __decorate([ProtobufElement({})], OCSPRequestOptionsProto);\n  let CertificateStorageGetOCSPActionProto = CertificateStorageGetOCSPActionProto_1 = class CertificateStorageGetOCSPActionProto extends CryptoActionProto {};\n  CertificateStorageGetOCSPActionProto.INDEX = CryptoActionProto.INDEX;\n  CertificateStorageGetOCSPActionProto.ACTION = "crypto/certificateStorage/getOCSP";\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageGetOCSPActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], CertificateStorageGetOCSPActionProto.prototype, "url", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageGetOCSPActionProto_1.INDEX++,\n    required: true,\n    converter: ArrayBufferConverter\n  })], CertificateStorageGetOCSPActionProto.prototype, "request", void 0);\n\n  __decorate([ProtobufProperty({\n    id: CertificateStorageGetOCSPActionProto_1.INDEX++,\n    required: false,\n    parser: OCSPRequestOptionsProto\n  })], CertificateStorageGetOCSPActionProto.prototype, "options", void 0);\n\n  CertificateStorageGetOCSPActionProto = CertificateStorageGetOCSPActionProto_1 = __decorate([ProtobufElement({})], CertificateStorageGetOCSPActionProto);\n  var KeyStorageSetItemActionProto_1, KeyStorageGetItemActionProto_1, KeyStorageRemoveItemActionProto_1, KeyStorageIndexOfActionProto_1;\n  let KeyStorageSetItemActionProto = KeyStorageSetItemActionProto_1 = class KeyStorageSetItemActionProto extends CryptoActionProto {};\n  KeyStorageSetItemActionProto.INDEX = CryptoActionProto.INDEX;\n  KeyStorageSetItemActionProto.ACTION = "crypto/keyStorage/setItem";\n\n  __decorate([ProtobufProperty({\n    id: KeyStorageSetItemActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], KeyStorageSetItemActionProto.prototype, "item", void 0);\n\n  KeyStorageSetItemActionProto = KeyStorageSetItemActionProto_1 = __decorate([ProtobufElement({})], KeyStorageSetItemActionProto);\n  let KeyStorageGetItemActionProto = KeyStorageGetItemActionProto_1 = class KeyStorageGetItemActionProto extends CryptoActionProto {};\n  KeyStorageGetItemActionProto.INDEX = CryptoActionProto.INDEX;\n  KeyStorageGetItemActionProto.ACTION = "crypto/keyStorage/getItem";\n\n  __decorate([ProtobufProperty({\n    id: KeyStorageGetItemActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], KeyStorageGetItemActionProto.prototype, "key", void 0);\n\n  __decorate([ProtobufProperty({\n    id: KeyStorageGetItemActionProto_1.INDEX++,\n    parser: AlgorithmProto\n  })], KeyStorageGetItemActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: KeyStorageGetItemActionProto_1.INDEX++,\n    type: "bool"\n  })], KeyStorageGetItemActionProto.prototype, "extractable", void 0);\n\n  __decorate([ProtobufProperty({\n    id: KeyStorageGetItemActionProto_1.INDEX++,\n    repeated: true,\n    type: "string"\n  })], KeyStorageGetItemActionProto.prototype, "keyUsages", void 0);\n\n  KeyStorageGetItemActionProto = KeyStorageGetItemActionProto_1 = __decorate([ProtobufElement({})], KeyStorageGetItemActionProto);\n  let KeyStorageKeysActionProto = class KeyStorageKeysActionProto extends CryptoActionProto {};\n  KeyStorageKeysActionProto.INDEX = CryptoActionProto.INDEX;\n  KeyStorageKeysActionProto.ACTION = "crypto/keyStorage/keys";\n  KeyStorageKeysActionProto = __decorate([ProtobufElement({})], KeyStorageKeysActionProto);\n  let KeyStorageRemoveItemActionProto = KeyStorageRemoveItemActionProto_1 = class KeyStorageRemoveItemActionProto extends CryptoActionProto {};\n  KeyStorageRemoveItemActionProto.INDEX = CryptoActionProto.INDEX;\n  KeyStorageRemoveItemActionProto.ACTION = "crypto/keyStorage/removeItem";\n\n  __decorate([ProtobufProperty({\n    id: KeyStorageRemoveItemActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], KeyStorageRemoveItemActionProto.prototype, "key", void 0);\n\n  KeyStorageRemoveItemActionProto = KeyStorageRemoveItemActionProto_1 = __decorate([ProtobufElement({})], KeyStorageRemoveItemActionProto);\n  let KeyStorageClearActionProto = class KeyStorageClearActionProto extends CryptoActionProto {};\n  KeyStorageClearActionProto.INDEX = CryptoActionProto.INDEX;\n  KeyStorageClearActionProto.ACTION = "crypto/keyStorage/clear";\n  KeyStorageClearActionProto = __decorate([ProtobufElement({})], KeyStorageClearActionProto);\n  let KeyStorageIndexOfActionProto = KeyStorageIndexOfActionProto_1 = class KeyStorageIndexOfActionProto extends CryptoActionProto {};\n  KeyStorageIndexOfActionProto.INDEX = CryptoActionProto.INDEX;\n  KeyStorageIndexOfActionProto.ACTION = "crypto/keyStorage/indexOf";\n\n  __decorate([ProtobufProperty({\n    id: KeyStorageIndexOfActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], KeyStorageIndexOfActionProto.prototype, "item", void 0);\n\n  KeyStorageIndexOfActionProto = KeyStorageIndexOfActionProto_1 = __decorate([ProtobufElement({})], KeyStorageIndexOfActionProto);\n  var ProviderCryptoProto_1, ProviderInfoProto_1, ProviderGetCryptoActionProto_1, ProviderTokenEventProto_1;\n  let ProviderCryptoProto = ProviderCryptoProto_1 = class ProviderCryptoProto extends BaseProto {\n    constructor(data) {\n      super();\n\n      if (data) {\n        assign(this, data);\n      }\n    }\n\n  };\n  ProviderCryptoProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: ProviderCryptoProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], ProviderCryptoProto.prototype, "id", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderCryptoProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], ProviderCryptoProto.prototype, "name", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderCryptoProto_1.INDEX++,\n    type: "bool",\n    defaultValue: false\n  })], ProviderCryptoProto.prototype, "readOnly", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderCryptoProto_1.INDEX++,\n    repeated: true,\n    type: "string"\n  })], ProviderCryptoProto.prototype, "algorithms", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderCryptoProto_1.INDEX++,\n    type: "bool",\n    defaultValue: false\n  })], ProviderCryptoProto.prototype, "isRemovable", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderCryptoProto_1.INDEX++,\n    type: "string"\n  })], ProviderCryptoProto.prototype, "atr", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderCryptoProto_1.INDEX++,\n    type: "bool",\n    defaultValue: false\n  })], ProviderCryptoProto.prototype, "isHardware", void 0);\n\n  ProviderCryptoProto = ProviderCryptoProto_1 = __decorate([ProtobufElement({})], ProviderCryptoProto);\n  let ProviderInfoProto = ProviderInfoProto_1 = class ProviderInfoProto extends BaseProto {};\n  ProviderInfoProto.INDEX = BaseProto.INDEX;\n\n  __decorate([ProtobufProperty({\n    id: ProviderInfoProto_1.INDEX++,\n    type: "string",\n    required: true\n  })], ProviderInfoProto.prototype, "name", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderInfoProto_1.INDEX++,\n    repeated: true,\n    parser: ProviderCryptoProto\n  })], ProviderInfoProto.prototype, "providers", void 0);\n\n  ProviderInfoProto = ProviderInfoProto_1 = __decorate([ProtobufElement({})], ProviderInfoProto);\n  let ProviderInfoActionProto = class ProviderInfoActionProto extends ActionProto {};\n  ProviderInfoActionProto.INDEX = ActionProto.INDEX;\n  ProviderInfoActionProto.ACTION = "provider/action/info";\n  ProviderInfoActionProto = __decorate([ProtobufElement({})], ProviderInfoActionProto);\n  let ProviderGetCryptoActionProto = ProviderGetCryptoActionProto_1 = class ProviderGetCryptoActionProto extends ActionProto {};\n  ProviderGetCryptoActionProto.INDEX = ActionProto.INDEX;\n  ProviderGetCryptoActionProto.ACTION = "provider/action/getCrypto";\n\n  __decorate([ProtobufProperty({\n    id: ProviderGetCryptoActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], ProviderGetCryptoActionProto.prototype, "cryptoID", void 0);\n\n  ProviderGetCryptoActionProto = ProviderGetCryptoActionProto_1 = __decorate([ProtobufElement({})], ProviderGetCryptoActionProto);\n  let ProviderAuthorizedEventProto = class ProviderAuthorizedEventProto extends ActionProto {};\n  ProviderAuthorizedEventProto.INDEX = ActionProto.INDEX;\n  ProviderAuthorizedEventProto.ACTION = "provider/event/authorized";\n  ProviderAuthorizedEventProto = __decorate([ProtobufElement({})], ProviderAuthorizedEventProto);\n  let ProviderTokenEventProto = ProviderTokenEventProto_1 = class ProviderTokenEventProto extends ActionProto {\n    constructor(data) {\n      super();\n\n      if (data) {\n        assign(this, data);\n      }\n    }\n\n  };\n  ProviderTokenEventProto.INDEX = ActionProto.INDEX;\n  ProviderTokenEventProto.ACTION = "provider/event/token";\n\n  __decorate([ProtobufProperty({\n    id: ProviderTokenEventProto_1.INDEX++,\n    repeated: true,\n    parser: ProviderCryptoProto\n  })], ProviderTokenEventProto.prototype, "added", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderTokenEventProto_1.INDEX++,\n    repeated: true,\n    parser: ProviderCryptoProto\n  })], ProviderTokenEventProto.prototype, "removed", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ProviderTokenEventProto_1.INDEX++,\n    type: "bytes",\n    parser: ErrorProto\n  })], ProviderTokenEventProto.prototype, "error", void 0);\n\n  ProviderTokenEventProto = ProviderTokenEventProto_1 = __decorate([ProtobufElement({\n    name: "ProviderTokenEvent"\n  })], ProviderTokenEventProto);\n  var DigestActionProto_1, GenerateKeyActionProto_1, SignActionProto_1, VerifyActionProto_1, DeriveBitsActionProto_1, DeriveKeyActionProto_1, UnwrapKeyActionProto_1, WrapKeyActionProto_1, ExportKeyActionProto_1, ImportKeyActionProto_1;\n  let DigestActionProto = DigestActionProto_1 = class DigestActionProto extends CryptoActionProto {};\n  DigestActionProto.INDEX = CryptoActionProto.INDEX;\n  DigestActionProto.ACTION = "crypto/subtle/digest";\n\n  __decorate([ProtobufProperty({\n    id: DigestActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], DigestActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: DigestActionProto_1.INDEX++,\n    required: true,\n    converter: ArrayBufferConverter\n  })], DigestActionProto.prototype, "data", void 0);\n\n  DigestActionProto = DigestActionProto_1 = __decorate([ProtobufElement({})], DigestActionProto);\n  let GenerateKeyActionProto = GenerateKeyActionProto_1 = class GenerateKeyActionProto extends CryptoActionProto {};\n  GenerateKeyActionProto.INDEX = CryptoActionProto.INDEX;\n  GenerateKeyActionProto.ACTION = "crypto/subtle/generateKey";\n\n  __decorate([ProtobufProperty({\n    id: GenerateKeyActionProto_1.INDEX++,\n    type: "bytes",\n    required: true,\n    parser: AlgorithmProto\n  })], GenerateKeyActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: GenerateKeyActionProto_1.INDEX++,\n    type: "bool",\n    required: true\n  })], GenerateKeyActionProto.prototype, "extractable", void 0);\n\n  __decorate([ProtobufProperty({\n    id: GenerateKeyActionProto_1.INDEX++,\n    type: "string",\n    repeated: true\n  })], GenerateKeyActionProto.prototype, "usage", void 0);\n\n  GenerateKeyActionProto = GenerateKeyActionProto_1 = __decorate([ProtobufElement({})], GenerateKeyActionProto);\n  let SignActionProto = SignActionProto_1 = class SignActionProto extends CryptoActionProto {};\n  SignActionProto.INDEX = CryptoActionProto.INDEX;\n  SignActionProto.ACTION = "crypto/subtle/sign";\n\n  __decorate([ProtobufProperty({\n    id: SignActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], SignActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: SignActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], SignActionProto.prototype, "key", void 0);\n\n  __decorate([ProtobufProperty({\n    id: SignActionProto_1.INDEX++,\n    required: true,\n    converter: ArrayBufferConverter\n  })], SignActionProto.prototype, "data", void 0);\n\n  SignActionProto = SignActionProto_1 = __decorate([ProtobufElement({})], SignActionProto);\n  let VerifyActionProto = VerifyActionProto_1 = class VerifyActionProto extends SignActionProto {};\n  VerifyActionProto.INDEX = SignActionProto.INDEX;\n  VerifyActionProto.ACTION = "crypto/subtle/verify";\n\n  __decorate([ProtobufProperty({\n    id: VerifyActionProto_1.INDEX++,\n    required: true,\n    converter: ArrayBufferConverter\n  })], VerifyActionProto.prototype, "signature", void 0);\n\n  VerifyActionProto = VerifyActionProto_1 = __decorate([ProtobufElement({})], VerifyActionProto);\n  let EncryptActionProto = class EncryptActionProto extends SignActionProto {};\n  EncryptActionProto.INDEX = SignActionProto.INDEX;\n  EncryptActionProto.ACTION = "crypto/subtle/encrypt";\n  EncryptActionProto = __decorate([ProtobufElement({})], EncryptActionProto);\n  let DecryptActionProto = class DecryptActionProto extends SignActionProto {};\n  DecryptActionProto.INDEX = SignActionProto.INDEX;\n  DecryptActionProto.ACTION = "crypto/subtle/decrypt";\n  DecryptActionProto = __decorate([ProtobufElement({})], DecryptActionProto);\n  let DeriveBitsActionProto = DeriveBitsActionProto_1 = class DeriveBitsActionProto extends CryptoActionProto {};\n  DeriveBitsActionProto.INDEX = CryptoActionProto.INDEX;\n  DeriveBitsActionProto.ACTION = "crypto/subtle/deriveBits";\n\n  __decorate([ProtobufProperty({\n    id: DeriveBitsActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], DeriveBitsActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: DeriveBitsActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], DeriveBitsActionProto.prototype, "key", void 0);\n\n  __decorate([ProtobufProperty({\n    id: DeriveBitsActionProto_1.INDEX++,\n    required: true,\n    type: "uint32"\n  })], DeriveBitsActionProto.prototype, "length", void 0);\n\n  DeriveBitsActionProto = DeriveBitsActionProto_1 = __decorate([ProtobufElement({})], DeriveBitsActionProto);\n  let DeriveKeyActionProto = DeriveKeyActionProto_1 = class DeriveKeyActionProto extends CryptoActionProto {};\n  DeriveKeyActionProto.INDEX = CryptoActionProto.INDEX;\n  DeriveKeyActionProto.ACTION = "crypto/subtle/deriveKey";\n\n  __decorate([ProtobufProperty({\n    id: DeriveKeyActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], DeriveKeyActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: DeriveKeyActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], DeriveKeyActionProto.prototype, "key", void 0);\n\n  __decorate([ProtobufProperty({\n    id: DeriveKeyActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], DeriveKeyActionProto.prototype, "derivedKeyType", void 0);\n\n  __decorate([ProtobufProperty({\n    id: DeriveKeyActionProto_1.INDEX++,\n    type: "bool"\n  })], DeriveKeyActionProto.prototype, "extractable", void 0);\n\n  __decorate([ProtobufProperty({\n    id: DeriveKeyActionProto_1.INDEX++,\n    type: "string",\n    repeated: true\n  })], DeriveKeyActionProto.prototype, "usage", void 0);\n\n  DeriveKeyActionProto = DeriveKeyActionProto_1 = __decorate([ProtobufElement({})], DeriveKeyActionProto);\n  let UnwrapKeyActionProto = UnwrapKeyActionProto_1 = class UnwrapKeyActionProto extends CryptoActionProto {};\n  UnwrapKeyActionProto.INDEX = CryptoActionProto.INDEX;\n  UnwrapKeyActionProto.ACTION = "crypto/subtle/unwrapKey";\n\n  __decorate([ProtobufProperty({\n    id: UnwrapKeyActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], UnwrapKeyActionProto.prototype, "format", void 0);\n\n  __decorate([ProtobufProperty({\n    id: UnwrapKeyActionProto_1.INDEX++,\n    required: true,\n    converter: ArrayBufferConverter\n  })], UnwrapKeyActionProto.prototype, "wrappedKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: UnwrapKeyActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], UnwrapKeyActionProto.prototype, "unwrappingKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: UnwrapKeyActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], UnwrapKeyActionProto.prototype, "unwrapAlgorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: UnwrapKeyActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], UnwrapKeyActionProto.prototype, "unwrappedKeyAlgorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: UnwrapKeyActionProto_1.INDEX++,\n    type: "bool"\n  })], UnwrapKeyActionProto.prototype, "extractable", void 0);\n\n  __decorate([ProtobufProperty({\n    id: UnwrapKeyActionProto_1.INDEX++,\n    type: "string",\n    repeated: true\n  })], UnwrapKeyActionProto.prototype, "keyUsage", void 0);\n\n  UnwrapKeyActionProto = UnwrapKeyActionProto_1 = __decorate([ProtobufElement({})], UnwrapKeyActionProto);\n  let WrapKeyActionProto = WrapKeyActionProto_1 = class WrapKeyActionProto extends CryptoActionProto {};\n  WrapKeyActionProto.INDEX = CryptoActionProto.INDEX;\n  WrapKeyActionProto.ACTION = "crypto/subtle/wrapKey";\n\n  __decorate([ProtobufProperty({\n    id: WrapKeyActionProto_1.INDEX++,\n    required: true,\n    type: "string"\n  })], WrapKeyActionProto.prototype, "format", void 0);\n\n  __decorate([ProtobufProperty({\n    id: WrapKeyActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], WrapKeyActionProto.prototype, "key", void 0);\n\n  __decorate([ProtobufProperty({\n    id: WrapKeyActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], WrapKeyActionProto.prototype, "wrappingKey", void 0);\n\n  __decorate([ProtobufProperty({\n    id: WrapKeyActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], WrapKeyActionProto.prototype, "wrapAlgorithm", void 0);\n\n  WrapKeyActionProto = WrapKeyActionProto_1 = __decorate([ProtobufElement({})], WrapKeyActionProto);\n  let ExportKeyActionProto = ExportKeyActionProto_1 = class ExportKeyActionProto extends CryptoActionProto {};\n  ExportKeyActionProto.INDEX = CryptoActionProto.INDEX;\n  ExportKeyActionProto.ACTION = "crypto/subtle/exportKey";\n\n  __decorate([ProtobufProperty({\n    id: ExportKeyActionProto_1.INDEX++,\n    type: "string",\n    required: true\n  })], ExportKeyActionProto.prototype, "format", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ExportKeyActionProto_1.INDEX++,\n    required: true,\n    parser: CryptoKeyProto\n  })], ExportKeyActionProto.prototype, "key", void 0);\n\n  ExportKeyActionProto = ExportKeyActionProto_1 = __decorate([ProtobufElement({})], ExportKeyActionProto);\n  let ImportKeyActionProto = ImportKeyActionProto_1 = class ImportKeyActionProto extends CryptoActionProto {};\n  ImportKeyActionProto.INDEX = CryptoActionProto.INDEX;\n  ImportKeyActionProto.ACTION = "crypto/subtle/importKey";\n\n  __decorate([ProtobufProperty({\n    id: ImportKeyActionProto_1.INDEX++,\n    type: "string",\n    required: true\n  })], ImportKeyActionProto.prototype, "format", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ImportKeyActionProto_1.INDEX++,\n    required: true,\n    converter: ArrayBufferConverter\n  })], ImportKeyActionProto.prototype, "keyData", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ImportKeyActionProto_1.INDEX++,\n    required: true,\n    parser: AlgorithmProto\n  })], ImportKeyActionProto.prototype, "algorithm", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ImportKeyActionProto_1.INDEX++,\n    required: true,\n    type: "bool"\n  })], ImportKeyActionProto.prototype, "extractable", void 0);\n\n  __decorate([ProtobufProperty({\n    id: ImportKeyActionProto_1.INDEX++,\n    type: "string",\n    repeated: true\n  })], ImportKeyActionProto.prototype, "keyUsages", void 0);\n\n  ImportKeyActionProto = ImportKeyActionProto_1 = __decorate([ProtobufElement({})], ImportKeyActionProto);\n\n  class CardReader extends EventEmitter {\n    constructor(client) {\n      super();\n      this.client = client;\n      this.onEvent = this.onEvent.bind(this);\n      this.client.on("listening", () => {\n        this.client.on("event", this.onEvent);\n      }).on("close", () => {\n        this.client.removeListener("event", this.onEvent);\n      });\n    }\n\n    async readers() {\n      const data = await this.client.send(new CardReaderGetReadersActionProto());\n      return JSON.parse(Convert.ToString(data));\n    }\n\n    on(event, cb) {\n      return super.on(event, cb);\n    }\n\n    emit(event, ...args) {\n      return super.emit(event, ...args);\n    }\n\n    onEvent(actionProto) {\n      (async () => {\n        switch (actionProto.action) {\n          case CardReaderInsertEventProto.ACTION:\n            this.onInsert((await CardReaderInsertEventProto.importProto(actionProto)));\n            break;\n\n          case CardReaderRemoveEventProto.ACTION:\n            this.onRemove((await CardReaderRemoveEventProto.importProto(actionProto)));\n            break;\n        }\n      })().catch(err => this.emit("error", err));\n    }\n\n    onInsert(actionProto) {\n      this.emit("insert", actionProto);\n    }\n\n    onRemove(actionProto) {\n      this.emit("remove", actionProto);\n    }\n\n  }\n\n  async function challenge(serverIdentity, clientIdentity) {\n    const serverIdentityDigest = await serverIdentity.thumbprint();\n    const clientIdentityDigest = await clientIdentity.thumbprint();\n    const combinedIdentity = Convert.FromHex(serverIdentityDigest + clientIdentityDigest);\n    const digest = await getEngine().crypto.subtle.digest("SHA-256", combinedIdentity);\n    return parseInt(Convert.ToHex(digest), 16).toString().substr(2, 6);\n  }\n\n  const SERVER_WELL_KNOWN = "/.well-known/webcrypto-socket";\n\n  class Event {\n    constructor(target, event) {\n      this.target = target;\n      this.event = event;\n    }\n\n  }\n\n  class CryptoServerError extends Error {\n    constructor(error) {\n      super(error.message);\n      this.name = "CryptoServerError";\n      this.code = error.code;\n      this.type = error.type;\n    }\n\n  }\n\n  class ClientEvent extends Event {}\n\n  class ClientCloseEvent extends ClientEvent {\n    constructor(target, remoteAddress, reasonCode, description) {\n      super(target, "close");\n      this.remoteAddress = remoteAddress;\n      this.reasonCode = reasonCode;\n      this.description = description;\n    }\n\n  }\n\n  class ClientErrorEvent extends ClientEvent {\n    constructor(target, error) {\n      super(target, "error");\n      this.error = error;\n    }\n\n  }\n\n  class ClientListeningEvent extends ClientEvent {\n    constructor(target, address) {\n      super(target, "listening");\n      this.address = address;\n    }\n\n  }\n\n  var SocketCryptoState;\n\n  (function (SocketCryptoState) {\n    SocketCryptoState[SocketCryptoState["connecting"] = 0] = "connecting";\n    SocketCryptoState[SocketCryptoState["open"] = 1] = "open";\n    SocketCryptoState[SocketCryptoState["closing"] = 2] = "closing";\n    SocketCryptoState[SocketCryptoState["closed"] = 3] = "closed";\n  })(SocketCryptoState || (SocketCryptoState = {}));\n\n  class Client extends EventEmitter {\n    constructor(storage) {\n      super();\n      this.stack = {};\n      this.messageCounter = 0;\n      this.storage = storage;\n    }\n\n    get state() {\n      if (this.socket) {\n        return this.socket.readyState;\n      } else {\n        return SocketCryptoState.closed;\n      }\n    }\n\n    connect(address, options) {\n      this.getServerInfo(address).then(info => {\n        this.serviceInfo = info;\n        const url = `wss://${address}`;\n        this.socket = options ? new WebSocket(url, undefined, options) : new WebSocket(url);\n        this.socket.binaryType = "arraybuffer";\n\n        this.socket.onerror = e => {\n          this.emit("error", new ClientErrorEvent(this, e.error));\n        };\n\n        this.socket.onopen = () => {\n          (async () => {\n            let identity = await this.storage.loadIdentity();\n\n            if (!identity) {\n              identity = await Identity.create(1);\n              await this.storage.saveIdentity(identity);\n            }\n\n            const remoteIdentityId = "0";\n            const bundle = await PreKeyBundleProtocol.importProto(Convert.FromBase64(info.preKey));\n            this.cipher = await AsymmetricRatchet.create(identity, bundle);\n            await this.storage.saveRemoteIdentity(remoteIdentityId, this.cipher.remoteIdentity);\n            this.emit("listening", new ClientListeningEvent(this, address));\n          })().catch(error => this.emit("error", new ClientErrorEvent(this, error)));\n        };\n\n        this.socket.onclose = e => {\n          for (const actionId in this.stack) {\n            const message = this.stack[actionId];\n            message.reject(new Error("Cannot finish operation. Session was closed"));\n          }\n\n          this.emit("close", new ClientCloseEvent(this, address, e.code, e.reason));\n        };\n\n        this.socket.onmessage = e => {\n          if (e.data instanceof ArrayBuffer) {\n            MessageSignedProtocol.importProto(e.data).then(proto2 => {\n              if (!this.cipher) {\n                throw new Error("Client cipher is not initialized");\n              }\n\n              return this.cipher.decrypt(proto2);\n            }).then(msg => {\n              this.onMessage(msg);\n            }).catch(err => {\n              this.emit("error", new ClientErrorEvent(this, err));\n            });\n          }\n        };\n      }).catch(err => {\n        this.emit("error", new ClientErrorEvent(this, err));\n      });\n      return this;\n    }\n\n    close() {\n      if (this.socket) {\n        this.socket.close();\n      }\n    }\n\n    on(event, listener) {\n      return super.on(event, listener);\n    }\n\n    once(event, listener) {\n      return super.once(event, listener);\n    }\n\n    async challenge() {\n      if (!this.cipher) {\n        throw new Error("Client cipher is not initialized");\n      }\n\n      return challenge(this.cipher.remoteIdentity.signingKey, this.cipher.identity.signingKey.publicKey);\n    }\n\n    async isLoggedIn() {\n      const action = new ServerIsLoggedInActionProto();\n      const data = await this.send(action);\n      return data ? !!new Uint8Array(data)[0] : false;\n    }\n\n    async login() {\n      const action = new ServerLoginActionProto();\n      await this.send(action);\n    }\n\n    send(data) {\n      return new Promise((resolve, reject) => {\n        this.checkSocketState();\n\n        if (!data) {\n          data = new ActionProto();\n        }\n\n        data.action = data.action;\n        data.actionId = (this.messageCounter++).toString();\n        data.exportProto().then(raw => {\n          if (!this.cipher) {\n            throw new Error("Client cipher is not initialized");\n          }\n\n          return this.cipher.encrypt(raw).then(msg => msg.exportProto());\n        }).then(raw => {\n          if (!this.socket) {\n            throw new Error("Client socket is not initialized");\n          }\n\n          this.stack[data.actionId] = {\n            resolve,\n            reject\n          };\n          this.socket.send(raw);\n        }).catch(reject);\n      });\n    }\n\n    async getServerInfo(address) {\n      const url = `https://${address}${SERVER_WELL_KNOWN}`;\n      const response = await fetch(url);\n\n      if (response.status !== 200) {\n        throw new Error("Cannot get wellknown link");\n      } else {\n        const json = await response.json();\n        return json;\n      }\n    }\n\n    checkSocketState() {\n      if (this.state !== SocketCryptoState.open) {\n        throw new Error("Socket connection is not open");\n      }\n    }\n\n    async onMessage(message) {\n      const p = await ActionProto.importProto(message);\n      const promise = this.stack[p.actionId];\n\n      if (promise) {\n        delete this.stack[p.actionId];\n        const messageProto = await ResultProto.importProto((await p.exportProto()));\n\n        if (messageProto.error && messageProto.error.message) {\n          const errorProto = messageProto.error;\n          const error = new CryptoServerError(errorProto);\n          promise.reject(error);\n        } else {\n          promise.resolve(messageProto.data);\n        }\n      } else {\n        this.emit("event", p);\n      }\n    }\n\n  }\n  /**\n   * Copyright (c) 2019, Peculiar Ventures, All rights reserved.\n   */\n\n\n  class PemConverter {\n    static toArrayBuffer(pem) {\n      const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/g, "").replace("\\r", "").replace("\\n", "");\n      return Convert.FromBase64(base64);\n    }\n\n    static toUint8Array(pem) {\n      const bytes = this.toArrayBuffer(pem);\n      return new Uint8Array(bytes);\n    }\n\n    static fromBufferSource(buffer, tag) {\n      const base64 = Convert.ToBase64(buffer);\n      let sliced;\n      let offset = 0;\n      const rows = [];\n\n      while (true) {\n        sliced = base64.slice(offset, offset = offset + 64);\n\n        if (sliced.length) {\n          rows.push(sliced);\n\n          if (sliced.length < 64) {\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n\n      const upperCaseTag = tag.toUpperCase();\n      return `-----BEGIN ${upperCaseTag}-----\\n${rows.join("\\n")}\\n-----END ${upperCaseTag}-----`;\n    }\n\n    static isPEM(data) {\n      return /-----BEGIN .+-----[A-Za-z0-9+\\/\\+\\=\\s\\n]+-----END .+-----/i.test(data);\n    }\n\n    static getTagName(pem) {\n      if (!this.isPEM(pem)) {\n        throw new Error("Bad parameter. Incoming data is not right PEM");\n      }\n\n      const res = /-----BEGIN (.+)-----/.exec(pem);\n\n      if (!res) {\n        throw new Error("Cannot get tag from PEM");\n      }\n\n      return res[1];\n    }\n\n    static hasTagName(pem, tagName) {\n      const tag = this.getTagName(pem);\n      return tagName.toLowerCase() === tag.toLowerCase();\n    }\n\n    static isCertificate(pem) {\n      return this.hasTagName(pem, "certificate");\n    }\n\n    static isCertificateRequest(pem) {\n      return this.hasTagName(pem, "certificate request");\n    }\n\n    static isCRL(pem) {\n      return this.hasTagName(pem, "x509 crl");\n    }\n\n    static isPublicKey(pem) {\n      return this.hasTagName(pem, "public key");\n    }\n\n  }\n\n  class BufferSourceConverter {\n    static toArrayBuffer(data) {\n      if (data instanceof ArrayBuffer) {\n        return data;\n      }\n\n      if (typeof Buffer !== "undefined" && Buffer.isBuffer(data)) {\n        return new Uint8Array(data);\n      }\n\n      if (ArrayBuffer.isView(data)) {\n        return data.buffer;\n      }\n\n      throw new TypeError("The provided value is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n    }\n\n    static toUint8Array(data) {\n      return new Uint8Array(this.toArrayBuffer(data));\n    }\n\n    static isBufferSource(data) {\n      return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;\n    }\n\n  }\n\n  function Cast(data) {\n    return data;\n  }\n\n  function isHashedAlgorithm(data) {\n    return data instanceof Object && "name" in data && "hash" in data;\n  }\n\n  function prepareAlgorithm(algorithm) {\n    if (algorithm instanceof AlgorithmProto) {\n      return algorithm;\n    }\n\n    const algProto = new AlgorithmProto();\n\n    if (typeof algorithm === "string") {\n      algProto.fromAlgorithm({\n        name: algorithm\n      });\n    } else if (isHashedAlgorithm(algorithm)) {\n      const preparedAlgorithm = _objectSpread({}, algorithm);\n\n      preparedAlgorithm.hash = prepareAlgorithm(algorithm.hash);\n      algProto.fromAlgorithm(preparedAlgorithm);\n    } else {\n      algProto.fromAlgorithm(_objectSpread({}, algorithm));\n    }\n\n    return algProto;\n  }\n\n  function isCryptoKey(data) {\n    return data instanceof CryptoKeyProto;\n  }\n\n  function isCryptoCertificate(data) {\n    return data instanceof CryptoCertificateProto;\n  }\n\n  function checkAlgorithm(algorithm, param) {\n    if (!(algorithm && (typeof algorithm === "object" || typeof algorithm === "string"))) {\n      throw new TypeError(`${param}: Is wrong type. Must be Object or String`);\n    }\n\n    if (typeof algorithm === "object" && !("name" in algorithm)) {\n      throw new TypeError(`${param}: Required property \'name\' is missed`);\n    }\n  }\n\n  function checkCryptoKey(data, param) {\n    if (!isCryptoKey(data)) {\n      throw new TypeError(`${param}: Is not type CryptoKey`);\n    }\n  }\n\n  function checkCryptoCertificate(data, param) {\n    if (!isCryptoCertificate(data)) {\n      throw new TypeError(`${param}: Is not type CryptoCertificate`);\n    }\n  }\n\n  function checkBufferSource(data, param) {\n    if (!BufferSourceConverter.isBufferSource(data)) {\n      throw new TypeError(`${param}: Is wrong type. Must be ArrayBuffer or ArrayBuffer view`);\n    }\n  }\n\n  function checkArray(data, param) {\n    if (!Array.isArray(data)) {\n      throw new TypeError(`${param}: Is not type Array`);\n    }\n  }\n\n  function checkPrimitive(data, type, param) {\n    if (typeof data !== type) {\n      throw new TypeError(`${param}: Is not type \'${type}\'`);\n    }\n  }\n\n  const IMPORT_CERT_FORMATS = ["raw", "pem", "x509", "request"];\n\n  class CertificateStorage {\n    constructor(provider) {\n      this.provider = provider;\n    }\n\n    async indexOf(item) {\n      checkCryptoCertificate(item, "item");\n      const proto = new CertificateStorageIndexOfActionProto();\n      proto.providerID = this.provider.id;\n      proto.item = item;\n      const result = await this.provider.client.send(proto);\n      return result ? Convert.ToUtf8String(result) : null;\n    }\n\n    async hasItem(item) {\n      const index = await this.indexOf(item);\n      return !!index;\n    }\n\n    async exportCert(format, item) {\n      checkPrimitive(format, "string", "format");\n      checkCryptoCertificate(item, "item");\n      const proto = new CertificateStorageExportActionProto();\n      proto.providerID = this.provider.id;\n      proto.format = "raw";\n      proto.item = item;\n      const result = await this.provider.client.send(proto);\n\n      if (format === "raw") {\n        return result;\n      } else {\n        let header = "";\n\n        switch (item.type) {\n          case "x509":\n            {\n              header = "CERTIFICATE";\n              break;\n            }\n\n          case "request":\n            {\n              header = "CERTIFICATE REQUEST";\n              break;\n            }\n\n          default:\n            throw new Error(`Cannot create PEM for unknown type of certificate item`);\n        }\n\n        const pem = PemConverter.fromBufferSource(result, header);\n        return pem;\n      }\n    }\n\n    async importCert(format, data, algorithm, keyUsages) {\n      checkPrimitive(format, "string", "format");\n\n      if (!~IMPORT_CERT_FORMATS.indexOf(format)) {\n        throw new TypeError(`format: Is invalid value. Must be ${IMPORT_CERT_FORMATS.join(", ")}`);\n      }\n\n      if (format === "pem") {\n        checkPrimitive(data, "string", "data");\n      } else {\n        checkBufferSource(data, "data");\n      }\n\n      checkAlgorithm(algorithm, "algorithm");\n      checkArray(keyUsages, "keyUsages");\n      const algProto = prepareAlgorithm(algorithm);\n      let rawData;\n\n      if (BufferSourceConverter.isBufferSource(data)) {\n        rawData = BufferSourceConverter.toArrayBuffer(data);\n      } else if (typeof data === "string") {\n        rawData = PemConverter.toArrayBuffer(data);\n      } else {\n        throw new TypeError("data: Is not type String, ArrayBuffer or ArrayBufferView");\n      }\n\n      const proto = new CertificateStorageImportActionProto();\n      proto.providerID = this.provider.id;\n      proto.format = "raw";\n      proto.data = rawData;\n      proto.algorithm = algProto;\n      proto.keyUsages = keyUsages;\n      const result = await this.provider.client.send(proto);\n      const certItem = await CryptoCertificateProto.importProto(result);\n\n      if ((format === "request" || format === "x509") && certItem.type !== format) {\n        throw new TypeError(`Imported item is not ${format}`);\n      }\n\n      return this.prepareCertItem(certItem);\n    }\n\n    async keys() {\n      const proto = new CertificateStorageKeysActionProto();\n      proto.providerID = this.provider.id;\n      const result = await this.provider.client.send(proto);\n\n      if (result) {\n        const keys = Convert.ToUtf8String(result).split(",");\n        return keys;\n      }\n\n      return [];\n    }\n\n    async getItem(key, algorithm, keyUsages) {\n      checkPrimitive(key, "string", "key");\n\n      if (algorithm) {\n        checkAlgorithm(algorithm, "algorithm");\n        checkArray(keyUsages, "keyUsages");\n      }\n\n      const proto = new CertificateStorageGetItemActionProto();\n      proto.providerID = this.provider.id;\n      proto.key = key;\n\n      if (algorithm) {\n        proto.algorithm = prepareAlgorithm(algorithm);\n        proto.keyUsages = keyUsages;\n      }\n\n      const result = await this.provider.client.send(proto);\n\n      if (result && result.byteLength) {\n        const certItem = await CryptoCertificateProto.importProto(result);\n        return this.prepareCertItem(certItem);\n      }\n\n      throw new Error("Cannot get CryptoCertificate from storage by index");\n    }\n\n    async setItem(value) {\n      checkCryptoCertificate(value, "value");\n      const proto = new CertificateStorageSetItemActionProto();\n      proto.providerID = this.provider.id;\n      proto.item = value;\n      const data = await this.provider.client.send(proto);\n      return Convert.ToUtf8String(data);\n    }\n\n    async removeItem(key) {\n      checkPrimitive(key, "string", "key");\n      const proto = new CertificateStorageRemoveItemActionProto();\n      proto.providerID = this.provider.id;\n      proto.key = key;\n      await this.provider.client.send(proto);\n    }\n\n    async clear() {\n      const proto = new CertificateStorageClearActionProto();\n      proto.providerID = this.provider.id;\n      await this.provider.client.send(proto);\n    }\n\n    async getChain(value) {\n      checkCryptoCertificate(value, "value");\n      const proto = new CertificateStorageGetChainActionProto();\n      proto.providerID = this.provider.id;\n      proto.item = value;\n      const data = await this.provider.client.send(proto);\n      const resultProto = await CertificateStorageGetChainResultProto.importProto(data);\n      return resultProto.items;\n    }\n\n    async getCRL(url) {\n      checkPrimitive(url, "string", "url");\n      const proto = new CertificateStorageGetCRLActionProto();\n      proto.providerID = this.provider.id;\n      proto.url = url;\n      const data = await this.provider.client.send(proto);\n      return data;\n    }\n\n    async getOCSP(url, request, options) {\n      checkPrimitive(url, "string", "url");\n      checkBufferSource(request, "request");\n      const proto = new CertificateStorageGetOCSPActionProto();\n      proto.providerID = this.provider.id;\n      proto.url = url;\n      proto.request = BufferSourceConverter.toArrayBuffer(request);\n\n      if (options) {\n        for (const key in options) {\n          proto.options[key] = options[key];\n        }\n      }\n\n      const data = await this.provider.client.send(proto);\n      return data;\n    }\n\n    async prepareCertItem(item) {\n      const raw = await item.exportProto();\n      let result;\n\n      switch (item.type) {\n        case "x509":\n          {\n            result = await CryptoX509CertificateProto.importProto(raw);\n            break;\n          }\n\n        case "request":\n          {\n            result = await CryptoX509CertificateRequestProto.importProto(raw);\n            break;\n          }\n\n        default:\n          throw new Error(`Unsupported CertificateItem type \'${item.type}\'`);\n      }\n\n      result.provider = this.provider;\n      return result;\n    }\n\n  }\n\n  class KeyStorage {\n    constructor(service) {\n      this.service = service;\n    }\n\n    async keys() {\n      const proto = new KeyStorageKeysActionProto();\n      proto.providerID = this.service.id;\n      const result = await this.service.client.send(proto);\n\n      if (result) {\n        const keys = Convert.ToUtf8String(result).split(",");\n        return keys;\n      }\n\n      return [];\n    }\n\n    async indexOf(item) {\n      checkCryptoKey(item, "item");\n      const proto = new KeyStorageIndexOfActionProto();\n      proto.providerID = this.service.id;\n      proto.item = item;\n      const result = await this.service.client.send(proto);\n      return result ? Convert.ToUtf8String(result) : null;\n    }\n\n    async hasItem(item) {\n      const index = await this.indexOf(item);\n      return !!index;\n    }\n\n    async getItem(key, algorithm, extractable, usages) {\n      checkPrimitive(key, "string", "key");\n\n      if (algorithm) {\n        checkAlgorithm(algorithm, "algorithm");\n        checkPrimitive(extractable, "boolean", "extractable");\n        checkArray(usages, "usages");\n      }\n\n      const proto = new KeyStorageGetItemActionProto();\n      proto.providerID = this.service.id;\n      proto.key = key;\n\n      if (algorithm) {\n        proto.algorithm = prepareAlgorithm(algorithm);\n        proto.extractable = extractable;\n        proto.keyUsages = usages;\n      }\n\n      const result = await this.service.client.send(proto);\n      let socketKey;\n\n      if (result && result.byteLength) {\n        socketKey = await CryptoKeyProto.importProto(result);\n      } else {\n        throw new Error("Cannot get CryptoKey from key storage by index");\n      }\n\n      return socketKey;\n    }\n\n    async setItem(value) {\n      checkCryptoKey(value, "value");\n      const proto = new KeyStorageSetItemActionProto();\n      proto.providerID = this.service.id;\n      proto.item = value;\n      const data = await this.service.client.send(proto);\n      return Convert.ToUtf8String(data);\n    }\n\n    async removeItem(key) {\n      checkPrimitive(key, "string", "key");\n      const proto = new KeyStorageRemoveItemActionProto();\n      proto.providerID = this.service.id;\n      proto.key = key;\n      await this.service.client.send(proto);\n    }\n\n    async clear() {\n      const proto = new KeyStorageClearActionProto();\n      proto.providerID = this.service.id;\n      await this.service.client.send(proto);\n    }\n\n  }\n\n  class SubtleCrypto {\n    constructor(crypto) {\n      this.service = crypto;\n    }\n\n    async encrypt(algorithm, key, data) {\n      return this.encryptData(algorithm, key, data, "encrypt");\n    }\n\n    async decrypt(algorithm, key, data) {\n      return this.encryptData(algorithm, key, data, "decrypt");\n    }\n\n    async deriveBits(algorithm, baseKey, length) {\n      checkAlgorithm(algorithm, "algorithm");\n      checkCryptoKey(baseKey, "baseKey");\n      checkPrimitive(length, "number", "length");\n      const algProto = prepareAlgorithm(algorithm);\n      checkCryptoKey(algProto.public, "algorithm.public");\n      algProto.public = await Cast(algProto.public).exportProto();\n      const action = new DeriveBitsActionProto();\n      action.providerID = this.service.id;\n      action.algorithm = algProto;\n      action.key = baseKey;\n      action.length = length;\n      const result = await this.service.client.send(action);\n      return result;\n    }\n\n    async deriveKey(algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\n      checkAlgorithm(algorithm, "algorithm");\n      checkCryptoKey(baseKey, "baseKey");\n      checkAlgorithm(derivedKeyType, "algorithm");\n      checkPrimitive(extractable, "boolean", "extractable");\n      checkArray(keyUsages, "keyUsages");\n      const algProto = prepareAlgorithm(algorithm);\n      checkCryptoKey(algProto.public, "algorithm.public");\n      algProto.public = await Cast(algProto.public).exportProto();\n      const algKeyType = prepareAlgorithm(derivedKeyType);\n      const action = new DeriveKeyActionProto();\n      action.providerID = this.service.id;\n      action.algorithm = algProto;\n      action.derivedKeyType.fromAlgorithm(algKeyType);\n      action.key = baseKey;\n      action.extractable = extractable;\n      action.usage = keyUsages;\n      const result = await this.service.client.send(action);\n      return await CryptoKeyProto.importProto(result);\n    }\n\n    async digest(algorithm, data) {\n      checkAlgorithm(algorithm, "algorithm");\n      checkBufferSource(data, "data");\n      const algProto = prepareAlgorithm(algorithm);\n      const rawData = BufferSourceConverter.toArrayBuffer(data);\n      return getEngine().crypto.subtle.digest(algorithm, rawData);\n    }\n\n    async generateKey(algorithm, extractable, keyUsages) {\n      checkAlgorithm(algorithm, "algorithm");\n      checkPrimitive(extractable, "boolean", "extractable");\n      checkArray(keyUsages, "keyUsages");\n      const algProto = prepareAlgorithm(algorithm);\n      const action = new GenerateKeyActionProto();\n      action.providerID = this.service.id;\n      action.algorithm = algProto;\n      action.extractable = extractable;\n      action.usage = keyUsages;\n      const result = await this.service.client.send(action);\n\n      try {\n        const keyPair = await CryptoKeyPairProto.importProto(result);\n        return keyPair;\n      } catch (e) {\n        const key = await CryptoKeyProto.importProto(result);\n        return key;\n      }\n    }\n\n    async exportKey(format, key) {\n      checkPrimitive(format, "string", "format");\n      checkCryptoKey(key, "key");\n      const action = new ExportKeyActionProto();\n      action.providerID = this.service.id;\n      action.format = format;\n      action.key = key;\n      const result = await this.service.client.send(action);\n\n      if (format === "jwk") {\n        return JSON.parse(Convert.ToBinary(result));\n      } else {\n        return result;\n      }\n    }\n\n    async importKey(format, keyData, algorithm, extractable, keyUsages) {\n      checkPrimitive(format, "string", "format");\n      checkAlgorithm(algorithm, "algorithm");\n      checkPrimitive(extractable, "boolean", "extractable");\n      checkArray(keyUsages, "keyUsages");\n      const algProto = prepareAlgorithm(algorithm);\n      let preparedKeyData;\n\n      if (format === "jwk") {\n        preparedKeyData = Convert.FromUtf8String(JSON.stringify(keyData));\n      } else {\n        checkBufferSource(keyData, "keyData");\n        preparedKeyData = BufferSourceConverter.toArrayBuffer(keyData);\n      }\n\n      const action = new ImportKeyActionProto();\n      action.providerID = this.service.id;\n      action.algorithm = algProto;\n      action.keyData = preparedKeyData;\n      action.format = format;\n      action.extractable = extractable;\n      action.keyUsages = keyUsages;\n      const result = await this.service.client.send(action);\n      return await CryptoKeyProto.importProto(result);\n    }\n\n    async sign(algorithm, key, data) {\n      checkAlgorithm(algorithm, "algorithm");\n      checkCryptoKey(key, "key");\n      checkBufferSource(data, "data");\n      const algProto = prepareAlgorithm(algorithm);\n      const rawData = BufferSourceConverter.toArrayBuffer(data);\n      const action = new SignActionProto();\n      action.providerID = this.service.id;\n      action.algorithm = algProto;\n      action.key = key;\n      action.data = rawData;\n      const result = await this.service.client.send(action);\n      return result;\n    }\n\n    async verify(algorithm, key, signature, data) {\n      checkAlgorithm(algorithm, "algorithm");\n      checkCryptoKey(key, "key");\n      checkBufferSource(signature, "signature");\n      checkBufferSource(data, "data");\n      const algProto = prepareAlgorithm(algorithm);\n      const rawSignature = BufferSourceConverter.toArrayBuffer(signature);\n      const rawData = BufferSourceConverter.toArrayBuffer(data);\n      const action = new VerifyActionProto();\n      action.providerID = this.service.id;\n      action.algorithm = algProto;\n      action.key = key;\n      action.data = rawData;\n      action.signature = rawSignature;\n      const result = await this.service.client.send(action);\n      return !!new Uint8Array(result)[0];\n    }\n\n    async wrapKey(format, key, wrappingKey, wrapAlgorithm) {\n      checkPrimitive(format, "string", "format");\n      checkCryptoKey(key, "key");\n      checkCryptoKey(wrappingKey, "wrappingKey");\n      checkAlgorithm(wrapAlgorithm, "wrapAlgorithm");\n      const wrapAlgProto = prepareAlgorithm(wrapAlgorithm);\n      const action = new WrapKeyActionProto();\n      action.providerID = this.service.id;\n      action.wrapAlgorithm = wrapAlgProto;\n      action.key = key;\n      action.wrappingKey = wrappingKey;\n      action.format = format;\n      const result = await this.service.client.send(action);\n      return result;\n    }\n\n    async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\n      checkPrimitive(format, "string", "format");\n      checkBufferSource(wrappedKey, "wrappedKey");\n      checkCryptoKey(unwrappingKey, "unwrappingKey");\n      checkAlgorithm(unwrapAlgorithm, "unwrapAlgorithm");\n      checkAlgorithm(unwrappedKeyAlgorithm, "unwrappedKeyAlgorithm");\n      checkPrimitive(extractable, "boolean", "extractable");\n      checkArray(keyUsages, "keyUsages");\n      const unwrapAlgProto = prepareAlgorithm(unwrapAlgorithm);\n      const unwrappedKeyAlgProto = prepareAlgorithm(unwrappedKeyAlgorithm);\n      const rawWrappedKey = BufferSourceConverter.toArrayBuffer(wrappedKey);\n      const action = new UnwrapKeyActionProto();\n      action.providerID = this.service.id;\n      action.format = format;\n      action.unwrapAlgorithm = unwrapAlgProto;\n      action.unwrappedKeyAlgorithm = unwrappedKeyAlgProto;\n      action.unwrappingKey = unwrappingKey;\n      action.wrappedKey = rawWrappedKey;\n      action.extractable = extractable;\n      action.keyUsage = keyUsages;\n      const result = await this.service.client.send(action);\n      return await CryptoKeyProto.importProto(result);\n    }\n\n    async encryptData(algorithm, key, data, type) {\n      checkAlgorithm(algorithm, "algorithm");\n      checkCryptoKey(key, "key");\n      checkBufferSource(data, "data");\n      const algProto = prepareAlgorithm(algorithm);\n      const rawData = BufferSourceConverter.toArrayBuffer(data);\n      let ActionClass;\n\n      if (type === "encrypt") {\n        ActionClass = EncryptActionProto;\n      } else {\n        ActionClass = DecryptActionProto;\n      }\n\n      const action = new ActionClass();\n      action.providerID = this.service.id;\n      action.algorithm = algProto;\n      action.key = key;\n      action.data = rawData;\n      const result = await this.service.client.send(action);\n      return result;\n    }\n\n  }\n\n  class SocketCrypto {\n    constructor(client, id) {\n      this.client = client;\n      this.id = id;\n      this.subtle = new SubtleCrypto(this);\n      this.keyStorage = new KeyStorage(this);\n      this.certStorage = new CertificateStorage(this);\n    }\n\n    getRandomValues(array) {\n      return getEngine().crypto.getRandomValues(array);\n    }\n\n    async login() {\n      const action = new LoginActionProto();\n      action.providerID = this.id;\n      return this.client.send(action);\n    }\n\n    async logout() {\n      const action = new LogoutActionProto();\n      action.providerID = this.id;\n      return this.client.send(action);\n    }\n\n    async reset() {\n      const action = new ResetActionProto();\n      action.providerID = this.id;\n      return this.client.send(action);\n    }\n\n    async isLoggedIn() {\n      const action = new IsLoggedInActionProto();\n      action.providerID = this.id;\n      const res = await this.client.send(action);\n      return !!new Uint8Array(res)[0];\n    }\n\n  }\n\n  class SocketProvider extends EventEmitter {\n    get state() {\n      return this.client.state;\n    }\n\n    constructor(options) {\n      super();\n      this.client = new Client(options.storage);\n      this.cardReader = new CardReader(this.client);\n    }\n\n    connect(address, options) {\n      this.removeAllListeners();\n      this.client.connect(address, options).on("error", e => {\n        this.emit("error", e.error);\n      }).on("event", proto => {\n        (async () => {\n          switch (proto.action) {\n            case ProviderTokenEventProto.ACTION:\n              {\n                const tokenProto = await ProviderTokenEventProto.importProto((await proto.exportProto()));\n                this.emit("token", tokenProto);\n              }\n\n            case ProviderAuthorizedEventProto.ACTION:\n              {\n                const authProto = await ProviderAuthorizedEventProto.importProto((await proto.exportProto()));\n                this.emit("auth", authProto);\n              }\n\n            default:\n          }\n        })();\n      }).on("listening", e => {\n        this.emit("listening", address);\n      }).on("close", e => {\n        this.emit("close", e.remoteAddress);\n      });\n      return this;\n    }\n\n    close() {\n      this.client.close();\n    }\n\n    on(event, listener) {\n      return super.on(event, listener);\n    }\n\n    once(event, listener) {\n      return super.once(event, listener);\n    }\n\n    async info() {\n      const proto = new ProviderInfoActionProto();\n      const result = await this.client.send(proto);\n      const infoProto = await ProviderInfoProto.importProto(result);\n      return infoProto;\n    }\n\n    async challenge() {\n      return this.client.challenge();\n    }\n\n    async isLoggedIn() {\n      return this.client.isLoggedIn();\n    }\n\n    async login() {\n      return this.client.login();\n    }\n\n    async getCrypto(cryptoID) {\n      const actionProto = new ProviderGetCryptoActionProto();\n      actionProto.cryptoID = cryptoID;\n      await this.client.send(actionProto);\n      return new SocketCrypto(this.client, cryptoID);\n    }\n\n  }\n\n  class RatchetStorage {}\n\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function (resolve, reject) {\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n\n      request.onerror = function () {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function (resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function (value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function (prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function () {\n          return this[targetProp][prop];\n        },\n        set: function (val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function (prop) {\n      if (!(prop in Constructor.prototype)) return;\n\n      ProxyClass.prototype[prop] = function () {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function (prop) {\n      if (!(prop in Constructor.prototype)) return;\n\n      ProxyClass.prototype[prop] = function () {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function (prop) {\n      if (!(prop in Constructor.prototype)) return;\n\n      ProxyClass.prototype[prop] = function () {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, \'_index\', [\'name\', \'keyPath\', \'multiEntry\', \'unique\']);\n  proxyRequestMethods(Index, \'_index\', IDBIndex, [\'get\', \'getKey\', \'getAll\', \'getAllKeys\', \'count\']);\n  proxyCursorRequestMethods(Index, \'_index\', IDBIndex, [\'openCursor\', \'openKeyCursor\']);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, \'_cursor\', [\'direction\', \'key\', \'primaryKey\', \'value\']);\n  proxyRequestMethods(Cursor, \'_cursor\', IDBCursor, [\'update\', \'delete\']); // proxy \'next\' methods\n\n  [\'advance\', \'continue\', \'continuePrimaryKey\'].forEach(function (methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n\n    Cursor.prototype[methodName] = function () {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function () {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n\n        return promisifyRequest(cursor._request).then(function (value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function () {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function () {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, \'_store\', [\'name\', \'keyPath\', \'indexNames\', \'autoIncrement\']);\n  proxyRequestMethods(ObjectStore, \'_store\', IDBObjectStore, [\'put\', \'add\', \'delete\', \'clear\', \'get\', \'getAll\', \'getKey\', \'getAllKeys\', \'count\']);\n  proxyCursorRequestMethods(ObjectStore, \'_store\', IDBObjectStore, [\'openCursor\', \'openKeyCursor\']);\n  proxyMethods(ObjectStore, \'_store\', IDBObjectStore, [\'deleteIndex\']);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function (resolve, reject) {\n      idbTransaction.oncomplete = function () {\n        resolve();\n      };\n\n      idbTransaction.onerror = function () {\n        reject(idbTransaction.error);\n      };\n\n      idbTransaction.onabort = function () {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function () {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, \'_tx\', [\'objectStoreNames\', \'mode\']);\n  proxyMethods(Transaction, \'_tx\', IDBTransaction, [\'abort\']);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function () {\n    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n  };\n\n  proxyProperties(UpgradeDB, \'_db\', [\'name\', \'version\', \'objectStoreNames\']);\n  proxyMethods(UpgradeDB, \'_db\', IDBDatabase, [\'deleteObjectStore\', \'close\']);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function () {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, \'_db\', [\'name\', \'version\', \'objectStoreNames\']);\n  proxyMethods(DB, \'_db\', IDBDatabase, [\'close\']); // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n\n  [\'openCursor\', \'openKeyCursor\'].forEach(function (funcName) {\n    [ObjectStore, Index].forEach(function (Constructor) {\n      // Don\'t create iterateKeyCursor if openKeyCursor doesn\'t exist.\n      if (!(funcName in Constructor.prototype)) return;\n\n      Constructor.prototype[funcName.replace(\'open\', \'iterate\')] = function () {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n\n        request.onsuccess = function () {\n          callback(request.result);\n        };\n      };\n    });\n  }); // polyfill getAll\n\n  [Index, ObjectStore].forEach(function (Constructor) {\n    if (Constructor.prototype.getAll) return;\n\n    Constructor.prototype.getAll = function (query, count) {\n      var instance = this;\n      var items = [];\n      return new Promise(function (resolve) {\n        instance.iterateCursor(query, function (cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  function openDb(name, version, upgradeCallback) {\n    var p = promisifyRequestCall(indexedDB, \'open\', [name, version]);\n    var request = p.request;\n\n    if (request) {\n      request.onupgradeneeded = function (event) {\n        if (upgradeCallback) {\n          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n        }\n      };\n    }\n\n    return p.then(function (db) {\n      return new DB(db);\n    });\n  }\n\n  function isFirefox() {\n    return /firefox/i.test(self.navigator.userAgent);\n  }\n\n  function isEdge() {\n    return /edge\\/([\\d\\.]+)/i.test(self.navigator.userAgent);\n  }\n\n  const ECDH = {\n    name: "ECDH",\n    namedCurve: "P-256"\n  };\n  const ECDSA = {\n    name: "ECDSA",\n    namedCurve: "P-256"\n  };\n  const AES_CBC = {\n    name: "AES-CBC",\n    iv: new ArrayBuffer(16)\n  };\n\n  async function createEcPublicKey(publicKey) {\n    const algName = publicKey.algorithm.name.toUpperCase();\n\n    if (!(algName === "ECDH" || algName === "ECDSA")) {\n      throw new Error("Error: Unsupported asymmetric key algorithm.");\n    }\n\n    if (publicKey.type !== "public") {\n      throw new Error("Error: Expected key type to be public but it was not.");\n    }\n\n    const jwk = await getEngine().crypto.subtle.exportKey("jwk", publicKey);\n\n    if (!(jwk.x && jwk.y)) {\n      throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");\n    }\n\n    const x = Convert.FromBase64Url(jwk.x);\n    const y = Convert.FromBase64Url(jwk.y);\n    const xy = Convert.ToBinary(x) + Convert.ToBinary(y);\n    const key = publicKey;\n    const serialized = Convert.FromBinary(xy);\n    const id = Convert.ToHex((await getEngine().crypto.subtle.digest("SHA-256", serialized)));\n    return {\n      id,\n      key,\n      serialized\n    };\n  }\n\n  async function updateEcPublicKey(ecPublicKey, publicKey) {\n    const data = await createEcPublicKey(publicKey);\n    ecPublicKey.id = data.id;\n    ecPublicKey.key = data.key;\n    ecPublicKey.serialized = data.serialized;\n  }\n\n  class BrowserStorage extends RatchetStorage {\n    constructor(db) {\n      super();\n      this.db = db;\n    }\n\n    static async create() {\n      const db = await openDb(this.STORAGE_NAME, 1, updater => {\n        updater.createObjectStore(this.SESSION_STORAGE);\n        updater.createObjectStore(this.IDENTITY_STORAGE);\n        updater.createObjectStore(this.REMOTE_STORAGE);\n      });\n      return new BrowserStorage(db);\n    }\n\n    async loadWrapKey() {\n      const wKey = await this.db.transaction(BrowserStorage.IDENTITY_STORAGE).objectStore(BrowserStorage.IDENTITY_STORAGE).get("wkey");\n\n      if (wKey) {\n        if (isEdge()) {\n          if (!(wKey.key instanceof ArrayBuffer)) {\n            return null;\n          }\n\n          wKey.key = await getEngine().crypto.subtle.importKey("raw", wKey.key, {\n            name: AES_CBC.name,\n            length: 256\n          }, false, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]);\n        }\n\n        AES_CBC.iv = wKey.iv;\n      }\n\n      return wKey || null;\n    }\n\n    async saveWrapKey(key) {\n      if (isEdge()) {\n        key = {\n          key: await getEngine().crypto.subtle.exportKey("raw", key.key),\n          iv: key.iv\n        };\n      }\n\n      const tx = this.db.transaction(BrowserStorage.IDENTITY_STORAGE, "readwrite");\n      tx.objectStore(BrowserStorage.IDENTITY_STORAGE).put(key, "wkey");\n      return tx.complete;\n    }\n\n    async loadIdentity() {\n      const json = await this.db.transaction(BrowserStorage.IDENTITY_STORAGE).objectStore(BrowserStorage.IDENTITY_STORAGE).get("identity");\n      let res = null;\n\n      if (json) {\n        if (isFirefox() || isEdge()) {\n          const wkey = await this.loadWrapKey();\n\n          if (!(wkey && wkey.key.usages.some(usage => usage === "encrypt") && json.exchangeKey.privateKey instanceof ArrayBuffer)) {\n            return null;\n          }\n\n          json.exchangeKey.privateKey = await getEngine().crypto.subtle.decrypt(AES_CBC, wkey.key, json.exchangeKey.privateKey).then(buf => getEngine().crypto.subtle.importKey("jwk", JSON.parse(Convert.ToUtf8String(buf)), ECDH, false, ["deriveKey", "deriveBits"]));\n          json.signingKey.privateKey = await getEngine().crypto.subtle.decrypt(AES_CBC, wkey.key, json.signingKey.privateKey).then(buf => getEngine().crypto.subtle.importKey("jwk", JSON.parse(Convert.ToUtf8String(buf)), ECDSA, false, ["sign"]));\n\n          if (isEdge()) {\n            json.exchangeKey.publicKey = await getEngine().crypto.subtle.unwrapKey("jwk", json.exchangeKey.publicKey, wkey.key, AES_CBC, ECDH, true, []);\n            json.signingKey.publicKey = await getEngine().crypto.subtle.unwrapKey("jwk", json.signingKey.publicKey, wkey.key, AES_CBC, ECDSA, true, ["verify"]);\n          }\n        }\n\n        res = await Identity.fromJSON(json);\n      }\n\n      return res;\n    }\n\n    async saveIdentity(value) {\n      let wkey;\n\n      if (isFirefox() || isEdge()) {\n        wkey = {\n          key: await getEngine().crypto.subtle.generateKey({\n            name: AES_CBC.name,\n            length: 256\n          }, isEdge(), ["wrapKey", "unwrapKey", "encrypt", "decrypt"]),\n          iv: getEngine().crypto.getRandomValues(new Uint8Array(AES_CBC.iv)).buffer\n        };\n        await this.saveWrapKey(wkey);\n        const exchangeKeyPair = await getEngine().crypto.subtle.generateKey(value.exchangeKey.privateKey.algorithm, true, ["deriveKey", "deriveBits"]);\n        value.exchangeKey.privateKey = exchangeKeyPair.privateKey;\n        await updateEcPublicKey(value.exchangeKey.publicKey, exchangeKeyPair.publicKey);\n        const signingKeyPair = await getEngine().crypto.subtle.generateKey(value.signingKey.privateKey.algorithm, true, ["sign", "verify"]);\n        value.signingKey.privateKey = signingKeyPair.privateKey;\n        await updateEcPublicKey(value.signingKey.publicKey, signingKeyPair.publicKey);\n      }\n\n      const json = await value.toJSON();\n\n      if (isFirefox() || isEdge()) {\n        if (!wkey) {\n          throw new Error("WrapKey is empty");\n        }\n\n        json.exchangeKey.privateKey = await getEngine().crypto.subtle.wrapKey("jwk", value.exchangeKey.privateKey, wkey.key, AES_CBC);\n        json.signingKey.privateKey = await getEngine().crypto.subtle.wrapKey("jwk", value.signingKey.privateKey, wkey.key, AES_CBC);\n\n        if (isEdge()) {\n          json.exchangeKey.publicKey = await getEngine().crypto.subtle.wrapKey("jwk", value.exchangeKey.publicKey.key, wkey.key, AES_CBC);\n          json.signingKey.publicKey = await getEngine().crypto.subtle.wrapKey("jwk", value.signingKey.publicKey.key, wkey.key, AES_CBC);\n        }\n      }\n\n      const tx = this.db.transaction(BrowserStorage.IDENTITY_STORAGE, "readwrite");\n      tx.objectStore(BrowserStorage.IDENTITY_STORAGE).put(json, "identity");\n      return tx.complete;\n    }\n\n    async loadRemoteIdentity(key) {\n      const json = await this.db.transaction(BrowserStorage.REMOTE_STORAGE).objectStore(BrowserStorage.REMOTE_STORAGE).get(key);\n      let res = null;\n\n      if (json) {\n        res = await RemoteIdentity.fromJSON(json);\n      }\n\n      return res;\n    }\n\n    async saveRemoteIdentity(key, value) {\n      const json = await value.toJSON();\n      const tx = this.db.transaction(BrowserStorage.REMOTE_STORAGE, "readwrite");\n      tx.objectStore(BrowserStorage.REMOTE_STORAGE).put(json, key);\n      return tx.complete;\n    }\n\n    async loadSession(key) {\n      const json = await this.db.transaction(BrowserStorage.SESSION_STORAGE).objectStore(BrowserStorage.SESSION_STORAGE).get(key);\n      let res = null;\n\n      if (json) {\n        const identity = await this.loadIdentity();\n\n        if (!identity) {\n          throw new Error("Identity is empty");\n        }\n\n        const remoteIdentity = await this.loadRemoteIdentity(key);\n\n        if (!remoteIdentity) {\n          throw new Error("Remote identity is not found");\n        }\n\n        res = await AsymmetricRatchet.fromJSON(identity, remoteIdentity, json);\n      }\n\n      return res;\n    }\n\n    async saveSession(key, value) {\n      const json = await value.toJSON();\n      const tx = this.db.transaction(BrowserStorage.SESSION_STORAGE, "readwrite");\n      tx.objectStore(BrowserStorage.SESSION_STORAGE).put(json, key);\n      return tx.complete;\n    }\n\n  }\n\n  BrowserStorage.STORAGE_NAME = "webcrypto-remote";\n  BrowserStorage.IDENTITY_STORAGE = "identity";\n  BrowserStorage.SESSION_STORAGE = "sessions";\n  BrowserStorage.REMOTE_STORAGE = "remoteIdentity";\n\n  class MemoryStorage extends RatchetStorage {\n    constructor() {\n      super(...arguments);\n      this.remoteIdentities = {};\n      this.sessions = {};\n    }\n\n    async loadIdentity() {\n      return this.identity || null;\n    }\n\n    async saveIdentity(value) {\n      this.identity = value;\n    }\n\n    async loadRemoteIdentity(key) {\n      return this.remoteIdentities[key] || null;\n    }\n\n    async saveRemoteIdentity(key, value) {\n      this.remoteIdentities[key] = value;\n    }\n\n    async loadSession(key) {\n      return this.sessions[key] || null;\n    }\n\n    async saveSession(key, value) {\n      this.sessions[key] = value;\n    }\n\n  }\n\n  exports.BrowserStorage = BrowserStorage;\n  exports.CryptoServerError = CryptoServerError;\n  exports.MemoryStorage = MemoryStorage;\n  exports.RatchetStorage = RatchetStorage;\n  exports.SocketCrypto = SocketCrypto;\n  exports.SocketProvider = SocketProvider;\n  exports.getEngine = getEngine;\n  exports.setEngine = setEngine;\n\n  return exports;\n\n}({}, protobuf, fetch, WebSocket));\n'},sL6v:function(e,t,n){n("8rVx")(n("AjCi"))}}]);