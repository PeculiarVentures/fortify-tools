(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{"7J5r":function(e,t,r){(function(e){!function(t){"use strict";function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},s=Object.keys(r);"function"===typeof Object.getOwnPropertySymbols&&(s=s.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),s.forEach(function(t){n(e,t,r[t])})}return e}class i{static get enabled(){return"undefined"!==typeof self&&self.PV_WEBCRYPTO_LINER_LOG}static log(e,...t){this.enabled&&console.log.apply(console,arguments)}static error(e,...t){this.enabled&&console.error.apply(console,arguments)}static info(e,...t){this.enabled&&console.info.apply(console,arguments)}static warn(e,...t){this.enabled&&console.warn.apply(console,arguments)}static trace(e,...t){this.enabled&&console.trace.apply(console,arguments)}}let o;if("undefined"===typeof self){const e=r("HEbw");o={crypto:{subtle:{},getRandomValues:t=>{const r=t.buffer,n=new Uint8Array(r);return e.randomBytes(n.length).forEach((e,t)=>n[t]=e),t}}}}else o=self;const a=o.msCrypto||o.crypto||{};let c=null;try{c=a.subtle||a.webkitSubtle}catch(it){console.warn("Cannot get subtle from crypto",it)}function l(e,t,r,n){var s,i=arguments.length,o=i<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"===typeof Reflect&&"function"===typeof Reflect.decorate)o=Reflect.decorate(e,t,r,n);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i<3?s(o):i>3?s(t,r,o):s(t,r))||o);return i>3&&o&&Object.defineProperty(t,r,o),o}function h(e,t,r,n){return new(r||(r=Promise))(function(s,i){function o(e){try{c(n.next(e))}catch(t){i(t)}}function a(e){try{c(n.throw(e))}catch(t){i(t)}}function c(e){e.done?s(e.value):new r(function(t){t(e.value)}).then(o,a)}c((n=n.apply(e,t||[])).next())})}function u(t){return"undefined"!==typeof e?new Uint8Array(t):new Uint8Array(t instanceof ArrayBuffer?t:t.buffer)}class f{static ToString(e,t="utf8"){const r=u(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(t){const r=u(t);if("undefined"!==typeof btoa){const e=this.ToString(r,"binary");return btoa(e)}return e.from(r).toString("base64")}static FromBase64(t){return t=t.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!==typeof atob?this.FromBinary(atob(t)):new Uint8Array(e.from(t,"base64")).buffer}static FromBase64Url(e){return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r.buffer}static ToUtf8String(e){const t=u(e),r=String.fromCharCode.apply(null,t);return decodeURIComponent(escape(r))}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);return r.buffer}static ToBinary(e){const t=u(e);let r="";const n=t.length;for(let s=0;s<n;s++)r+=String.fromCharCode(t[s]);return r}static ToHex(e){const t=u(e),r=[],n=t.length;for(let s=0;s<n;s++){const e=t[s].toString(16);r.push(1===e.length?"0"+e:e)}return r.join("")}static FromHex(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2){const n=e.slice(r,r+2);t[r/2]=parseInt(n,16)}return t.buffer}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}}class y extends Error{}class p extends y{}class g extends y{constructor(e){super(`Unsupported operation: ${e?`${e}`:""}`)}}class m extends y{}class d extends y{constructor(e){super(`${e}: Missing required property`)}}class v{static toArrayBuffer(t){if(t instanceof ArrayBuffer)return t;if("undefined"!==typeof e&&e.isBuffer(t))return new Uint8Array(t);if(ArrayBuffer.isView(t))return t.buffer;throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static toUint8Array(e){return new Uint8Array(this.toArrayBuffer(e))}static isBufferSource(e){return ArrayBuffer.isView(e)||e instanceof ArrayBuffer}}function k(e){return"object"===typeof e&&"kty"in e}class w{digest(e,t){return h(this,arguments,void 0,function*(){return this.checkDigest.apply(this,arguments),this.onDigest.apply(this,arguments)})}checkDigest(e,t){this.checkAlgorithmName(e)}onDigest(e,t){return h(this,void 0,void 0,function*(){throw new g("digest")})}generateKey(e,t,r){return h(this,arguments,void 0,function*(){return this.checkGenerateKey.apply(this,arguments),this.onGenerateKey.apply(this,arguments)})}checkGenerateKey(e,t,r){if(this.checkAlgorithmName(e),this.checkGenerateKeyParams(e),!r||!r.length)throw new TypeError("Usages cannot be empty when creating a key.");let n;n=Array.isArray(this.usages)?this.usages:this.usages.privateKey.concat(this.usages.publicKey),this.checkKeyUsages(r,n)}checkGenerateKeyParams(e){}onGenerateKey(e,t,r){return h(this,void 0,void 0,function*(){throw new g("generateKey")})}sign(e,t,r){return h(this,arguments,void 0,function*(){return this.checkSign.apply(this,arguments),this.onSign.apply(this,arguments)})}checkSign(e,t,r){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"sign")}onSign(e,t,r){return h(this,void 0,void 0,function*(){throw new g("sign")})}verify(e,t,r,n){return h(this,arguments,void 0,function*(){return this.checkVerify.apply(this,arguments),this.onVerify.apply(this,arguments)})}checkVerify(e,t,r,n){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"verify")}onVerify(e,t,r,n){return h(this,void 0,void 0,function*(){throw new g("verify")})}encrypt(e,t,r,n){return h(this,arguments,void 0,function*(){return this.checkEncrypt.apply(this,arguments),this.onEncrypt.apply(this,arguments)})}checkEncrypt(e,t,r,n={}){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"encrypt":void 0)}onEncrypt(e,t,r){return h(this,void 0,void 0,function*(){throw new g("encrypt")})}decrypt(e,t,r,n){return h(this,arguments,void 0,function*(){return this.checkDecrypt.apply(this,arguments),this.onDecrypt.apply(this,arguments)})}checkDecrypt(e,t,r,n={}){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"decrypt":void 0)}onDecrypt(e,t,r){return h(this,void 0,void 0,function*(){throw new g("decrypt")})}deriveBits(e,t,r,n){return h(this,arguments,void 0,function*(){return this.checkDeriveBits.apply(this,arguments),this.onDeriveBits.apply(this,arguments)})}checkDeriveBits(e,t,r,n={}){if(this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"deriveBits":void 0),r%8!==0)throw new m("length: Is not multiple of 8")}onDeriveBits(e,t,r){return h(this,void 0,void 0,function*(){throw new g("deriveBits")})}exportKey(e,t){return h(this,arguments,void 0,function*(){return this.checkExportKey.apply(this,arguments),this.onExportKey.apply(this,arguments)})}checkExportKey(e,t){if(this.checkKeyFormat(e),this.checkCryptoKey(t),!t.extractable)throw new y("key: Is not extractable")}onExportKey(e,t){return h(this,void 0,void 0,function*(){throw new g("exportKey")})}importKey(e,t,r,n,s){return h(this,arguments,void 0,function*(){return this.checkImportKey.apply(this,arguments),this.onImportKey.apply(this,arguments)})}checkImportKey(e,t,r,n,s){this.checkKeyFormat(e),this.checkKeyData(e,t),this.checkAlgorithmName(r),this.checkImportParams(r),Array.isArray(this.usages)&&this.checkKeyUsages(s,this.usages)}onImportKey(e,t,r,n,s){return h(this,void 0,void 0,function*(){throw new g("importKey")})}checkAlgorithmName(e){if(e.name.toLowerCase()!==this.name.toLowerCase())throw new p("Unrecognized name")}checkAlgorithmParams(e){}checkDerivedKeyParams(e){}checkKeyUsages(e,t){for(const r of e)if(-1===t.indexOf(r))throw new TypeError("Cannot create a key using the specified key usages")}checkCryptoKey(e,t){if(this.checkAlgorithmName(e.algorithm),t&&-1===e.usages.indexOf(t))throw new y("key does not match that of operation")}checkRequiredProperty(e,t){if(!(t in e))throw new d(t)}checkHashAlgorithm(e,t){for(const r of t)if(r.toLowerCase()===e.name.toLowerCase())return;throw new m(`hash: Must be one of ${t.join(", ")}`)}checkImportParams(e){}checkKeyFormat(e){switch(e){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(e,t){if(!t)throw new TypeError("keyData: Cannot be empty on empty on key importing");if("jwk"===e){if(!k(t))throw new TypeError("keyData: Is not JsonWebToken")}else if(!v.isBufferSource(t))throw new TypeError("keyData: Is not ArrayBufferView or ArrrayBuffer")}prepareData(e){return v.toArrayBuffer(e)}}class b extends w{checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!==typeof e.length)throw new TypeError("length: Is not of type Number");switch(e.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class B extends b{constructor(){super(...arguments),this.name="AES-CBC",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.iv.byteLength)throw new TypeError("iv: Must have length 16 bytes")}}class A extends b{constructor(){super(...arguments),this.name="AES-CTR",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"counter"),!(e.counter instanceof ArrayBuffer||ArrayBuffer.isView(e.counter)))throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.counter.byteLength)throw new TypeError("iv: Must have length 16 bytes");if(this.checkRequiredProperty(e,"length"),"number"!==typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new m("length: Must be more than 0")}}class S extends b{constructor(){super(...arguments),this.name="AES-ECB",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}}class x extends b{constructor(){super(...arguments),this.name="AES-GCM",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength<1)throw new m("iv: Must have length more than 0 and less than 2^64 - 1");switch("tagLength"in e||(e.tagLength=128),e.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new m("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}}class C extends b{constructor(){super(...arguments),this.name="AES-KW",this.usages=["wrapKey","unwrapKey"]}}class N extends w{constructor(){super(...arguments),this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.ivSize){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength!==this.ivSize)throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!==typeof e.length)throw new TypeError("length: Is not of type Number");if(e.length!==this.keySizeBits)throw new m(`algorith.length: Must be ${this.keySizeBits}`)}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class E extends w{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=f.ToBase64(e.publicExponent);if("Aw=="!==t&&"AQAB"!==t)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}class K extends E{constructor(){super(...arguments),this.name="RSASSA-PKCS1-v1_5",this.usages={privateKey:["sign"],publicKey:["verify"]}}}class U extends E{constructor(){super(...arguments),this.name="RSA-PSS",this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"saltLength"),"number"!==typeof e.saltLength)throw new TypeError("saltLength: Is not a Number");if(e.saltLength<1)throw new RangeError("saltLength: Must be more than 0")}}class O extends E{constructor(){super(...arguments),this.name="RSA-OAEP",this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(e){if(e.label&&!(e.label instanceof ArrayBuffer||ArrayBuffer.isView(e.label)))throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}}class L extends w{checkGenerateKeyParams(e){this.checkRequiredProperty(e,"namedCurve"),this.checkNamedCurve(e.namedCurve)}checkNamedCurve(e){for(const t of this.namedCurves)if(t.toLowerCase()===e.toLowerCase())return;throw new m(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`)}}class P extends L{constructor(){super(...arguments),this.name="ECDSA",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}const T=["secret","private","public"];class H{static create(e,t,r,n){const s=new this;return s.algorithm=e,s.type=t,s.extractable=r,s.usages=n,s}static isKeyType(e){return-1!==T.indexOf(e)}}class I extends L{constructor(){super(...arguments),this.name="ECDH",this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]},this.namedCurves=["P-256","P-384","P-521"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"public"),!(e.public instanceof H))throw new TypeError("public: Is not a CryptoKey");if("public"!==e.public.type)throw new m("public: Is not a public key");if(e.public.algorithm.name!==this.name)throw new m(`public: Is not ${this.name} key`)}}class R extends w{constructor(){super(...arguments),this.name="PBKDF2",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!(e.salt instanceof ArrayBuffer||ArrayBuffer.isView(e.salt)))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"iterations"),"number"!==typeof e.iterations)throw new TypeError("iterations: Is not a Number");if(e.iterations<1)throw new TypeError("iterations: Is less than 1")}checkImportKey(e,t,r,n,s){if(super.checkImportKey(e,t,r,n,s),n)throw new SyntaxError("extractable: Must be False")}}class D{}class J{constructor(){this.items={}}get(e){return this.items[e.toLowerCase()]||null}set(e){this.items[e.name.toLowerCase()]=e}removeAt(e){const t=this.get(e.toLowerCase());return t&&delete this.items[e],t}has(e){return!!this.get(e)}get length(){return Object.keys(this.items).length}get algorithms(){const e=[];for(const t in this.items){const r=this.items[t];e.push(r.name)}return e.sort()}}class V{constructor(){this.providers=new J}static isHashedAlgorithm(e){return e instanceof Object&&"name"in e&&"hash"in e}digest(e,t){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,2,"digest");const r=this.prepareAlgorithm(e),n=v.toArrayBuffer(t),s=this.getProvider(r.name);return yield s.digest(r,n)})}generateKey(e,t,r){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"generateKey");const n=this.prepareAlgorithm(e),s=this.getProvider(n.name);return yield s.generateKey(Object.assign({},n,{name:s.name}),t,r)})}sign(e,t,r){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"sign"),this.checkCryptoKey(t);const n=this.prepareAlgorithm(e),s=v.toArrayBuffer(r),i=this.getProvider(n.name);return yield i.sign(Object.assign({},n,{name:i.name}),t,s)})}verify(e,t,r,n){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,4,"verify"),this.checkCryptoKey(t);const s=this.prepareAlgorithm(e),i=v.toArrayBuffer(n),o=v.toArrayBuffer(r),a=this.getProvider(s.name);return yield a.verify(Object.assign({},s,{name:a.name}),t,o,i)})}encrypt(e,t,r){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"encrypt"),this.checkCryptoKey(t);const n=this.prepareAlgorithm(e),s=v.toArrayBuffer(r),i=this.getProvider(n.name);return yield i.encrypt(Object.assign({},n,{name:i.name}),t,s,{keyUsage:!0})})}decrypt(e,t,r){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"decrypt"),this.checkCryptoKey(t);const n=this.prepareAlgorithm(e),s=v.toArrayBuffer(r),i=this.getProvider(n.name);return yield i.decrypt(Object.assign({},n,{name:i.name}),t,s,{keyUsage:!0})})}deriveBits(e,t,r){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"deriveBits"),this.checkCryptoKey(t);const n=this.prepareAlgorithm(e),s=this.getProvider(n.name);return yield s.deriveBits(Object.assign({},n,{name:s.name}),t,r,{keyUsage:!0})})}deriveKey(e,t,r,n,s){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,5,"deriveKey");const i=this.prepareAlgorithm(r);this.getProvider(i.name).checkDerivedKeyParams(i);const o=this.prepareAlgorithm(e),a=this.getProvider(o.name);a.checkCryptoKey(t,"deriveKey");const c=yield a.deriveBits(Object.assign({},o,{name:a.name}),t,r.length,{keyUsage:!1});return this.importKey("raw",c,r,n,s)})}exportKey(e,t){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,2,"exportKey"),this.checkCryptoKey(t);const r=this.getProvider(t.algorithm.name);return yield r.exportKey(e,t)})}importKey(e,t,r,n,s){return h(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,5,"importKey");const i=this.prepareAlgorithm(r),o=this.getProvider(i.name);if(-1!==["pkcs8","spki","raw"].indexOf(e)){const r=v.toArrayBuffer(t);return o.importKey(e,r,Object.assign({},i,{name:o.name}),n,s)}if(!t.kty)throw new TypeError("keyData: Is not JSON");return o.importKey(e,t,Object.assign({},i,{name:o.name}),n,s)})}wrapKey(e,t,r,n){return h(this,void 0,void 0,function*(){let s=yield this.exportKey(e,t);if("jwk"===e){const e=JSON.stringify(s);s=f.FromUtf8String(e)}const i=this.prepareAlgorithm(n),o=v.toArrayBuffer(s),a=this.getProvider(i.name);return a.encrypt(Object.assign({},i,{name:a.name}),r,o,{keyUsage:!1})})}unwrapKey(e,t,r,n,s,i,o){return h(this,void 0,void 0,function*(){const a=this.prepareAlgorithm(n),c=v.toArrayBuffer(t),l=this.getProvider(a.name);let h=yield l.decrypt(Object.assign({},a,{name:l.name}),r,c,{keyUsage:!1});if("jwk"===e)try{h=JSON.parse(f.ToUtf8String(h))}catch(u){const e=new TypeError("wrappedKey: Is not a JSON");throw e.internal=u,e}return this.importKey(e,h,s,i,o)})}checkRequiredArguments(e,t,r){if(e.length!==t)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${t} arguments required, but only ${e.length} present`)}prepareAlgorithm(e){if("string"===typeof e)return{name:e};if(V.isHashedAlgorithm(e)){const t=Object.assign({},e);return t.hash=this.prepareAlgorithm(e.hash),t}return Object.assign({},e)}getProvider(e){const t=this.providers.get(e);if(!t)throw new p("Unrecognized name");return t}checkCryptoKey(e){if(!(e instanceof H))throw new TypeError("Key is not of type 'CryptoKey'")}}function j(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function M(e,t){return e(t={exports:{}},t.exports),t.exports}function F(e,t){let r=0;if(1===e.length)return e[0];for(let n=e.length-1;n>=0;n--)r+=e[e.length-1-n]*Math.pow(2,t*n);return r}function _(e,t,r=-1){const n=r;let s=e,i=0,o=Math.pow(2,t);for(let a=1;a<8;a++){if(e<o){let e;if(n<0)e=new ArrayBuffer(a),i=a;else{if(n<a)return new ArrayBuffer(0);e=new ArrayBuffer(n),i=n}const r=new Uint8Array(e);for(let n=a-1;n>=0;n--){const e=Math.pow(2,n*t);r[i-n-1]=Math.floor(s/e),s-=r[i-n-1]*e}return e}o*=Math.pow(2,t)}return new ArrayBuffer(0)}const $="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",G="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";const z=Math.log(2);var q=Object.freeze({getUTCDate:function(e){return new Date(e.getTime()+6e4*e.getTimezoneOffset())},getParametersValue:function(e,t,r){return e instanceof Object===!1?r:t in e?e[t]:r},bufferToHexCodes:function(e,t=0,r=e.byteLength-t,n=!1){let s="";for(const i of new Uint8Array(e,t,r)){const e=i.toString(16).toUpperCase();1===e.length&&(s+="0"),s+=e,n&&(s+=" ")}return s.trim()},checkBufferParams:function(e,t,r,n){return t instanceof ArrayBuffer===!1?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):n<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-n<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1)},utilFromBase:F,utilToBase:_,utilConcatBuf:function(...e){let t=0,r=0;for(const i of e)t+=i.byteLength;const n=new ArrayBuffer(t),s=new Uint8Array(n);for(const i of e)s.set(new Uint8Array(i),r),r+=i.byteLength;return n},utilConcatView:function(...e){let t=0,r=0;for(const i of e)t+=i.length;const n=new ArrayBuffer(t),s=new Uint8Array(n);for(const i of e)s.set(i,r),r+=i.length;return s},utilDecodeTC:function(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0===(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let o=0;o<this.valueHex.byteLength;o++)r[o]=0;r[0]=128&e[0];const n=F(r,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let o=0;o<this.valueHex.byteLength;o++)i[o]=e[o];return i[0]&=127,F(i,8)-n},utilEncodeTC:function(e){const t=e<0?-1*e:e;let r=128;for(let n=1;n<8;n++){if(t<=r){if(e<0){const e=_(r-t,8,n);return new Uint8Array(e)[0]|=128,e}let s=_(t,8,n),i=new Uint8Array(s);if(128&i[0]){const e=s.slice(0),t=new Uint8Array(e);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return s}r*=Math.pow(2,8)}return new ArrayBuffer(0)},isEqualBuffer:function(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),n=new Uint8Array(t);for(let s=0;s<r.length;s++)if(r[s]!==n[s])return!1;return!0},padNumber:function(e,t){const r=e.toString(10);if(t<r.length)return"";const n=t-r.length,s=new Array(n);for(let i=0;i<n;i++)s[i]="0";return s.join("").concat(r)},toBase64:function(e,t=!1,r=!1,n=!1){let s=0,i=0,o=0,a="";const c=t?G:$;if(n){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;s<e.length;){const t=e.charCodeAt(s++);s>=e.length&&(i=1);const n=e.charCodeAt(s++);s>=e.length&&(o=1);const l=e.charCodeAt(s++),h=t>>2,u=(3&t)<<4|n>>4;let f=(15&n)<<2|l>>6,y=63&l;1===i?f=y=64:1===o&&(y=64),a+=r?64===f?`${c.charAt(h)}${c.charAt(u)}`:64===y?`${c.charAt(h)}${c.charAt(u)}${c.charAt(f)}`:`${c.charAt(h)}${c.charAt(u)}${c.charAt(f)}${c.charAt(y)}`:`${c.charAt(h)}${c.charAt(u)}${c.charAt(f)}${c.charAt(y)}`}return a},fromBase64:function(e,t=!1,r=!1){const n=t?G:$;function s(e){for(let t=0;t<64;t++)if(n.charAt(t)===e)return t;return 64}function i(e){return 64===e?0:e}let o=0,a="";for(;o<e.length;){const t=s(e.charAt(o++)),r=o>=e.length?0:s(e.charAt(o++)),n=o>=e.length?0:s(e.charAt(o++)),c=o>=e.length?0:s(e.charAt(o++)),l=i(t)<<2|i(r)>>4,h=(15&i(r))<<4|i(n)>>2,u=(3&i(n))<<6|i(c);a+=String.fromCharCode(l),64!==n&&(a+=String.fromCharCode(h)),64!==c&&(a+=String.fromCharCode(u))}if(r){let e=-1;for(let t=a.length-1;t>=0;t--)if(0!==a.charCodeAt(t)){e=t;break}a=-1!==e?a.slice(0,e+1):""}return a},arrayBufferToString:function(e){let t="";const r=new Uint8Array(e);for(const n of r)t+=String.fromCharCode(n);return t},stringToArrayBuffer:function(e){const t=e.length,r=new ArrayBuffer(t),n=new Uint8Array(r);for(let s=0;s<t;s++)n[s]=e.charCodeAt(s);return r},nearestPowerOf2:function(e){const t=Math.log(e)/z,r=Math.floor(t),n=Math.round(t);return r===n?r:n},clearProps:function(e,t){for(const r of t)delete e[r]}}),W=M(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.RawData=t.Repeated=t.Any=t.Choice=t.TIME=t.Duration=t.DateTime=t.TimeOfDay=t.DATE=t.GeneralizedTime=t.UTCTime=t.CharacterString=t.GeneralString=t.VisibleString=t.GraphicString=t.IA5String=t.VideotexString=t.TeletexString=t.PrintableString=t.NumericString=t.UniversalString=t.BmpString=t.Utf8String=t.ObjectIdentifier=t.Enumerated=t.Integer=t.BitString=t.OctetString=t.Null=t.Set=t.Sequence=t.Boolean=t.EndOfContent=t.Constructed=t.Primitive=t.BaseBlock=void 0,t.fromBER=oe,t.compareSchema=ae,t.verifySchema=function(e,t){if(t instanceof Object===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=oe(e);if(-1===r.offset)return{verified:!1,result:r.result};return ae(r.result,r.result,t)},t.fromJSON=function(e){};const r=[new Uint8Array([1])],n="0123456789";class s{constructor(e={}){this.blockLength=(0,q.getParametersValue)(e,"blockLength",0),this.error=(0,q.getParametersValue)(e,"error",""),this.warnings=(0,q.getParametersValue)(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:(0,q.bufferToHexCodes)(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const i=e=>(class extends e{constructor(e={}){super(e),this.isHexOnly=(0,q.getParametersValue)(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,r){if(!1===(0,q.checkBufferParams)(this,e,t,r))return-1;return 0===new Uint8Array(e,t,r).length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+r),this.blockLength=r,t+r)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=(0,q.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}});class o extends(i(s)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=(0,q.getParametersValue)(e.idBlock,"isHexOnly",!1),this.valueHex=(0,q.getParametersValue)(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=(0,q.getParametersValue)(e.idBlock,"tagClass",-1),this.tagNumber=(0,q.getParametersValue)(e.idBlock,"tagNumber",-1),this.isConstructed=(0,q.getParametersValue)(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,n=0;switch(this.tagClass){case 1:n|=0;break;case 2:n|=64;break;case 3:n|=128;break;case 4:n|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(n|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;n|=e&=31,r[0]=n}return t}if(!1===this.isHexOnly){const s=(0,q.utilToBase)(this.tagNumber,7),i=new Uint8Array(s),o=s.byteLength;if(t=new ArrayBuffer(o+1),(r=new Uint8Array(t))[0]=31|n,!e){for(let e=0;e<o-1;e++)r[e+1]=128|i[e];r[o]=i[o-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),(r=new Uint8Array(t))[0]=31|n,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,r){if(!1===(0,q.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;switch(192&n[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32===(32&n[0]),this.isHexOnly=!1;const s=31&n[0];if(31!==s)this.tagNumber=s,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&n[e];){if(r[e-1]=127&n[e],++e>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),n=new Uint8Array(e);for(let t=0;t<r.length;t++)n[t]=r[t];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&n[e];const s=new ArrayBuffer(e),i=new Uint8Array(s);for(let n=0;n<e;n++)i[n]=r[n];this.valueHex=new ArrayBuffer(e),(r=new Uint8Array(this.valueHex)).set(i),this.blockLength<=9?this.tagNumber=(0,q.utilFromBase)(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class a extends s{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=(0,q.getParametersValue)(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=(0,q.getParametersValue)(e.lenBlock,"longFormUsed",!1),this.length=(0,q.getParametersValue)(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,r){if(!1===(0,q.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,t+this.blockLength;const s=127&n[0];if(s>8)return this.error="Too big integer",-1;if(s+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const i=new Uint8Array(s);for(let o=0;o<s;o++)i[o]=n[o+1];return 0===i[s-1]&&this.warnings.push("Needlessly long encoded length"),this.length=(0,q.utilFromBase)(i,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=s+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=128),t;if(!0===this.longFormUsed){const n=(0,q.utilToBase)(this.length,8);if(n.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(n.byteLength+1),!0===e)return t;const s=new Uint8Array(n);(r=new Uint8Array(t))[0]=128|n.byteLength;for(let e=0;e<n.byteLength;e++)r[e+1]=s[e];return t}return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class c extends s{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}}class l extends s{constructor(e={},t=c){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new o(e),this.lenBlock=new a(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),n=this.valueBlock.toBER(!0);this.lenBlock.length=n.byteLength;const s=this.lenBlock.toBER(e);let i;if(t=(0,q.utilConcatBuf)(r,s),i=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length),t=(0,q.utilConcatBuf)(t,i),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=(0,q.utilConcatBuf)(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}t.BaseBlock=l;class h extends c{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=(0,q.getParametersValue)(e,"isHexOnly",!0)}fromBER(e,t,r){if(!1===(0,q.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(n.length);const s=new Uint8Array(this.valueHex);for(let i=0;i<n.length;i++)s[i]=n[i];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.valueHex=(0,q.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class u extends l{constructor(e={}){super(e,h),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}t.Primitive=u;class f extends c{constructor(e={}){super(e),this.value=(0,q.getParametersValue)(e,"value",[]),this.isIndefiniteForm=(0,q.getParametersValue)(e,"isIndefiniteForm",!1)}fromBER(e,t,r){const n=t,s=r;if(!1===(0,q.checkBufferParams)(this,e,t,r))return-1;if(0===new Uint8Array(e,t,r).length)return this.warnings.push("Zero buffer length"),t;let i=t;for(;o=this.isIndefiniteForm,a=r,(!0===o?1:a)>0;){const t=ie(e,i,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(i=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===g.blockName())break}var o,a;return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===g.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(n,n+s),i}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);t=(0,q.utilConcatBuf)(t,n)}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let r=0;r<this.value.length;r++)e.value.push(this.value[r].toJSON());return e}}class y extends l{constructor(e={}){super(e,f),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}}t.Constructed=y;class p extends c{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class g extends l{constructor(e={}){super(e,p),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}t.EndOfContent=g;class m extends c{constructor(e={}){if(super(e),this.value=(0,q.getParametersValue)(e,"value",!1),this.isHexOnly=(0,q.getParametersValue)(e,"isHexOnly",!1),"valueHex"in e)this.valueHex=e.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){new Uint8Array(this.valueHex)[0]=255}}fromBER(e,t,r){if(!1===(0,q.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(n.length);const s=new Uint8Array(this.valueHex);for(let i=0;i<n.length;i++)s[i]=n[i];return 0!==q.utilDecodeTC.call(this)?this.value=!0:this.value=!1,this.blockLength=r,t+r}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=(0,q.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class d extends l{constructor(e={}){super(e,m),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}t.Boolean=d;class v extends y{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}t.Sequence=v;class k extends y{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}t.Set=k;class w extends l{constructor(e={}){super(e,s),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}t.Null=w;class b extends(i(f)){constructor(e={}){super(e),this.isConstructed=(0,q.getParametersValue)(e,"isConstructed",!1)}fromBER(e,t,r){let n=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(n=f.prototype.fromBER.call(this,e,t,r)))return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===g.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==B.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,n=super.fromBER(e,t,r),this.blockLength=r;return n}toBER(e=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e?t:0===this.valueHex.byteLength?t:t=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=(0,q.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class B extends l{constructor(e={}){super(e,b),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof B!==!1&&JSON.stringify(this)===JSON.stringify(e)}}t.OctetString=B;class A extends(i(f)){constructor(e={}){super(e),this.unusedBits=(0,q.getParametersValue)(e,"unusedBits",0),this.isConstructed=(0,q.getParametersValue)(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(e,t,r){if(0===r)return t;let n=-1;if(!0===this.isConstructed){if(-1===(n=f.prototype.fromBER.call(this,e,t,r)))return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===g.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==S.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return n}if(!1===(0,q.checkBufferParams)(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);if(this.unusedBits=s[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(s.length-1);const i=new Uint8Array(this.valueHex);for(let o=0;o<r-1;o++)i[o]=s[o+1];return this.blockLength=s.length,t+r}toBER(e=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),n=new Uint8Array(r);n[0]=this.unusedBits;for(let s=0;s<this.valueHex.byteLength;s++)n[s+1]=t[s];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=(0,q.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class S extends l{constructor(e={}){super(e,A),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof S!==!1&&JSON.stringify(this)===JSON.stringify(e)}}t.BitString=S;class x extends(i(c)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=q.utilDecodeTC.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=(0,q.utilEncodeTC)(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,n=0){const s=this.fromBER(e,t,r);if(-1===s)return s;const i=new Uint8Array(this._valueHex);if(0===i[0]&&0!==(128&i[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==n&&this._valueHex.byteLength<n){n-this._valueHex.byteLength>1&&(n=this._valueHex.byteLength+1);const e=new ArrayBuffer(n);new Uint8Array(e).set(i,n-this._valueHex.byteLength),this._valueHex=e.slice(0)}return s}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!==(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0===(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const n=super.fromBER(e,t,r);return-1===n?n:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let n=new Uint8Array(e),s=new Uint8Array(t),i=n.slice(0);const o=i.length-1;let a=s.slice(0);const c=a.length-1;let l=0;let h=0;for(let u=c<o?o:c;u>=0;u--,h++){switch(!0){case h<a.length:l=i[o-h]+a[c-h]+r[0];break;default:l=i[o-h]+r[0]}switch(r[0]=l/10,!0){case h>=i.length:i=(0,q.utilConcatView)(new Uint8Array([l%10]),i);break;default:i[o-h]=l%10}}return r[0]>0&&(i=(0,q.utilConcatView)(r,i)),i.slice(0)}function t(e){if(e>=r.length)for(let t=r.length;t<=e;t++){const e=new Uint8Array([0]);let n=r[t-1].slice(0);for(let t=n.length-1;t>=0;t--){const r=new Uint8Array([(n[t]<<1)+e[0]]);e[0]=r[0]/10,n[t]=r[0]%10}e[0]>0&&(n=(0,q.utilConcatView)(e,n)),r.push(n)}return r[e]}function s(e,t){let r=0,n=new Uint8Array(e),s=new Uint8Array(t),i=n.slice(0);const o=i.length-1;let a=s.slice(0);const c=a.length-1;let l,h=0;for(let u=c;u>=0;u--,h++)switch(l=i[o-h]-a[c-h]-r,!0){case l<0:r=1,i[o-h]=l+10;break;default:r=0,i[o-h]=l}if(r>0)for(let u=o-c+1;u>=0;u--,h++){if(!((l=i[o-h]-r)<0)){r=0,i[o-h]=l;break}r=1,i[o-h]=l+10}return i.slice()}const i=8*this._valueHex.byteLength-1;let o,a=new Uint8Array(8*this._valueHex.byteLength/3),c=0;const l=new Uint8Array(this._valueHex);let h="",u=!1;for(let r=this._valueHex.byteLength-1;r>=0;r--){o=l[r];for(let r=0;r<8;r++){if(1===(1&o))switch(c){case i:a=s(t(c),a),h="-";break;default:a=e(a,t(c))}c++,o>>=1}}for(let r=0;r<a.length;r++)a[r]&&(u=!0),u&&(h+=n.charAt(a[r]));return!1===u&&(h+=n.charAt(0)),h}}class C extends l{constructor(e={}){super(e,x),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof C?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?(0,q.isEqualBuffer)(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&(0,q.isEqualBuffer)(this.valueBlock.valueHex,e)}convertToDER(){const e=new C({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new C({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}t.Integer=C;class N extends C{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}t.Enumerated=N;class E extends(i(s)){constructor(e={}){super(e),this.valueDec=(0,q.getParametersValue)(e,"valueDec",-1),this.isFirstSid=(0,q.getParametersValue)(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===(0,q.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let s=new Uint8Array(this.valueHex);for(let a=0;a<r&&(s[a]=127&n[a],this.blockLength++,0!==(128&n[a]));a++);const i=new ArrayBuffer(this.blockLength),o=new Uint8Array(i);for(let a=0;a<this.blockLength;a++)o[a]=s[a];return this.valueHex=i.slice(0),s=new Uint8Array(this.valueHex),0!==(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===s[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,q.utilFromBase)(s,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const n=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|n[e];return r[this.blockLength-1]=n[this.blockLength-1],t}const n=(0,q.utilToBase)(this.valueDec,7);if(0===n.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(n.byteLength),!1===e){const e=new Uint8Array(n);r=new Uint8Array(t);for(let t=0;t<n.byteLength-1;t++)r[t]=128|e[t];r[n.byteLength-1]=e[n.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=(0,q.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class K extends c{constructor(e={}){super(e),this.fromString((0,q.getParametersValue)(e,"value",""))}fromBER(e,t,r){let n=t;for(;r>0;){const t=new E;if(-1===(n=t.fromBER(e,n,r)))return this.blockLength=0,this.error=t.error,n;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return n}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);if(0===n.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=(0,q.utilConcatBuf)(t,n)}return t}fromString(e){this.value=[];let t=0,r=0,n="",s=!1;do{if(n=-1===(r=e.indexOf(".",t))?e.substr(t):e.substr(t,r-t),t=r+1,s){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(n,10);if(isNaN(r))return!0;e.valueDec=r+t,s=!1}else{const e=new E;if(e.valueDec=parseInt(n,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,s=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(e=`${e}.`),t?(n=`{${n}}`,this.value[r].isFirstSid?e=`2.{${n} - 80}`:e+=n):e+=n}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}e.value=this.toString(),e.sidArray=[];for(let r=0;r<this.value.length;r++)e.sidArray.push(this.value[r].toJSON());return e}}class U extends l{constructor(e={}){super(e,K),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}t.ObjectIdentifier=U;class O extends(i(s)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e}}class L extends l{constructor(e={}){super(e,O),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const n=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<r;s++)n[s]=t.charCodeAt(s);this.valueBlock.value=e}}t.Utf8String=L;class P extends(i(s)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e}}class T extends l{constructor(e={}){super(e,P),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let n=0;n<r.length;n+=2){const e=r[n];r[n]=r[n+1],r[n+1]=e}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<t;n++){const t=(0,q.utilToBase)(e.charCodeAt(n),8),s=new Uint8Array(t);if(s.length>2)continue;const i=2-s.length;for(let e=s.length-1;e>=0;e--)r[2*n+e+i]=s[e]}this.valueBlock.value=e}}t.BmpString=T;class H extends(i(s)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e}}class I extends l{constructor(e={}){super(e,H),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let n=0;n<r.length;n+=4)r[n]=r[n+3],r[n+1]=r[n+2],r[n+2]=0,r[n+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<t;n++){const t=(0,q.utilToBase)(e.charCodeAt(n),8),s=new Uint8Array(t);if(s.length>4)continue;const i=4-s.length;for(let e=s.length-1;e>=0;e--)r[4*n+e+i]=s[e]}this.valueBlock.value=e}}t.UniversalString=I;class R extends(i(s)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e}}class D extends l{constructor(e={}){super(e,R),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);this.valueBlock.value=e}}class J extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}t.NumericString=J;class V extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}t.PrintableString=V;class j extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}t.TeletexString=j;class M extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}t.VideotexString=M;class F extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}t.IA5String=F;class _ extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}t.GraphicString=_;class $ extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}t.VisibleString=$;class G extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}t.GeneralString=G;class z extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}t.CharacterString=z;class W extends ${constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for convertion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(){const e=new Array(7);return e[0]=(0,q.padNumber)(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=(0,q.padNumber)(this.month,2),e[2]=(0,q.padNumber)(this.day,2),e[3]=(0,q.padNumber)(this.hour,2),e[4]=(0,q.padNumber)(this.minute,2),e[5]=(0,q.padNumber)(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}t.UTCTime=W;class Z extends ${constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,n="",s="",i=0,o=0,a=0;if("Z"===e[e.length-1])n=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");n=e}if(r){if(-1!==n.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==n.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=n.indexOf("+"),r="";if(-1===t&&(t=n.indexOf("-"),e=-1),-1!==t){if(r=n.substr(t+1),n=n.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let s=new Number(r.substr(0,2));if(isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");if(o=e*s,4===r.length){if(s=new Number(r.substr(2,2)),isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");a=e*s}}}let c=n.indexOf(".");if(-1===c&&(c=n.indexOf(",")),-1!==c){const e=new Number(`0${n.substr(c)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");i=e.valueOf(),s=n.substr(0,c)}else s=n;switch(!0){case 8===s.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for convertion");break;case 10===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){const e=1e3*i;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const l=t.exec(s);if(null===l)throw new Error("Wrong input string for convertion");for(let h=1;h<l.length;h++)switch(h){case 1:this.year=parseInt(l[h],10);break;case 2:this.month=parseInt(l[h],10);break;case 3:this.day=parseInt(l[h],10);break;case 4:this.hour=parseInt(l[h],10)+o;break;case 5:this.minute=parseInt(l[h],10)+a;break;case 6:this.second=parseInt(l[h],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push((0,q.padNumber)(this.year,4)),e.push((0,q.padNumber)(this.month,2)),e.push((0,q.padNumber)(this.day,2)),e.push((0,q.padNumber)(this.hour,2)),e.push((0,q.padNumber)(this.minute,2)),e.push((0,q.padNumber)(this.second,2)),0!==this.millisecond&&(e.push("."),e.push((0,q.padNumber)(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}t.GeneralizedTime=Z;class X extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}t.DATE=X;class Y extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}t.TimeOfDay=Y;class Q extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}t.DateTime=Q;class ee extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}t.Duration=ee;class te extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}t.TIME=te;class re{constructor(e={}){this.value=(0,q.getParametersValue)(e,"value",[]),this.optional=(0,q.getParametersValue)(e,"optional",!1)}}t.Choice=re;class ne{constructor(e={}){this.name=(0,q.getParametersValue)(e,"name",""),this.optional=(0,q.getParametersValue)(e,"optional",!1)}}t.Any=ne;class se{constructor(e={}){this.name=(0,q.getParametersValue)(e,"name",""),this.optional=(0,q.getParametersValue)(e,"optional",!1),this.value=(0,q.getParametersValue)(e,"value",new ne),this.local=(0,q.getParametersValue)(e,"local",!1)}}t.Repeated=se;function ie(e,t,r){const n=t;let i=new l({},Object);if(!1===(0,q.checkBufferParams)(new s,e,t,r))return i.error="Wrong input parameters",{offset:-1,result:i};if(0===new Uint8Array(e,t,r).length)return this.error="Zero buffer length",{offset:-1,result:i};let o=i.idBlock.fromBER(e,t,r);if(i.warnings.concat(i.idBlock.warnings),-1===o)return i.error=i.idBlock.error,{offset:-1,result:i};if(t=o,r-=i.idBlock.blockLength,o=i.lenBlock.fromBER(e,t,r),i.warnings.concat(i.lenBlock.warnings),-1===o)return i.error=i.lenBlock.error,{offset:-1,result:i};if(t=o,r-=i.lenBlock.blockLength,!1===i.idBlock.isConstructed&&!0===i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let a=l;switch(i.idBlock.tagClass){case 1:if(i.idBlock.tagNumber>=37&&!1===i.idBlock.isHexOnly)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(!0===i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};a=g;break;case 1:a=d;break;case 2:a=C;break;case 3:a=S;break;case 4:a=B;break;case 5:a=w;break;case 6:a=U;break;case 10:a=N;break;case 12:a=L;break;case 14:a=te;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:a=v;break;case 17:a=k;break;case 18:a=J;break;case 19:a=V;break;case 20:a=j;break;case 21:a=M;break;case 22:a=F;break;case 23:a=W;break;case 24:a=Z;break;case 25:a=_;break;case 26:a=$;break;case 27:a=G;break;case 28:a=I;break;case 29:a=z;break;case 30:a=T;break;case 31:a=X;break;case 32:a=Y;break;case 33:a=Q;break;case 34:a=ee;break;default:{let n;(n=!0===i.idBlock.isConstructed?new y:new u).idBlock=i.idBlock,n.lenBlock=i.lenBlock,n.warnings=i.warnings,o=(i=n).fromBER(e,t,r)}}break;case 2:case 3:case 4:default:a=!0===i.idBlock.isConstructed?y:u}return o=(i=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(i,a)).fromBER(e,t,!0===i.lenBlock.isIndefiniteForm?r:i.lenBlock.length),i.valueBeforeDecode=e.slice(n,n+i.blockLength),{offset:o,result:i}}function oe(e){if(0===e.byteLength){const e=new l({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ie(e,0,e.byteLength)}function ae(e,t,r){if(r instanceof re){for(let n=0;n<r.value.length;n++){if(!0===ae(e,t,r.value[n]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(e.name=r.name),e}}if(r instanceof ne)return r.hasOwnProperty("name")&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object===!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object===!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=r.idBlock.toBER(!1);if(0===n.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(n,0,n.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if("isHexOnly"in r.idBlock===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=new Uint8Array(r.idBlock.valueHex),s=new Uint8Array(t.idBlock.valueHex);if(n.length!==s.length)return{verified:!1,result:e};for(let t=0;t<n.length;t++)if(n[t]!==s[1])return{verified:!1,result:e}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(e[r.name]=t)),!0===r.idBlock.isConstructed){let n=0,s={verified:!1},i=r.valueBlock.value.length;if(i>0&&r.valueBlock.value[0]instanceof se&&(i=t.valueBlock.value.length),0===i)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return!0===t?{verified:!0,result:e}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let o=0;o<i;o++)if(o-n>=t.valueBlock.value.length){if(!1===r.valueBlock.value[o].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof se){if(!1===(s=ae(e,t.valueBlock.value[o],r.valueBlock.value[0].value)).verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),s;n++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let n={};"undefined"===typeof(n="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?t:e)[r.valueBlock.value[0].name]&&(n[r.valueBlock.value[0].name]=[]),n[r.valueBlock.value[0].name].push(t.valueBlock.value[o])}}else if(!1===(s=ae(e,t.valueBlock.value[o-n],r.valueBlock.value[o])).verified){if(!0!==r.valueBlock.value[o].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),s;n++}if(!1===s.verified){const t={verified:!1,result:e};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if("primitiveSchema"in r&&"valueHex"in t.valueBlock){const n=oe(t.valueBlock.valueHex);if(-1===n.offset){const t={verified:!1,result:n.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return ae(e,n.result,r.primitiveSchema)}return{verified:!0,result:e}}t.RawData=class{constructor(e={}){this.data=(0,q.getParametersValue)(e,"data",new ArrayBuffer(0))}fromBER(e,t,r){return this.data=e.slice(t,r),t+r}toBER(e=!1){return this.data}}});j(W);W.RawData,W.Repeated,W.Any,W.Choice,W.TIME,W.Duration,W.DateTime,W.TimeOfDay,W.DATE,W.GeneralizedTime,W.UTCTime,W.CharacterString,W.GeneralString,W.VisibleString,W.GraphicString,W.IA5String,W.VideotexString,W.TeletexString,W.PrintableString,W.NumericString,W.UniversalString,W.BmpString,W.Utf8String,W.ObjectIdentifier,W.Enumerated;var Z=W.Integer,X=(W.BitString,W.OctetString,W.Null,W.Set,W.Sequence,W.Boolean,W.EndOfContent,W.Constructed,W.Primitive,W.BaseBlock,W.fromBER,W.compareSchema,W.verifySchema,W.fromJSON,M(function(t,r){Object.defineProperty(r,"__esModule",{value:!0});const n={fromASN:e=>e instanceof W.Null?null:e.valueBeforeDecode,toASN:e=>{if(null===e)return new W.Null;const t=W.fromBER(e);if(t.result.error)throw new Error(t.result.error);return t.result}},i={fromASN:e=>!e.valueBlock.valueDec&&e.valueBlock.valueHex.byteLength>0?e.valueBlock.toString():e.valueBlock.valueDec,toASN:e=>new W.Integer({value:e})},o={fromASN:e=>e.valueBlock.valueDec,toASN:e=>new W.Enumerated({value:e})},a={fromASN:e=>e.valueBlock.valueHex,toASN:e=>new W.Integer({valueHex:e})},c={fromASN:e=>e.valueBlock.valueHex,toASN:e=>new W.BitString({valueHex:e})},l={fromASN:e=>e.valueBlock.toString(),toASN:e=>new W.ObjectIdentifier({value:e})},h={fromASN:e=>e.valueBlock.value,toASN:e=>new W.Boolean({value:e})},u={fromASN:e=>e.valueBlock.valueHex,toASN:e=>new W.OctetString({valueHex:e})};function f(e){return{fromASN:e=>e.valueBlock.value,toASN:t=>new e({value:t})}}const y=f(W.Utf8String),p=f(W.BmpString),g=f(W.UniversalString),m=f(W.NumericString),d=f(W.PrintableString),v=f(W.TeletexString),k=f(W.VideotexString),w=f(W.IA5String),b=f(W.GraphicString),B=f(W.VisibleString),A=f(W.GeneralString),S=f(W.CharacterString),x={fromASN:e=>e.toDate(),toASN:e=>new W.UTCTime({valueDate:e})},C={fromASN:e=>e.toDate(),toASN:e=>new W.GeneralizedTime({valueDate:e})};var N,E,K=Object.freeze({AsnAnyConverter:n,AsnIntegerConverter:i,AsnEnumeratedConverter:o,AsnIntegerArrayBufferConverter:a,AsnBitStringConverter:c,AsnObjectIdentifierConverter:l,AsnBooleanConverter:h,AsnOctetStringConverter:u,AsnUtf8StringConverter:y,AsnBmpStringConverter:p,AsnUniversalStringConverter:g,AsnNumericStringConverter:m,AsnPrintableStringConverter:d,AsnTeletexStringConverter:v,AsnVideotexStringConverter:k,AsnIA5StringConverter:w,AsnGraphicStringConverter:b,AsnVisibleStringConverter:B,AsnGeneralStringConverter:A,AsnCharacterStringConverter:S,AsnUTCTimeConverter:x,AsnGeneralizedTimeConverter:C});(N=r.AsnTypeTypes||(r.AsnTypeTypes={}))[N.Sequence=0]="Sequence",N[N.Set=1]="Set",N[N.Choice=2]="Choice",(E=r.AsnPropTypes||(r.AsnPropTypes={}))[E.Any=0]="Any",E[E.Boolean=1]="Boolean",E[E.OctetString=2]="OctetString",E[E.BitString=3]="BitString",E[E.Integer=4]="Integer",E[E.Enumerated=5]="Enumerated",E[E.ObjectIdentifier=6]="ObjectIdentifier",E[E.Utf8String=7]="Utf8String",E[E.BmpString=8]="BmpString",E[E.UniversalString=9]="UniversalString",E[E.NumericString=10]="NumericString",E[E.PrintableString=11]="PrintableString",E[E.TeletexString=12]="TeletexString",E[E.VideotexString=13]="VideotexString",E[E.IA5String=14]="IA5String",E[E.GraphicString=15]="GraphicString",E[E.VisibleString=16]="VisibleString",E[E.GeneralString=17]="GeneralString",E[E.CharacterString=18]="CharacterString",E[E.UTCTime=19]="UTCTime",E[E.GeneralizedTime=20]="GeneralizedTime",E[E.DATE=21]="DATE",E[E.TimeOfDay=22]="TimeOfDay",E[E.DateTime=23]="DateTime",E[E.Duration=24]="Duration",E[E.TIME=25]="TIME",E[E.Null=26]="Null";const U=W;const O=new class{constructor(){this.items=new Map}has(e){return this.items.has(e)}get(e){const t=this.items.get(e);if(!t)throw new Error("Cannot get schema for current target");return t}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const t={type:r.AsnTypeTypes.Sequence,items:{}},n=this.findParentSchema(e);return n&&(Object.assign(t,n),t.items=Object.assign({},t.items,n.items)),t}create(e,t){const n=this.items.get(e)||this.createDefault(e),s=[];for(const i in n.items){const e=n.items[i],o=t?i:"";let a;if("number"===typeof e.type){const t=r.AsnPropTypes[e.type],n=U[t];if(!n)throw new Error(`Cannot get ASN1 class by name '${t}'`);a=new n({name:o})}else a=new U.Any({name:o});const c=!!e.optional||void 0!==e.defaultValue;if(e.repeated&&(a.name="",a=new U.Repeated({name:o,value:a})),null!==e.context&&void 0!==e.context)if(e.implicit)if("number"===typeof e.type)s.push(new U.Primitive({name:o,optional:c,idBlock:{tagClass:3,tagNumber:e.context}}));else{this.cache(e.type);const t=this.get(e.type).schema.valueBlock.value;s.push(new U.Constructed({name:o,optional:c,idBlock:{tagClass:3,tagNumber:e.context},value:t}))}else s.push(new U.Constructed({optional:c,idBlock:{tagClass:3,tagNumber:e.context},value:[a]}));else a.optional=c,s.push(a)}switch(n.type){case r.AsnTypeTypes.Sequence:return new U.Sequence({value:s,name:""});case r.AsnTypeTypes.Set:return new U.Set({value:s,name:""});case r.AsnTypeTypes.Choice:return new U.Choice({value:s,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;return t?this.items.get(t)||this.findParentSchema(t):null}};function L(e){return e&&e.prototype?!(!e.prototype.toASN||!e.prototype.fromASN)||L(e.prototype):!!(e&&e.toASN&&e.fromASN)}const P=W;const T=W;r.AsnProp=(e=>(t,n)=>{let s;O.has(t.constructor)?s=O.get(t.constructor):(s=O.createDefault(t.constructor),O.set(t.constructor,s));const i=Object.assign({},e);if("number"===typeof i.type&&!i.converter){const s=`Asn${r.AsnPropTypes[e.type]}Converter`,o=K[s];if(!o)throw new Error(`Cannot get '${s}' for property '${n}' of ${t.constructor.name}`);i.converter=o}s.items[n]=i}),r.AsnType=(e=>t=>{const r=O.get(t);Object.assign(r,e)}),r.AsnParser=class{static parse(t,r,n){let s;if(t instanceof ArrayBuffer)s=t;else if(void 0!==typeof e&&e.isBuffer(t))s=new Uint8Array(t).buffer;else{if(!ArrayBuffer.isView(t))throw new TypeError("Wrong type of 'data' argument");s=t.buffer}const i=P.fromBER(s);if(i.result.error)throw new Error(i.result.error);return this.fromASN(i.result,r,n)}static fromASN(e,t,n){if(L(t))return(n||new t).fromASN(e);const s=O.get(t);O.cache(t);let i=s.schema;if(e.constructor===P.Constructed&&s.type!==r.AsnTypeTypes.Choice){i=new P.Constructed({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:s.schema.valueBlock.value});for(const t in s.items)delete e[t]}const o=P.compareSchema(e,e,i);if(!o.verified)throw new Error(`Data does not match to ${t.name} ASN1 schema. ${o.result.error}`);const a=n||new t;for(const c in s.items){if(!e[c])continue;const t=s.items[c];if("number"===typeof t.type){const n=t.converter;if(!n)throw new Error("Converter is empty");if(t.repeated)a[c]=Array.from(e[c],e=>n.fromASN(e));else{let s=e[c];if(t.implicit){const e=r.AsnPropTypes[t.type],n=P[e];if(!n)throw new Error(`Cannot get '${e}' class from asn1js module`);const i=new n;i.valueBlock=s.valueBlock,s=P.fromBER(i.toBER(!1)).result}a[c]=n.fromASN(s)}}else t.repeated?a[c]=Array.from(e[c],e=>this.fromASN(e,t.type)):a[c]=this.fromASN(e[c],t.type)}return a._cache={asn1:e},a}},r.AsnSerializer=class{static serialize(e){return this.toASN(e).toBER(!1)}static toASN(e){if(e&&L(e.constructor))return e.toASN();const t=e.constructor,n=O.get(t);O.cache(t);let i,o=[];for(const a in n.items){const i=n.items[a],c=e[a];if(void 0===c||i.defaultValue===c)continue;let l;if("number"===typeof i.type){const e=i.converter;if(!e)throw new Error(`Property '${a}' doesn't have converter for type ${r.AsnPropTypes[i.type]} in schema '${t.name}'`);l=i.repeated?Array.from(c,t=>e.toASN(t)):e.toASN(c)}else l=i.repeated?Array.from(c,e=>this.toASN(e)):this.toASN(c);if(null!==i.context&&void 0!==i.context)if(i.implicit)if("number"===typeof i.type){const e={};e.valueHex=l.valueBlock.toBER(),o.push(new T.Primitive(s({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context}},e)))}else o.push(new T.Constructed({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:l.valueBlock.value}));else o.push(new T.Constructed({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:[l]}));else i.repeated?o=o.concat(l):o.push(l)}switch(n.type){case r.AsnTypeTypes.Sequence:i=new T.Sequence({value:o});break;case r.AsnTypeTypes.Set:i=new T.Set({value:o});break;case r.AsnTypeTypes.Choice:if(!o[0])throw new Error(`Schema '${t.name}' has wrong data. Choice cannot be empty.`);i=o[0]}return i}},r.AsnAnyConverter=n,r.AsnIntegerConverter=i,r.AsnEnumeratedConverter=o,r.AsnIntegerArrayBufferConverter=a,r.AsnBitStringConverter=c,r.AsnObjectIdentifierConverter=l,r.AsnBooleanConverter=h,r.AsnOctetStringConverter=u,r.AsnUtf8StringConverter=y,r.AsnBmpStringConverter=p,r.AsnUniversalStringConverter=g,r.AsnNumericStringConverter=m,r.AsnPrintableStringConverter=d,r.AsnTeletexStringConverter=v,r.AsnVideotexStringConverter=k,r.AsnIA5StringConverter=w,r.AsnGraphicStringConverter=b,r.AsnVisibleStringConverter=B,r.AsnGeneralStringConverter=A,r.AsnCharacterStringConverter=S,r.AsnUTCTimeConverter=x,r.AsnGeneralizedTimeConverter=C}));j(X);var Y=X.AsnTypeTypes,Q=X.AsnPropTypes,ee=X.AsnProp,te=X.AsnType,re=X.AsnParser,ne=X.AsnSerializer,se=(X.AsnAnyConverter,X.AsnIntegerConverter),ie=(X.AsnEnumeratedConverter,X.AsnIntegerArrayBufferConverter,X.AsnBitStringConverter,X.AsnObjectIdentifierConverter,X.AsnBooleanConverter,X.AsnOctetStringConverter,X.AsnUtf8StringConverter,X.AsnBmpStringConverter,X.AsnUniversalStringConverter,X.AsnNumericStringConverter,X.AsnPrintableStringConverter,X.AsnTeletexStringConverter,X.AsnVideotexStringConverter,X.AsnIA5StringConverter,X.AsnGraphicStringConverter,X.AsnVisibleStringConverter,X.AsnGeneralStringConverter,X.AsnCharacterStringConverter,X.AsnUTCTimeConverter,X.AsnGeneralizedTimeConverter,M(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});class r extends Error{constructor(e,t){super(t?`${e}. See the inner exception for more details.`:e),this.message=e,this.innerError=t}}class n extends r{constructor(e,t,r){super(t,r),this.schema=e}}class i extends n{constructor(e,t,r){super(e,`JSON doesn't match to '${e.target.name}' schema. ${t}`,r)}}class o extends r{}class a extends r{constructor(e,t,r){super(`Cannot serialize by '${e}' schema. ${t}`,r),this.schemaName=e}}class c extends i{constructor(e,t,r={}){super(e,"Some keys doesn't match to schema"),this.keys=t,this.errors=r}}var l;function h(e,r){if(!function(e,r){switch(r){case t.JsonPropTypes.Boolean:return"boolean"===typeof e;case t.JsonPropTypes.Number:return"number"===typeof e;case t.JsonPropTypes.String:return"string"===typeof e}return!0}(e,r))throw new TypeError(`Value must be ${t.JsonPropTypes[r]}`)}function u(e){return e&&e.prototype?!(!e.prototype.toJSON||!e.prototype.fromJSON)||u(e.prototype):!!(e&&e.toJSON&&e.fromJSON)}(l=t.JsonPropTypes||(t.JsonPropTypes={}))[l.Any=0]="Any",l[l.Boolean=1]="Boolean",l[l.Number=2]="Number",l[l.String=3]="String";const f="default",y=new class{constructor(){this.items=new Map}has(e){return this.items.has(e)||!!this.findParentSchema(e)}get(e){const t=this.items.get(e)||this.findParentSchema(e);if(!t)throw new Error("Cannot get schema for current target");return t}create(e){const t={names:{}},r=this.findParentSchema(e);if(r){Object.assign(t,r),t.names={};for(const e in r.names)t.names[e]=Object.assign({},r.names[e])}return t.target=e,t}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;return t?this.items.get(t)||this.findParentSchema(t):null}};class p{constructor(e){this.pattern=new RegExp(e)}validate(e){const t=new RegExp(this.pattern.source,this.pattern.flags);if("string"!==typeof e)throw new o("Incoming value must be string");if(!t.exec(e))throw new o(`Value doesn't match to pattern '${t.toString()}'`)}}class g{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(h(e,t.JsonPropTypes.Number),!(this.min<=e&&e<=this.max)){const e=this.min===Number.MIN_VALUE?"MIN":this.min,t=this.max===Number.MAX_VALUE?"MAX":this.max;throw new o(`Value doesn't match to diapason [${e},${t}]`)}}}class m{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(h(e,t.JsonPropTypes.Number),!(this.min<e&&e<this.max)){const e=this.min===Number.MIN_VALUE?"MIN":this.min,t=this.max===Number.MAX_VALUE?"MAX":this.max;throw new o(`Value doesn't match to diapason (${e},${t})`)}}}class d{constructor(e,t,r){this.length=e,this.minLength=t,this.maxLength=r}validate(e){if(void 0===this.length){if(void 0!==this.minLength&&e.length<this.minLength)throw new o(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&e.length>this.maxLength)throw new o(`Value length must be less than ${this.maxLength}.`)}else if(e.length!==this.length)throw new o(`Value length must be exactly ${this.length}.`)}}class v{constructor(e){this.enumeration=e}validate(e){if(h(e,t.JsonPropTypes.String),!this.enumeration.includes(e))throw new o(`Value must be one of ${this.enumeration.map(e=>`'${e}'`).join(", ")}`)}}class k{static checkValues(e,t){const r=Array.isArray(e)?e:[e];for(const n of r)for(const r of t.validations)r instanceof d&&t.repeated?r.validate(e):r.validate(n)}static checkTypes(e,t){if(t.repeated&&!Array.isArray(e))throw new TypeError("Value must be Array");if("number"===typeof t.type){const r=Array.isArray(e)?e:[e];for(const e of r)h(e,t.type)}}static getSchemaByName(e,t=f){return s({},e.names[f],e.names[t])}}class w extends k{static parse(e,t){const r=JSON.parse(e);return this.fromJSON(r,t)}static fromJSON(e,t){const r=t.targetSchema,n=t.schemaName||f,o=new r;if(u(o))return o.fromJSON(e);const a=y.get(r),l=this.getSchemaByName(a,n),h={};t.strictProperty&&!Array.isArray(e)&&w.checkStrictProperty(e,l,a);for(const c in l)try{const r=l[c],u=r.name||c,f=e[u];if(void 0===f&&(r.optional||void 0!==r.defaultValue))continue;if(!r.optional&&void 0===f)throw new i(a,`Property '${u}' is required.`);if(this.checkTypes(f,r),this.checkValues(f,r),"number"===typeof r.type)r.converter?r.repeated?o[c]=f.map(e=>r.converter.fromJSON(e,o)):o[c]=r.converter.fromJSON(f,o):o[c]=f;else{const e=s({},t,{targetSchema:r.type,schemaName:n});r.repeated?o[c]=f.map(t=>this.fromJSON(t,e)):o[c]=this.fromJSON(f,e)}}catch(g){if(g instanceof i||(g=new i(a,`Property '${c}' is wrong. ${g.message}`,g)),!t.strictAllKeys)throw g;h[c]=g}const p=Object.keys(h);if(p.length)throw new c(a,p,h);return o}static checkStrictProperty(e,t,r){const n=Object.keys(e),s=Object.keys(t),i=[];for(const o of n)-1===s.indexOf(o)&&i.push(o);if(i.length)throw new c(r,i)}}t.JsonSerializer=class extends k{static serialize(e,t,r,n){const s=this.toJSON(e,t);return JSON.stringify(s,r,n)}static toJSON(e,t={}){let n,s=t.targetSchema;const i=t.schemaName||f;if(u(e))return e.toJSON();if(Array.isArray(e)){n=[];for(const r of e)n.push(this.toJSON(r,t))}else if("object"===typeof e){if(s&&!y.has(s))throw new r("Cannot get schema for `targetSchema` param");if(s=s||e.constructor,y.has(s)){const t=y.get(s);n={};const r=this.getSchemaByName(t,i);for(const c in r)try{const l=r[c],h=e[c];let u;if(l.optional&&void 0===h||void 0!==l.defaultValue&&h===l.defaultValue)continue;if(!l.optional&&void 0===h)throw new a(s.name,`Property '${c}' is required.`);u="number"===typeof l.type?l.converter?l.repeated?h.map(t=>l.converter.toJSON(t,e)):l.converter.toJSON(h,e):h:l.repeated?h.map(e=>this.toJSON(e,{schemaName:i})):this.toJSON(h,{schemaName:i}),this.checkTypes(u,l),this.checkValues(u,l),n[l.name||c]=u}catch(o){throw o instanceof a?o:new a(t.target.name,`Property '${c}' is wrong. ${o.message}`,o)}}else{n={};for(const t in e)n[t]=this.toJSON(e[t],{schemaName:i})}}else n=e;return n}},t.JsonParser=w,t.JsonProp=((e={})=>(r,n)=>{const s=`Cannot set type for ${n} property of ${r.constructor.name} schema`;let i;y.has(r.constructor)?(i=y.get(r.constructor)).target!==r.constructor&&(i=y.create(r.constructor),y.set(r.constructor,i)):(i=y.create(r.constructor),y.set(r.constructor,i));const o={type:t.JsonPropTypes.Any,validations:[]},a=Object.assign(o,e);if(a.validations=function(e){const r=[];return e.pattern&&r.push(new p(e.pattern)),e.type!==t.JsonPropTypes.Number&&e.type!==t.JsonPropTypes.Any||(void 0===e.minInclusive&&void 0===e.maxInclusive||r.push(new g(e.minInclusive,e.maxInclusive)),void 0===e.minExclusive&&void 0===e.maxExclusive||r.push(new m(e.minExclusive,e.maxExclusive)),void 0!==e.enumeration&&r.push(new v(e.enumeration))),(e.type===t.JsonPropTypes.String||e.repeated||e.type===t.JsonPropTypes.Any)&&(void 0===e.length&&void 0===e.minLength&&void 0===e.maxLength||r.push(new d(e.length,e.minLength,e.maxLength))),r}(a),"number"!==typeof a.type&&!y.has(a.type)&&!u(a.type))throw new Error(`${s}. Assigning type doesn't have schema.`);let c;c=Array.isArray(e.schema)?e.schema:[e.schema||f];for(const e of c)i.names[e]||(i.names[e]={}),i.names[e][n]=a})}));j(ie);ie.JsonPropTypes;var oe=ie.JsonSerializer,ae=ie.JsonParser,ce=ie.JsonProp;let le=class{constructor(e){e&&(this.value=e)}};l([ee({type:Q.ObjectIdentifier})],le.prototype,"value",void 0),le=l([te({type:Y.Choice})],le);class he{constructor(e){Object.assign(this,e)}}l([ee({type:Q.ObjectIdentifier})],he.prototype,"algorithm",void 0),l([ee({type:Q.Any,optional:!0})],he.prototype,"parameters",void 0);class ue{constructor(){this.version=0,this.privateKeyAlgorithm=new he,this.privateKey=new ArrayBuffer(0)}}l([ee({type:Q.Integer})],ue.prototype,"version",void 0),l([ee({type:he})],ue.prototype,"privateKeyAlgorithm",void 0),l([ee({type:Q.OctetString})],ue.prototype,"privateKey",void 0),l([ee({type:Q.Any,optional:!0})],ue.prototype,"attributes",void 0);class fe{constructor(){this.publicKeyAlgorithm=new he,this.publicKey=new ArrayBuffer(0)}}l([ee({type:he})],fe.prototype,"publicKeyAlgorithm",void 0),l([ee({type:Q.BitString})],fe.prototype,"publicKey",void 0);const ye={fromJSON:e=>f.FromBase64Url(e),toJSON:e=>f.ToBase64Url(new Uint8Array(e))};var pe;function ge(...e){const t=new Uint8Array(e.map(e=>e.length).reduce((e,t)=>e+t));let r=0;return e.forEach((e,n)=>{for(let s=0;s<e.length;s++)t[r+s]=e[s];r+=e.length}),t}!function(e){e.Unknown="Unknown",e.IE="Internet Explorer",e.Safari="Safari",e.Edge="Edge",e.Chrome="Chrome",e.Firefox="Firefox Mozilla",e.Mobile="Mobile"}(pe||(pe={}));const me={fromASN:e=>{const t=e.valueBlock.valueHex;return new Uint8Array(t)[0]?e.valueBlock.valueHex:e.valueBlock.valueHex.slice(1)},toASN:e=>{const t=new Uint8Array(e)[0]>127?ge(new Uint8Array([0]),new Uint8Array(e)):new Uint8Array(e);return new Z({valueHex:new Uint8Array(t).buffer})}};class de{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}l([ee({type:Q.Integer,converter:se})],de.prototype,"version",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"n",converter:ye})],de.prototype,"modulus",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"e",converter:ye})],de.prototype,"publicExponent",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"d",converter:ye})],de.prototype,"privateExponent",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"p",converter:ye})],de.prototype,"prime1",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"q",converter:ye})],de.prototype,"prime2",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"dp",converter:ye})],de.prototype,"exponent1",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"dq",converter:ye})],de.prototype,"exponent2",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"qi",converter:ye})],de.prototype,"coefficient",void 0),l([ee({type:Q.Any,optional:!0})],de.prototype,"otherPrimeInfos",void 0);class ve{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}l([ee({type:Q.Integer,converter:me}),ce({name:"n",converter:ye})],ve.prototype,"modulus",void 0),l([ee({type:Q.Integer,converter:me}),ce({name:"e",converter:ye})],ve.prototype,"publicExponent",void 0);let ke=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){let e=new Uint8Array(this.value);if(4!==e[0])throw new y("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");const t=(e=new Uint8Array(this.value.slice(1))).length/2;return{x:f.ToBase64Url(e.buffer.slice(0,0+t)),y:f.ToBase64Url(e.buffer.slice(0+t,0+t+t))}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");if(!("y"in e))throw new Error("y: Missing required property");const t=f.FromBase64Url(e.x),r=f.FromBase64Url(e.y),n=ge(new Uint8Array([4]),new Uint8Array(t),new Uint8Array(r));return this.value=new Uint8Array(n).buffer,this}};l([ee({type:Q.OctetString})],ke.prototype,"value",void 0),ke=l([te({type:Y.Choice})],ke);class we{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(e){if(!("d"in e))throw new Error("d: Missing required property");if(this.privateKey=f.FromBase64Url(e.d),"x"in e){const t=new ke;t.fromJSON(e),this.publicKey=ne.toASN(t).valueBlock.valueHex}return this}toJSON(){const e={};return e.d=f.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(e,new ke(this.publicKey).toJSON()),e}}l([ee({type:Q.Integer,converter:se})],we.prototype,"version",void 0),l([ee({type:Q.OctetString})],we.prototype,"privateKey",void 0),l([ee({context:0,type:Q.Any,optional:!0})],we.prototype,"parameters",void 0),l([ee({context:1,type:Q.BitString,optional:!0})],we.prototype,"publicKey",void 0);const be={fromASN:e=>{const t=new Uint8Array(e.valueBlock.valueHex);return 0===t[0]?t.buffer.slice(1):t.buffer},toASN:e=>{const t=new Uint8Array(e);if(t[0]>127){const e=new Uint8Array(t.length+1);return e.set(t,1),new Z({valueHex:e})}return new Z({valueHex:e})}};class Be{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}}l([ee({type:Q.Integer,converter:be})],Be.prototype,"r",void 0),l([ee({type:Q.Integer,converter:be})],Be.prototype,"s",void 0);class Ae extends H{constructor(e,t,r,n){super(),this.extractable=t,this.type=r,this.usages=n,this.algorithm=s({},e)}}function Se(e,t){return e.name.toUpperCase()===t.toUpperCase()}class xe extends Ae{constructor(e,t,r,n){super(e,t,"secret",r),this.raw=n}toJSON(){return{kty:"oct",alg:this.getJwkAlgorithm(),k:f.ToBase64Url(this.raw),ext:this.extractable,key_ops:this.usages}}getJwkAlgorithm(){switch(this.algorithm.name.toUpperCase()){case"AES-CBC":return`A${this.algorithm.length}CBC`;case"AES-CTR":return`A${this.algorithm.length}CTR`;case"AES-GCM":return`A${this.algorithm.length}GCM`;case"AES-ECB":return`A${this.algorithm.length}ECB`;default:throw new p("Unsupported algorithm name")}}}class Ce{static checkLib(){if("undefined"===typeof asmCrypto)throw new m("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project")}static checkCryptoKey(e){if(!(e instanceof xe))throw new TypeError("key: Is not AesCryptoKey")}static async generateKey(e,t,r){this.checkLib();const n=a.getRandomValues(new Uint8Array(e.length/8));return new xe(e,t,r,n)}static async encrypt(e,t,r){return this.cipher(e,t,r,!0)}static async decrypt(e,t,r){return this.cipher(e,t,r,!1)}static async exportKey(e,t){switch(this.checkLib(),e){case"jwk":return t.toJSON();case"raw":return t.raw.buffer;default:throw new m("format: Must be 'jwk' or 'raw'")}}static async importKey(e,t,r,n,s){let i;switch(this.checkLib(),(i=k(t)?f.FromBase64Url(t.k):v.toArrayBuffer(t)).byteLength<<3){case 128:case 192:case 256:break;default:throw new m("keyData: Is wrong key length")}return new xe({name:r.name,length:i.byteLength<<3},n,s,new Uint8Array(i))}static async cipher(e,t,r,n){this.checkLib();const s=n?"encrypt":"decrypt";let i;if(Se(e,Ce.AesCBC)){const n=v.toArrayBuffer(e.iv);i=asmCrypto.AES_CBC[s](r,t.raw,void 0,n)}else if(Se(e,Ce.AesGCM)){const n=v.toArrayBuffer(e.iv);let o;e.additionalData&&(o=v.toArrayBuffer(e.additionalData));const a=(e.tagLength||128)/8;i=asmCrypto.AES_GCM[s](r,t.raw,n,o,a)}else{if(!Se(e,Ce.AesECB))throw new m("algorithm: Is not recognized");i=asmCrypto.AES_ECB[s](r,t.raw,!0)}return i.buffer}}Ce.AesCBC="AES-CBC",Ce.AesECB="AES-ECB",Ce.AesGCM="AES-GCM";class Ne extends B{async onGenerateKey(e,t,r){return Ce.generateKey(e,t,r)}async onEncrypt(e,t,r){return Ce.encrypt(e,t,r)}async onDecrypt(e,t,r){return Ce.decrypt(e,t,r)}async onExportKey(e,t){return Ce.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ce.importKey(e,t,r,n,s)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Ce.checkCryptoKey(e)}}class Ee extends S{async onGenerateKey(e,t,r){return Ce.generateKey(e,t,r)}async onEncrypt(e,t,r){return Ce.encrypt(e,t,r)}async onDecrypt(e,t,r){return Ce.decrypt(e,t,r)}async onExportKey(e,t){return Ce.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ce.importKey(e,t,r,n,s)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Ce.checkCryptoKey(e)}}class Ke extends x{async onGenerateKey(e,t,r){return Ce.generateKey(e,t,r)}async onEncrypt(e,t,r){return Ce.encrypt(e,t,r)}async onDecrypt(e,t,r){return Ce.decrypt(e,t,r)}async onExportKey(e,t){return Ce.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ce.importKey(e,t,r,n,s)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Ce.checkCryptoKey(e)}}class Ue extends A{async onEncrypt(e,t,r){throw new Error("Method not implemented.")}async onDecrypt(e,t,r){throw new Error("Method not implemented.")}async onGenerateKey(e,t,r){throw new Error("Method not implemented.")}async onExportKey(e,t){throw new Error("Method not implemented.")}async onImportKey(e,t,r,n,s){throw new Error("Method not implemented.")}}class Oe extends C{async onEncrypt(e,t,r){throw new Error("Method not implemented.")}async onDecrypt(e,t,r){throw new Error("Method not implemented.")}async onGenerateKey(e,t,r){throw new Error("Method not implemented.")}async onExportKey(e,t){throw new Error("Method not implemented.")}async onImportKey(e,t,r,n,s){throw new Error("Method not implemented.")}}class Le extends Ae{constructor(e,t,r,n,s){super(e,t,r,n),this.data=s}}class Pe{static checkLib(){if("undefined"===typeof asmCrypto)throw new m("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project")}static checkCryptoKey(e){if(!(e instanceof Le))throw new TypeError("key: Is not RsaCryptoKey")}static async generateKey(e,t,r){this.checkLib();const n=3===e.publicExponent[0]?3:65537,i=asmCrypto.RSA.generateKey(e.modulusLength,n),o=e.hash.name.toUpperCase();return{privateKey:new Le(s({},e,{hash:{name:o}}),t,"private",r.filter(e=>~this.privateUsages.indexOf(e)),i),publicKey:new Le(s({},e,{hash:{name:o}}),!0,"public",r.filter(e=>~this.publicUsages.indexOf(e)),i)}}static async exportKey(e,t){switch(this.checkLib(),e){case"pkcs8":return this.exportPkcs8Key(t);case"spki":return this.exportSpkiKey(t);case"jwk":return this.exportJwkKey(t);default:throw new m("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async importKey(e,t,r,n,i){let o;switch(this.checkLib(),e){case"pkcs8":o=this.importPkcs8Key(t);break;case"spki":o=this.importSpkiKey(t);break;case"jwk":o=this.importJwkKey(t);break;default:throw new m("format: Must be 'jwk', 'pkcs8' or 'spki'")}return new Le(s({publicExponent:1===o[1][1]?o[1].slice(1):o[1].slice(3),modulusLength:o[0].byteLength<<3},r),n,2===o.length?"public":"private",i,o)}static exportPkcs8Key(e){const t=new ue;return t.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",t.privateKeyAlgorithm.parameters=null,t.privateKey=ne.serialize(this.exportAsmKey(e.data)),ne.serialize(t)}static importPkcs8Key(e){const t=re.parse(e,ue),r=re.parse(t.privateKey,de);return this.importAsmKey(r)}static importSpkiKey(e){const t=re.parse(e,fe),r=re.parse(t.publicKey,ve);return this.importAsmKey(r)}static exportSpkiKey(e){const t=new ve;t.modulus=e.data[0].buffer,t.publicExponent=1===e.data[1][1]?e.data[1].buffer.slice(1):e.data[1].buffer.slice(3);const r=new fe;return r.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",r.publicKeyAlgorithm.parameters=null,r.publicKey=ne.serialize(t),ne.serialize(r)}static importJwkKey(e){let t;return t=e.d?ae.fromJSON(e,{targetSchema:de}):ae.fromJSON(e,{targetSchema:ve}),this.importAsmKey(t)}static exportJwkKey(e){const t=this.exportAsmKey(e.data),r=oe.toJSON(t);return r.ext=!0,r.key_ops=e.usages,r.kty="RSA",r.alg=this.getJwkAlgorithm(e.algorithm),r}static getJwkAlgorithm(e){switch(e.name.toUpperCase()){case"RSA-OAEP":const t=/(\d+)$/.exec(e.hash.name)[1];return`RSA-OAEP${"1"!==t?`-${t}`:""}`;case"RSASSA-PKCS1-V1_5":return`RS${/(\d+)$/.exec(e.hash.name)[1]}`;case"RSA-PSS":return`PS${/(\d+)$/.exec(e.hash.name)[1]}`;default:throw new m("algorithm: Is not recognized")}}static exportAsmKey(e){let t;if(e.length>2){const r=new de;r.privateExponent=e[2].buffer,r.prime1=e[3].buffer,r.prime2=e[4].buffer,r.exponent1=e[5].buffer,r.exponent2=e[6].buffer,r.coefficient=e[7].buffer,t=r}else t=new ve;return t.modulus=e[0].buffer,t.publicExponent=1===e[1][1]?e[1].buffer.slice(1):e[1].buffer.slice(3),t}static importAsmKey(e){const t=new Uint8Array(4-e.publicExponent.byteLength),r=[new Uint8Array(e.modulus),ge(t,new Uint8Array(e.publicExponent))];return e instanceof de&&(r.push(new Uint8Array(e.privateExponent)),r.push(new Uint8Array(e.prime1)),r.push(new Uint8Array(e.prime2)),r.push(new Uint8Array(e.exponent1)),r.push(new Uint8Array(e.exponent2)),r.push(new Uint8Array(e.coefficient))),r}}Pe.RsaSsa="RSASSA-PKCS1-v1_5",Pe.RsaPss="RSA-PSS",Pe.RsaOaep="RSA-OAEP",Pe.privateUsages=["sign","decrypt","unwrapKey"],Pe.publicUsages=["verify","encrypt","wrapKey"];class Te extends O{async onGenerateKey(e,t,r){return Pe.generateKey(e,t,r)}async onExportKey(e,t){return Pe.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Pe.importKey(e,t,r,n,s)}async onEncrypt(e,t,r){return Pe.checkLib(),this.cipher(e,t,r,!0)}async onDecrypt(e,t,r){return Pe.checkLib(),this.cipher(e,t,r,!1)}cipher(e,t,r,n){const s=this.getOperation(t.algorithm,n);let i;return e.label&&(i=v.toArrayBuffer(e.label)),s(r,t.data,i).slice(0).buffer}getOperation(e,t){const r=t?"encrypt":"decrypt";switch(e.hash.name){case"SHA-1":return asmCrypto.RSA_OAEP_SHA1[r];case"SHA-256":return asmCrypto.RSA_OAEP_SHA256[r];case"SHA-512":return asmCrypto.RSA_OAEP_SHA512[r];default:throw new p("keyAlgorithm.hash: Is not recognized")}}}class He extends U{async onGenerateKey(e,t,r){return Pe.generateKey(e,t,r)}async onExportKey(e,t){return Pe.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Pe.importKey(e,t,r,n,s)}async onSign(e,t,r){return Pe.checkLib(),this.getOperation(t.algorithm,!0)(r,t.data,e.saltLength).buffer}async onVerify(e,t,r,n){return Pe.checkLib(),this.getOperation(t.algorithm,!1)(r,n,t.data,e.saltLength)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Pe.checkCryptoKey(e)}getOperation(e,t){const r=t?"sign":"verify";switch(e.hash.name){case"SHA-1":return asmCrypto.RSA_PSS_SHA1[r];case"SHA-256":return asmCrypto.RSA_PSS_SHA256[r];case"SHA-512":return asmCrypto.RSA_PSS_SHA512[r];default:throw new p("keyAlgorithm.hash: Is not recognized")}}}class Ie extends K{async onGenerateKey(e,t,r){return Pe.generateKey(e,t,r)}async onExportKey(e,t){return Pe.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Pe.importKey(e,t,r,n,s)}async onSign(e,t,r){return Pe.checkLib(),this.getOperation(t.algorithm,!0)(r,t.data).buffer}async onVerify(e,t,r,n){return Pe.checkLib(),this.getOperation(t.algorithm,!1)(r,n,t.data)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Pe.checkCryptoKey(e)}getOperation(e,t){const r=t?"sign":"verify";switch(e.hash.name){case"SHA-1":return asmCrypto.RSA_PKCS1_v1_5_SHA1[r];case"SHA-256":return asmCrypto.RSA_PKCS1_v1_5_SHA256[r];case"SHA-512":return asmCrypto.RSA_PKCS1_v1_5_SHA512[r];default:throw new p("keyAlgorithm.hash: Is not recognized")}}}const Re={"1.2.840.10045.3.1.7":"P-256","P-256":"1.2.840.10045.3.1.7","1.3.132.0.34":"P-384","P-384":"1.3.132.0.34","1.3.132.0.35":"P-521","P-521":"1.3.132.0.35","1.3.132.0.10":"K-256","K-256":"1.3.132.0.10"};function De(e){const t=Re[e];if(!t)throw new m(`Cannot convert WebCrypto named curve '${e}' to OID`);return t}class Je extends Ae{constructor(e,t,r,n,s){super(e,t,r,n),this.data=s}}class Ve{static checkLib(){if("undefined"===typeof elliptic)throw new m("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/elliptic.js' script to your project")}static async generateKey(e,t,r){this.checkLib();const n=this.initEcKey(e.namedCurve).genKeyPair();return n.getPublic(),{privateKey:new Je(s({},e),t,"private",r.filter(e=>~this.privateUsages.indexOf(e)),n),publicKey:new Je(s({},e),!0,"public",r.filter(e=>~this.publicUsages.indexOf(e)),n)}}static checkCryptoKey(e){if(!(e instanceof Je))throw new TypeError("key: Is not EcCryptoKey")}static concat(...e){const t=new Uint8Array(e.map(e=>e.length).reduce((e,t)=>e+t));let r=0;return e.forEach((e,n)=>{for(let s=0;s<e.length;s++)t[r+s]=e[s];r+=e.length}),t}static async exportKey(e,t){switch(this.checkLib(),e){case"pkcs8":return this.exportPkcs8Key(t);case"spki":return this.exportSpkiKey(t);case"jwk":return this.exportJwkKey(t);case"raw":return new Uint8Array(t.data.getPublic("der")).buffer;default:throw new m("format: Must be 'jwk', 'raw, 'pkcs8' or 'spki'")}}static async importKey(e,t,r,n,i){let o;switch(this.checkLib(),e){case"pkcs8":o=this.importPkcs8Key(t,r.namedCurve);break;case"spki":o=this.importSpkiKey(t,r.namedCurve);break;case"raw":o=this.importEcKey(new ke(t),r.namedCurve);break;case"jwk":o=this.importJwkKey(t);break;default:throw new m("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}return new Je(s({},r),n,o.priv?"private":"public",i,o)}static getNamedCurve(e){const t=e.toUpperCase();let r="";if(["P-256","P-384","P-521"].indexOf(t)>-1)r=t.replace("-","").toLowerCase();else{if("K-256"!==t)throw new m(`Unsupported named curve '${e}'`);r="secp256k1"}return r}static initEcKey(e){return elliptic.ec(this.getNamedCurve(e))}static exportPkcs8Key(e){const t=new ue;return t.privateKeyAlgorithm.algorithm=this.ASN_ALGORITHM,t.privateKeyAlgorithm.parameters=ne.serialize(new le(De(e.algorithm.namedCurve))),t.privateKey=ne.serialize(this.exportEcKey(e)),ne.serialize(t)}static importPkcs8Key(e,t){const r=re.parse(e,ue),n=re.parse(r.privateKey,we);return this.importEcKey(n,t)}static importSpkiKey(e,t){const r=re.parse(e,fe),n=new ke(r.publicKey);return this.importEcKey(n,t)}static exportSpkiKey(e){const t=new ke(new Uint8Array(e.data.getPublic("der")).buffer),r=new fe;return r.publicKeyAlgorithm.algorithm=this.ASN_ALGORITHM,r.publicKeyAlgorithm.parameters=ne.serialize(new le(De(e.algorithm.namedCurve))),r.publicKey=t.value,ne.serialize(r)}static importJwkKey(e){let t;return t=e.d?ae.fromJSON(e,{targetSchema:we}):ae.fromJSON(e,{targetSchema:ke}),this.importEcKey(t,e.crv)}static exportJwkKey(e){const t=this.exportEcKey(e),r=oe.toJSON(t);return r.ext=!0,r.key_ops=e.usages,r.crv=e.algorithm.namedCurve,r.kty="EC",r}static exportEcKey(e){if("private"===e.type){const t=new we,r=new Uint8Array(e.data.getPrivate("der").toArray()),n=new Uint8Array(this.getPointSize(e.algorithm.namedCurve)-r.length);return t.privateKey=ge(n,r),t.publicKey=new Uint8Array(e.data.getPublic("der")),t}if(e.data.pub)return new ke(new Uint8Array(e.data.getPublic("der")).buffer);throw new Error("Cannot get private or public key")}static importEcKey(e,t){const r=this.initEcKey(t);return e instanceof ke?r.keyFromPublic(new Uint8Array(e.value)):r.keyFromPrivate(new Uint8Array(e.privateKey))}static getPointSize(e){switch(e){case"P-256":case"K-256":return 32;case"P-384":return 48;case"P-521":return 66}throw new Error("namedCurve: Is not recognized")}}Ve.privateUsages=["sign","deriveKey","deriveBits"],Ve.publicUsages=["verify"],Ve.ASN_ALGORITHM="1.2.840.10045.2.1";class je extends I{async onGenerateKey(e,t,r){return Ve.generateKey(e,t,r)}async onExportKey(e,t){return Ve.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ve.importKey(e,t,r,n,s)}async onDeriveBits(e,t,r){Ve.checkLib();const n=t.data.derive(e.public.data.getPublic());let s=new Uint8Array(n.toArray()),i=s.length;return i=i>32?i>48?66:48:32,s.length<i&&(s=Ve.concat(new Uint8Array(i-s.length),s)),s.slice(0,r/8).buffer}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Ve.checkCryptoKey(e)}}function Me(e){const t=new Uint8Array(e),r=[];for(let n=0;n<t.length;n++)r.push(t[n]);return r}function Fe(e,t){let r="";for(let n=0;n<e.length;n++){const t=e[n].toString(16);r+=t.length%2?"0"+t:t}if(t){let t=e.length;t=t>32?t>48?66:48:32,r.length/2<t&&(r=new Array(2*t-r.length+1).join("0")+r)}return r}class _e extends P{async onGenerateKey(e,t,r){return Ve.generateKey(e,t,r)}async onExportKey(e,t){return Ve.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ve.importKey(e,t,r,n,s)}async onSign(e,t,r){Ve.checkLib();const n=new rt;let s;s=Me(await n.subtle.digest(e.hash,r));const i=await t.data.sign(s);return function(e,t){e.length%2&&(e="0"+e);let r=new Uint8Array(e.length/2);for(let n=0;n<e.length;n++){const t=e.slice(n,++n+1);r[(n-1)/2]=parseInt(t,16)}if(t){let e=r.length;e=e>32?e>48?66:48:32,r.length<e&&(r=Ve.concat(new Uint8Array(e-r.length),r))}return r}(Fe(i.r.toArray(),!0)+Fe(i.s.toArray(),!0)).buffer}async onVerify(e,t,r,n){Ve.checkLib();const s=new rt,i={r:new Uint8Array(r.slice(0,r.byteLength/2)),s:new Uint8Array(r.slice(r.byteLength/2))},o=Me(await s.subtle.digest(e.hash,n));return t.data.verify(o,i)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Ve.checkCryptoKey(e)}}class $e{static checkLib(){if("undefined"===typeof asmCrypto)throw new m("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project")}static async digest(e,t){return this.checkLib(),asmCrypto[e.name.replace("-","")].bytes(t).buffer}}class Ge extends w{constructor(){super(...arguments),this.name="SHA-1",this.usages=[]}async onDigest(e,t){return $e.digest(e,t)}}class ze extends Ge{constructor(){super(...arguments),this.name="SHA-256"}}class qe extends Ge{constructor(){super(...arguments),this.name="SHA-512"}}class We extends Ae{constructor(e,t,r,n){super(e,t,"secret",r),this.raw=n}}class Ze extends R{checkLib(){if("undefined"===typeof asmCrypto)throw new m("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project")}async onImportKey(e,t,r,n,s){return this.checkLib(),new We(r,n,s,v.toUint8Array(t))}async onDeriveBits(e,t,r){let n;this.checkLib();const s=v.toUint8Array(e.salt),i=t.raw;switch(e.hash.name.toUpperCase()){case"SHA-1":n=asmCrypto.PBKDF2_HMAC_SHA1.bytes(i,s,e.iterations,r>>3);break;case"SHA-256":n=asmCrypto.PBKDF2_HMAC_SHA256.bytes(i,s,e.iterations,r>>3);break;default:throw new m(`algorithm.hash: '${e.hash.name}' hash algorithm is not supported`)}return n.buffer}}class Xe extends Ae{constructor(e,t,r,n){super(e,t,"secret",r),this.raw=n}toJSON(){return{kty:"oct",alg:this.getJwkAlgorithm(),k:f.ToBase64Url(this.raw),ext:this.extractable,key_ops:this.usages}}getJwkAlgorithm(){switch(this.algorithm.name.toUpperCase()){case"DES-CBC":return"DES-CBC";case"DES-EDE3-CBC":return"3DES-CBC";default:throw new p("Unsupported algorithm name")}}}class Ye{static checkLib(){if("undefined"===typeof des)throw new m("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/des.js' script to your project")}static async generateKey(e,t,r){this.checkLib();const n=a.getRandomValues(new Uint8Array(e.length/8));return new Xe(e,t,r,n)}static async exportKey(e,t){switch(this.checkLib(),e){case"jwk":return t.toJSON();case"raw":return t.raw.buffer;default:throw new m("format: Must be 'jwk' or 'raw'")}}static async importKey(e,t,r,n,s){let i;if(this.checkLib(),i=k(t)?f.FromBase64Url(t.k):v.toArrayBuffer(t),"DES-CBC"===r.name&&8!==i.byteLength||"DES-EDE3-CBC"===r.name&&24!==i.byteLength)throw new m("keyData: Is wrong key length");return new Xe({name:r.name,length:i.byteLength<<3},n,s,new Uint8Array(i))}static async encrypt(e,t,r){return this.cipher(e,t,r,!0)}static async decrypt(e,t,r){return this.cipher(e,t,r,!1)}static async cipher(e,t,r,n){this.checkLib();const s=n?"encrypt":"decrypt";let i;const o=v.toUint8Array(e.iv);switch(e.name.toUpperCase()){case"DES-CBC":i=des.CBC.instantiate(des.DES).create({key:t.raw,type:s,iv:o});break;case"DES-EDE3-CBC":i=des.CBC.instantiate(des.EDE).create({key:t.raw,type:s,iv:o});break;default:throw new m("algorithm: Is not recognized")}const a=i.update(new Uint8Array(r)).concat(i.final());return new Uint8Array(a).buffer}}class Qe extends N{constructor(){super(...arguments),this.keySizeBits=64,this.ivSize=8,this.name="DES-CBC"}async onGenerateKey(e,t,r){return Ye.generateKey(e,t,r)}async onExportKey(e,t){return Ye.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ye.importKey(e,t,r,n,s)}async onEncrypt(e,t,r){return Ye.encrypt(e,t,r)}async onDecrypt(e,t,r){return Ye.decrypt(e,t,r)}}class et extends N{constructor(){super(...arguments),this.keySizeBits=192,this.ivSize=8,this.name="DES-EDE3-CBC"}async onGenerateKey(e,t,r){return Ye.generateKey(e,t,r)}async onExportKey(e,t){return Ye.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ye.importKey(e,t,r,n,s)}async onEncrypt(e,t,r){return Ye.encrypt(e,t,r)}async onDecrypt(e,t,r){return Ye.decrypt(e,t,r)}}class tt extends V{constructor(){super(),this.browserInfo=function(){const e={name:pe.Unknown,version:"0"},t=self.navigator.userAgent;let r;return(r=/edge\/([\d\.]+)/i.exec(t))?(e.name=pe.Edge,e.version=r[1]):/msie/i.test(t)?(e.name=pe.IE,e.version=/msie ([\d\.]+)/i.exec(t)[1]):/Trident/i.test(t)?(e.name=pe.IE,e.version=/rv:([\d\.]+)/i.exec(t)[1]):/chrome/i.test(t)?(e.name=pe.Chrome,e.version=/chrome\/([\d\.]+)/i.exec(t)[1]):/firefox/i.test(t)?(e.name=pe.Firefox,e.version=/firefox\/([\d\.]+)/i.exec(t)[1]):/mobile/i.test(t)?(e.name=pe.Mobile,e.version=/mobile\/([\w]+)/i.exec(t)[1]):/safari/i.test(t)&&(e.name=pe.Safari,e.version=/version\/([\d\.]+)/i.exec(t)[1]),e}(),this.providers.set(new Ne),this.providers.set(new Ue),this.providers.set(new Ee),this.providers.set(new Ke),this.providers.set(new Oe),this.providers.set(new Qe),this.providers.set(new et),this.providers.set(new Ie),this.providers.set(new He),this.providers.set(new Te),this.providers.set(new _e),this.providers.set(new je),this.providers.set(new Ge),this.providers.set(new ze),this.providers.set(new qe),this.providers.set(new Ze)}static isAnotherKey(e){return"object"===typeof e&&"string"===typeof e.type&&"boolean"===typeof e.extractable&&"object"===typeof e.algorithm&&!(e instanceof Ae)}async digest(...e){return this.wrapNative("digest",...e)}async importKey(...e){return this.fixFirefoxEcImportPkcs8(e),this.wrapNative("importKey",...e)}async exportKey(...e){return await this.fixFirefoxEcExportPkcs8(e)||await this.wrapNative("exportKey",...e)}async generateKey(...e){return this.wrapNative("generateKey",...e)}async sign(...e){return this.wrapNative("sign",...e)}async verify(...e){return this.wrapNative("verify",...e)}async encrypt(...e){return this.wrapNative("encrypt",...e)}async decrypt(...e){return this.wrapNative("decrypt",...e)}async wrapKey(...e){return this.wrapNative("wrapKey",...e)}async unwrapKey(...e){return this.wrapNative("unwrapKey",...e)}async deriveBits(...e){return this.wrapNative("deriveBits",...e)}async deriveKey(...e){return this.wrapNative("deriveKey",...e)}async wrapNative(e,...t){~["generateKey","unwrapKey","deriveKey","importKey"].indexOf(e)&&this.fixAlgorithmName(t);try{if("digest"!==e||!t.some(e=>e instanceof Ae)){return i.info(`Call native '${e}' method`,t),await c[e].apply(c,t)}}catch(r){i.warn(`Error on native '${e}' calling. ${r.message}`,r)}if("wrapKey"===e)try{i.info("Trying to wrap key by using native functions",t);const e=await this.exportKey(t[0],t[1]),n="jwk"===t[0]?f.FromUtf8String(JSON.stringify(e)):e;return await this.encrypt(t[3],t[2],n)}catch(r){i.warn(`Cannot wrap key by native functions. ${r.message}`,r)}if("unwrapKey"===e)try{i.info("Trying to unwrap key by using native functions",t);const e=await this.decrypt(t[3],t[2],t[1]),n="jwk"===t[0]?JSON.parse(f.ToUtf8String(e)):e;return await this.importKey(t[0],n,t[4],t[5],t[6])}catch(r){i.warn(`Cannot unwrap key by native functions. ${r.message}`,r)}if("deriveKey"===e)try{i.info("Trying to derive key by using native functions",t);const e=await this.deriveBits(t[0],t[1],t[2].length);return await this.importKey("raw",e,t[2],t[3],t[4])}catch(r){i.warn(`Cannot derive key by native functions. ${r.message}`,r)}if("deriveBits"===e||"deriveKey"===e)for(const n of t)"object"===typeof n&&n.public&&tt.isAnotherKey(n.public)&&(n.public=await this.castKey(n.public));for(let n=0;n<t.length;n++){const e=t[n];tt.isAnotherKey(e)&&(t[n]=await this.castKey(e))}return super[e].apply(this,t)}async castKey(e){if(i.info("Cast native CryptoKey to linter key.",e),!e.extractable)throw new Error("Cannot cast unextractable crypto key");const t=this.getProvider(e.algorithm.name),r=await this.exportKey("jwk",e);return t.importKey("jwk",r,e.algorithm,!0,e.usages)}fixAlgorithmName(e){if(this.browserInfo.name===pe.Edge)for(let t=0;t<e.length;t++){const r=e[0];if("string"===typeof r){for(const n of this.providers.algorithms)if(n.toLowerCase()===r.toLowerCase()){e[t]=n;break}}else if("object"===typeof r&&"string"===typeof r.name)for(const e of this.providers.algorithms)e.toLowerCase()===r.name.toLowerCase()&&(r.name=e),("string"===typeof r.hash&&e.toLowerCase()===r.hash.toLowerCase()||"object"===typeof r.hash&&"string"===typeof r.hash.name&&e.toLowerCase()===r.hash.name.toLowerCase())&&(r.hash={name:e})}}fixFirefoxEcImportPkcs8(e){const t=this.prepareAlgorithm(e[2]),r=t.name.toUpperCase();if(this.browserInfo.name===pe.Firefox&&"pkcs8"===e[0]&&~["ECDSA","ECDH"].indexOf(r)&&~["P-256","P-384","P-521"].indexOf(t.namedCurve)){if(!v.isBufferSource(e[1]))throw new TypeError("data: Is not ArrayBuffer or ArrayBufferView");const r=v.toArrayBuffer(e[1]),n=re.parse(r,ue),s=re.parse(n.privateKey,we),i=oe.toJSON(s);i.ext=!0,i.key_ops=e[4],i.crv=t.namedCurve,i.kty="EC",e[0]="jwk",e[1]=i}}async fixFirefoxEcExportPkcs8(e){try{if(this.browserInfo.name===pe.Firefox&&"pkcs8"===e[0]&&~["ECDSA","ECDH"].indexOf(e[1].algorithm.name)&&~["P-256","P-384","P-521"].indexOf(e[1].algorithm.namedCurve)){const t=await this.exportKey("jwk",e[1]),r=ae.fromJSON(t,{targetSchema:we}),n=new ue;return n.privateKeyAlgorithm.algorithm=Ve.ASN_ALGORITHM,n.privateKeyAlgorithm.parameters=ne.serialize(new le(De(e[1].algorithm.namedCurve))),n.privateKey=ne.serialize(r),ne.serialize(n)}}catch(it){return i.error(it),null}}}tt.methods=["digest","importKey","exportKey","sign","verify","generateKey","encrypt","decrypt","deriveBits","deriveKey","wrapKey","unwrapKey"];class rt extends D{constructor(){super(...arguments),this.subtle=new tt}getRandomValues(e){return a.getRandomValues(e)}}Math.imul||(Math.imul=function(e,t){const r=65535&e,n=65535&t;return r*n+((e>>>16&65535)*n+r*(t>>>16&65535)<<16>>>0)|0});const nt=self;a&&Object.freeze(a.getRandomValues);try{delete self.crypto,nt.crypto=new rt,Object.freeze(nt.crypto)}catch(ot){i.error(ot)}const st=nt.crypto;t.crypto=st}({})}).call(this,r("tjlA").Buffer)}}]);